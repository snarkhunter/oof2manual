<!-- 
  This software was produced by NIST, an agency of the
  U.S. government, and by statute is not subject to copyright in the
  United States.  Recipients of this software assume all
  responsibilities associated with its operation, modification and
  maintenance. However, to facilitate maintenance we ask that before
  distributing modified versions of this software, you first contact
  the authors at oof_manager@nist.gov.
-->

<refentry id="Class-FieldIndex">
  <refnamediv>
	<refname>FieldIndex</refname>
	<refpurpose>Base class for index objects</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
	<title>Synopses</title>
	<refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
#include "engine/fieldindex.h"
	    <classsynopsis language="cpp">
	      <ooclass>
		    <classname>FieldIndex</classname>
	      </ooclass>
	      <methodsynopsis>
		    <modifier>virtual</modifier>
		    <type>FieldIndex*</type>
		    <methodname><link
		                    linkend="Class-FieldIndex-clone">clone</link></methodname>
		    <void/>
		    <modifier>const</modifier>
	      </methodsynopsis>
	      <methodsynopsis>
		    <modifier>virtual</modifier>
		    <type>int</type>
		    <methodname><link
		                    linkend="Class-FieldIndex-integer">integer</link></methodname>
            <void/>
		    <modifier>const</modifier>
	      </methodsynopsis>
	      <methodsynopsis>
		    <modifier>virtual</modifier>
		    <type>bool</type>
		    <methodname><link
		                    linkend="Class-FieldIndex-in_plane">in_plane</link></methodname>
		    <void/>
		    <modifier>const</modifier>
	      </methodsynopsis>
	    </classsynopsis>
	  </literallayout>
	</refsect2><!-- C++ Synopsis -->
	<refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine.fieldindex import FieldIndex </literallayout>
      <classsynopsis language="python">
	    <ooclass>
		  <classname>FieldIndex</classname>
	    </ooclass>
	    <methodsynopsis>
		  <methodname><link
		                  linkend="Class-FieldIndex-integer">integer</link></methodname>
          <void/>
	    </methodsynopsis>
	    <methodsynopsis>
		  <methodname><link
		                  linkend="Class-FieldIndex-in_plane">in_plane</link></methodname>
		  <void/>
	    </methodsynopsis>
	  </classsynopsis>
	</refsect2><!-- Python Synopsis -->
	<refsect2>
	  <title>Derived Classes</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara>
		    <link
		        linkend="Class-ScalarFieldIndex"><classname>ScalarFieldIndex</classname></link>
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		    <link
		        linkend="Class-VectorFieldIndex"><classname>VectorFieldIndex</classname></link>
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		    <link
		        linkend="Class-SymTensorIndex"><classname>SymTensorIndex</classname></link>
	      </simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2>
	<refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.h</filename>:
		  C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.C</filename>:
		  C++ source code</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.swg</filename>:
	      SWIG source code</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.spy</filename>:
	      python code included in the swig output</simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2><!-- Source Files -->
  </refsynopsisdiv>
  <refsection>
	<title>Description</title>
	<para>
	  <classname>FieldIndex</classname> is the abstract base class
	  for classes which refer to the components of
	  multi-dimensional <link
	  linkend="Class-Field"><classname>Fields</classname></link>,
	  <link
	      linkend="Class-Flux"><classname>Fluxes</classname></link>,
	  and <link
	  linkend="Class-Equation"><classname>Equations</classname></link>.
	  The different subclasses refer to components of
	  scalars,<footnote>
	  <simpara>Trivially.</simpara>
	</footnote>
	vectors, and tensors.
	</para>
    <para>
      In C++, a <classname>FieldIndex</classname> is usually obtained
      by looping over a &Field; or &Flux;'s <link
      linkend="Class-Field-components"><function>components</function></link>,
      or calling their <link
      linkend="Class-Field-getIndex"><function>getIndex</function></link>
      method.  In the first case, the returned index is automatically
      wrapped in an &IndexP;, which handles the deallocation of the
      <classname>FieldIndex</classname>.  In the second, the returned
      <classname>FieldIndex</classname> pointer needs to either be
      explicitly deallocated or manually wrapped in an &IndexP;.
    </para>
    <para>
      In Python there is no need for the &IndexP; class.  Whenever a
      <classname>FieldIndex</classname> object is returned from a C++
      function to Python, it is converted into an object of the
      appropriate derived class.  Thus, in Python every
      <classname>FieldIndex</classname> object is explicitly a <link
      linkend="Class-ScalarFieldIndex"><classname>ScalarFieldIndex</classname></link>
      object, <link
      linkend="Class-VectorFieldIndex"><classname>VectorFieldIndex</classname></link>
      object, or other subclass of <classname>FieldIndex</classname>.
    </para>
  </refsection><!-- Description -->
  <refsection>
	<title>Methods</title>
	<refsection id="Class-FieldIndex-clone">
	  <title><code>virtual FieldIndex *clone() const</code></title>
	  <para>
	    <methodname>clone</methodname> returns a pointer to a new copy
	    of the <classname>FieldIndex</classname> object of the same
	    type.  The pointer must be explicitly deallocated.  Using an
	    &IndexP; instead of a <classname>FieldIndex</classname>
	    obviates the need for explicit deallocation.
	  </para>
	</refsection><!-- clone -->
	<refsection id="Class-FieldIndex-integer">
	  <title><code>virtual int integer() const</code></title>
	  <para>
	    Every kind of <link
	    linkend="Class-FieldIndex"><classname>FieldIndex</classname></link>
	    has a canonical ordering of the indices that it
	    represents.  For example, a <link
	    linkend="Class-VectorFieldIndex"><classname>VectorFieldIndex</classname></link>
	    takes the values <emphasis>x, y, z</emphasis> in that
	    order, and a <link
	    linkend="Class-SymTensorIndex"><classname>SymTensorIndex</classname></link>
	    takes the values <emphasis>xx, yy, zz, yz, xz,
	    xy</emphasis>, in that order.
	    <methodname>FieldIndex::integer</methodname> returns the
	    current value's position in the canonical list. 
	  </para>
	  <para>
	    <methodname>integer</methodname> is used whenever an
	    <classname>FieldIndex</classname> needs to determine a
	    position in a Python list, C++
	    <classname>std::vector</classname>, or other linear storage
	    structure.  It may also be used in some situations where
	    functions weren't designed to accept the more abstract
	    <classname>FieldIndex</classname> or
	    &IndexP; objects, for whatever reason.
      </para>
	</refsection>
	<refsection id="Class-FieldIndex-in_plane">
	  <title><code>virtual bool in_plane() const</code></title>
	  <para>
	    <methodname>in_plane</methodname> indicates whether or not
	    the <classname>FieldIndex</classname> refers to an in-plane or
	    out-of-plane index.  For vectors, <emphasis>x</emphasis>
	    and <emphasis>y</emphasis> are in-plane and
        <emphasis>z</emphasis> is out-of-plane.  For tensors, any
	    set of indices containing a <emphasis>z</emphasis> is
	    out-of-plane.
	  </para>
	</refsection>
  </refsection>                 <!-- Methods -->
</refentry>                     <!-- FieldIndex -->

<!-- ============================================================ -->

<refentry id="Class-IndexP">
  <refnamediv>
	<refname>IndexP</refname>
	<refpurpose>Generic wrapper for index objects</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
	<title>Synopses</title>
	<refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
#include "engine/fieldindex.h" </literallayout>
	  <classsynopsis language="cpp">
	    <ooclass>
          <classname>IndexP</classname>
	    </ooclass>
	    <constructorsynopsis>
		  <methodname><link linkend="Class-IndexP-constructor">IndexP</link></methodname>
		  <methodparam>
		    <type>FieldIndex*</type>
		    <parameter>index</parameter>
		  </methodparam>
	    </constructorsynopsis>
	    <constructorsynopsis>
		  <methodname><link
		                  linkend="Class-IndexP-copyconstructor">IndexP</link></methodname>
		  <methodparam>
		    <type>const IndexP&amp;</type>
		    <parameter>other</parameter>
		  </methodparam>
	    </constructorsynopsis>
        <constructorsynopsis>
          <methodname><link
                          linkend="Class-IndexP-moveconstructor">IndexP</link></methodname>
          <methodparam>
            <type>IndexP&amp;&amp;</type>
            <parameter>other</parameter>
          </methodparam>
        </constructorsynopsis>
	    <methodsynopsis>
		  <type>IndexP</type>
		  <methodname><link
		                  linkend="Class-IndexP-cloneIndex">cloneIndex</link></methodname>
		  <void/>
		  <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
		  <type>int</type>
		  <methodname><link
		                  linkend="Class-IndexP-integer">integer</link></methodname>
		  <void/>
		  <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
		  <type>bool</type>
		  <methodname><link
		                  linkend="Class-IndexP-in_plane">in_plane</link></methodname>
		  <void/>
		  <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
		  <methodname><link
		                  linkend="Class-IndexP-FieldIndex">operator const FieldIndex&amp;</link></methodname>
		  <void/>
		  <modifier>const</modifier>
	    </methodsynopsis>
        <methodsynopsis>
		  <methodname><link
		                  linkend="Class-IndexP-FieldIndex">operator const FieldIndex*</link></methodname>
		  <void/>
		  <modifier>const</modifier>

        </methodsynopsis>
	  </classsynopsis>
	</refsect2><!-- C++ Synopsis -->
	<refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.h</filename>:
		  C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.C</filename>:
		  C++ source code</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.swg</filename>:
	      SWIG source code</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.spy</filename>:
	      python code included in the swig output</simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2><!-- Source Files -->
  </refsynopsisdiv>
  <refsection>
	<title>Description</title>
	<para>
	  <classname>IndexP</classname> is a wrapper for the various
	  &FieldIndex;
	  classes, which are used to refer to components of various
	  kinds of <link
	  linkend="Class-Field"><classname>Fields</classname></link>,
	  <link
	      linkend="Class-Flux"><classname>Fluxes</classname></link>
	  and <link
	  linkend="Class-Equation"><classname>Equations</classname></link>.
	  The wrapper is a light-weight object that allows a
	  &FieldIndex; to be used in a generic
	  fashion, while at the same time handling allocation and
	  deallocation of the &FieldIndex;
	  object.
    </para>
    <para>
      All of the public &FieldIndex;
	  methods are available in <classname>IndexP</classname>, so an
      <classname>IndexP</classname> can be treated just like a
      <classname>FieldIndex</classname>.  In C++ an
      <classname>IndexP</classname> can be implicitly converted to a
      <classname>const FieldIndex*</classname> or <classname>const
      FieldIndex&amp;</classname>, so any function expecting a
      &FieldIndex; argument can also operate on
      an <classname>IndexP</classname>.
	</para>
	<para>
	  Note that <classname>IndexP</classname> does
	  <emphasis>not</emphasis> do reference counting. It's not a smart
	  pointer class.  It's main purpose is to deallocate the
	  &FieldIndex; pointer that it holds.
	</para>
    <para>
      In Python there is no need for the <classname>IndexP</classname>
      class. Whenever a &FieldIndex; object is returned from a C++
      function to Python, it is converted into an object of the
      appropriate derived class, and Python's garbage collection
      ensures that the &FieldIndex; is destroyed when necessary.
    </para>

  </refsection><!-- description -->
  <refsection>
	<title>Methods</title>
	<refsection id="Class-IndexP-constructor">
	  <title><code>IndexP(FieldIndex *index)</code></title>
	  <para>
	    The <classname>IndexP</classname> constructor has a single
	    argument, which must be a pointer to a newly constructed
	    instance of a &FieldIndex; subclass.  The
	    <classname>IndexP</classname> takes over ownership of the
	    &FieldIndex; and will delete it when necessary.
	  </para>
	  <note>
	    <para>
	      The <classname>IndexP</classname> constructor is not
	      available in Python.  It should never be necessary to
	      construct a new <classname>IndexP</classname> in Python.
	      Most <classname>IndexP</classname> objects are
	      constructed by calling a C++ method of a
	      <classname>Field</classname> (or similar) object.
	    </para>
	  </note>
	</refsection><!-- constructor -->
	<refsection id="Class-IndexP-copyconstructor">
	  <title><code>IndexP(const IndexP&amp; other)</code></title>
	  <para>
	    The <classname>IndexP</classname> copy constructor creates
	    a copy of the underlying &FieldIndex;
	    object as well.
	  </para>
	</refsection><!-- copy constructor -->
    <refsection id="Class-IndexP-moveconstructor">
      <title><code>IndexP(const IndexP&amp;&amp; other)</code></title>
      <para>
        The <classname>IndexP</classname> move constructor takes over
        ownership of the &FieldIndex; pointer.  The new
        <classname>IndexP</classname> object will delete the
        &FieldIndex; when the <classname>IndexP</classname> is
        destroyed.
      </para>
    </refsection>               <!-- move constructor -->
	<refsection id="Class-IndexP-cloneIndex">
	  <title><code>IndexP cloneIndex() const</code></title>
	  <para>
	    <methodname>cloneIndex</methodname> is just a wrapper for
	    the copy constructor.  It's useful to have an explicit
	    name for this operation when it's invoked from <link
	    linkend="Class-IteratorP"><classname>IteratorP</classname></link>,
	    which is derived from <classname>IndexP</classname>.
	  </para>
	</refsection><!-- cloneIndex -->
	<refsection id="Class-IndexP-integer">
	  <title><code>int integer() const()</code></title>
	  <para>
        See <link linkend="Class-FieldIndex-integer"><methodname>FieldIndex::integer</methodname></link>.
	  </para>
	</refsection><!-- integer -->
	<refsection id="Class-IndexP-in_plane">
	  <title><code>bool in_plane() const</code></title>
	  <para>
	  </para>
	</refsection><!-- in_plane -->
	<refsection id="Class-IndexP-FieldIndex">
	  <title>
        <code>operator const FieldIndex&amp;() const</code> and
        <code>operator const FieldIndex*() const</code>
      </title>
	  <para>
	    These operators convert an <classname>IndexP</classname> to
	    a reference or pointer to a <code>const</code>
	    &FieldIndex;.  This operation is not necessary in Python.
	  </para>
	</refsection><!-- operator const FieldIndex -->
  </refsection>                 <!-- Methods -->
</refentry>                     <!-- IndexP -->

<!-- ============================================================ -->

<refentry id="Class-ScalarFieldIndex">
  <refnamediv>
	<refname>ScalarFieldIndex</refname>
	<refpurpose>Index object for a scalar Field</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
	<title>Synopses</title>
	<refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
#include "engine/fieldindex.h" </literallayout>
	  <classsynopsis language="cpp">
	    <ooclass>
		  <classname>ScalarFieldIndex</classname>
	    </ooclass>
	    <ooclass>
		  <modifier>virtual public</modifier>
		  <classname><link linkend="Class-FieldIndex">FieldIndex</link></classname>
	    </ooclass>
	  </classsynopsis>
	</refsect2>                 <!-- C++ Synopsis -->
	<refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine.fieldindex import ScalarFieldIndex </literallayout>
      <classsynopsis language="python">
	    <ooclass>
		  <classname>ScalarFieldIndex</classname>
	    </ooclass>
	    <ooclass>
		  &FieldIndex;
	    </ooclass>
	  </classsynopsis>
	</refsect2>                 <!-- Python Synopsis -->
	<refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.h</filename>:
		  C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.C</filename>:
		  C++ source code</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.swg</filename>:
	      SWIG source code</simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2><!-- Source Files -->
  </refsynopsisdiv>
  <refsection>
	<title>Description</title>
	<para>
	  For &oof2;'s component addressing mechanism to be generic, all
	  subclasses of <link
	  linkend="Class-Field"><classname>Field</classname></link> must
	  have an associated &FieldIndex; type.
	  <classname>ScalarFieldIndex</classname> is the &FieldIndex; for
	  <link
	  linkend="Class-ScalarField"><classname>ScalarField</classname></link>.
	  It is a trivial class &mdash; it stores no data and most of its
	  methods are no-ops &mdash; since scalar fields have only one
	  component.
	</para>
    <para>
      Specifically,
      <itemizedlist>
        <listitem>
          <para>
            <code>ScalarFieldIndex::integer()</code> always returns 0.
          </para>
        </listitem>
        <listitem>
          <para>
            <code>ScalarFieldIndex::in_plane()</code> always returns
            true.
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </refsection>
</refentry>                     <!-- ScalarFieldIndex -->

<!-- ============================================================ -->

<refentry id="Class-VectorFieldIndex">
  <refnamediv>
	<refname>VectorFieldIndex</refname>
	<refpurpose>Index a vector field</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
	<title>Synopses</title>
	<refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
#include "engine/fieldindex.h" </literallayout>
	  <classsynopsis language="cpp">
	    <ooclass>
		  <classname>VectorFieldIndex</classname>
	    </ooclass>
	    <ooclass>
		  <modifier>virtual public</modifier>
		  <classname><link linkend="Class-FieldIndex">FieldIndex</link></classname>
	    </ooclass>
	  </classsynopsis>
	</refsect2><!-- C++ Synopsis -->
	<refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine.fieldindex import VectorFieldIndex</literallayout>
	  <classsynopsis language="python">
	    <ooclass>
		  <classname>VectorFieldIndex</classname>
	    </ooclass>
	    <ooclass>
		  &FieldIndex;
	    </ooclass>
	  </classsynopsis>
	</refsect2><!-- Python Synopsis -->
	<refsect2>
	  <title>Derived Classes</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><link
		               linkend="Class-OutOfPlaneVectorFieldIndex"><classname>OutOfPlaneVectorFieldIndex</classname></link></simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		    <link
		        linkend="Class-VectorFieldIterator"><classname>VectorFieldIterator</classname></link>
	      </simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2><!-- Derived Classes -->
	<refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.h</filename>:
		  C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.C</filename>:
		  C++ source code</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.swg</filename>:
	      SWIG source code</simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2><!-- Source Files -->
  </refsynopsisdiv>
  <refsection>
	<title>Description</title>
	<para>
	  <classname>VectorFieldIndex</classname> is used to refer to the
	  components of a vector-valued <link
	  linkend="Class-Field"><classname>Field</classname></link>, <link
	  linkend="Class-Flux"><classname>Flux</classname></link>, or
	  <link
	  linkend="Class-Equation"><classname>Equation</classname></link>.
	  It is often used within an &IndexP; wrapper.  See the &IndexP;
	  documentation for details on the available methods.
	</para>
  </refsection>
</refentry>                     <!-- VectorFieldIndex -->

<!-- ============================================================ -->

<refentry id="Class-OutOfPlaneVectorFieldIndex">
  <refnamediv>
	<refname>OutOfPlaneVectorFieldIndex</refname>
	<refpurpose>Index the out-of-plane components of a vector</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
	<title>Synopses</title>
	<refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
#include "engine/fieldindex.h" </literallayout>
	  <classsynopsis language="cpp">
	    <ooclass>
		  <classname>OutOfPlaneVectorFieldIndex</classname>
	    </ooclass>
	    <ooclass>
		  <modifier>public</modifier>
		  <classname><link linkend="Class-VectorFieldIndex">VectorFieldIndex</link></classname>
	    </ooclass>
	  </classsynopsis>
	</refsect2><!-- C++ Synopsis -->
	<refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine.fieldindex import OutOfPlaneVectorFieldIndex </literallayout>
	  <classsynopsis language="python">
	    <ooclass>
		  <classname>OutOfPlaneVectorFieldIndex</classname>
	    </ooclass>
	    <ooclass>
		  <classname>VectorFieldIndex</classname>
	    </ooclass>
	  </classsynopsis>
	</refsect2><!-- Python Synopsis -->
	<refsect2>
	  <title>Derived Classes</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara>
		    <link
		        linkend="Class-OutOfPlaneVectorFieldIterator"><classname>OutOfPlaneVectorFieldIterator</classname></link>
	      </simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2><!-- Derived Classes -->
	<refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.h</filename>:
		  C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.C</filename>:
		  C++ source code</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.swg</filename>:
	      SWIG source code</simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2><!-- Source Files -->
  </refsynopsisdiv>
  <refsection>
	<title>Description</title>
	<para>
	  The <classname>OutOfPlaneVectorFieldIndex</classname> is a
	  &FieldIndex; that only refers to the out-of-plane components of
	  a vector-valued <link
	  linkend="Class-Field"><classname>Field</classname></link>.
	</para>
	<para>
	  The <emphasis>z</emphasis> component of a vector is
	  component 0 when converted to an integer by
	  <methodname>OutOfPlaneVectorFieldIndex::integer</methodname>.
	</para>
	<para>
	  There is some potential for confusion here.  The <link
	  linkend="Class-TwoVectorField"><classname>TwoVectorField</classname></link>
	  used in &oof2; has only in-plane components, so an
	  <classname>OutOfPlaneVectorFieldIndex</classname> willl
	  never be used to refer to its components.  But
	  <classname>TwoVectorField</classname> is also a <link
	  linkend="Class-CompoundField"><classname>CompoundField</classname></link>,
	  so it has an associated <link
	  linkend="Section-Concepts-Mesh-3D"> out-of-plane
	  part</link>, which is a 3-vector of derivatives.
	  <emphasis>This</emphasis> vector has a z component,
	  <inlineequation>
	    <alt role="tex">\(\partial u_z/\partial z\)</alt>
	    </inlineequation>, which can be referred to by an
	    <classname>OutOfPlaneVectorFieldIndex</classname>.
	    Following these subtleties isn't really important, though,
	    because most of the time &FieldIndex;
	    objects are created by the <classname>Fields</classname>
	    themselves (<foreignphrase>e.g,</foreignphrase> with <link
	    linkend="Class-Field-iterator"><methodname>Field::iterator</methodname></link>,
	    which automatically does the right thing.
	</para>
  </refsection>
</refentry>                     <!-- OutOfPlaneVectorFieldIndex -->

<!-- ============================================================ -->

<refentry id="Class-SymTensorIndex">
  <refnamediv>
	<refname>SymTensorIndex</refname>
	<refpurpose>Index a symmetric 3&times;3 tensor</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
	<title>Synopses</title>
	<refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
#include "engine/fieldindex.h" </literallayout>
	  <classsynopsis language="cpp">
	    <ooclass>
		  <classname>SymTensorIndex</classname>
	    </ooclass>
	    <ooclass>
		  <modifier>public</modifier>
		  <classname><link linkend="Class-VectorFieldIndex">FieldIndex</link></classname>
	    </ooclass>
	    <methodsynopsis>
		  <type>int</type>
		  <methodname><link linkend="Class-SymTensorIndex-row">row</link></methodname>
		  <void/>
		  <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
		  <type>int</type>
		  <methodname><link linkend="Class-SymTensorIndex-col">col</link></methodname>
		  <void/>
		  <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
		  <type>bool</type>
		  <methodname><link
		                  linkend="Class-SymTensorIndex-diagonal">diagonal</link></methodname>
		  <void/>
		  <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
		  <modifier>static</modifier>
		  <type>int</type>
		  <methodname><link
		                  linkend="Class-SymTensorIndex-str2voigt">str2voigt</link></methodname>
		  <methodparam>
		    <modifier>const</modifier>
		    <type>std::string&amp;</type>
		    <parameter>str</parameter>
		  </methodparam>
	    </methodsynopsis>
	    <methodsynopsis>
		  <modifier>static</modifier>
		  <type>int</type>
		  <methodname><link
		                  linkend="Class-SymTensorIndex-ij2voigt">ij2voigt</link></methodname>
		  <methodparam>
		    <type>int</type>
		    <parameter>i</parameter>
		  </methodparam>
		  <methodparam>
		    <type>int</type>
		    <parameter>j</parameter>
		  </methodparam>
	    </methodsynopsis>
	  </classsynopsis>
	</refsect2><!-- C++ Synopsis -->
	<refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine.fieldindex import SymTensorIndex </literallayout>
	  <classsynopsis language="python">
	    <ooclass>
		  <classname>SymTensorIndex</classname>
	    </ooclass>
	    <ooclass>
		  &FieldIndex;
	    </ooclass>
	    <methodsynopsis>
		  <methodname><link linkend="Class-SymTensorIndex-row">row</link></methodname>
		  <void/>
	    </methodsynopsis>
	    <methodsynopsis>
		  <methodname><link linkend="Class-SymTensorIndex-col">col</link></methodname>
		  <void/>
	    </methodsynopsis>
	    <methodsynopsis>
		  <methodname><link
		                  linkend="Class-SymTensorIndex-diagonal">diagonal</link></methodname>
		  <void/>
		  <modifier>const</modifier>
	    </methodsynopsis>
	  </classsynopsis>
	</refsect2><!-- Python Synopsis -->
	<refsect2>
	  <title>Derived Classes</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara>
		    <link
		        linkend="Class-OutOfPlaneSymTensorIndex"><classname>OutOfPlaneSymTensorIndex</classname></link>
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
		    <link
		        linkend="Class-SymTensorIterator"><classname>SymTensorIterator</classname></link>
	      </simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2><!-- Derived Classes -->
	<refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.h</filename>:
		  C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.C</filename>:
		  C++ source code</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.swg</filename>:
	      SWIG source code</simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2><!-- Source Files -->
  </refsynopsisdiv>
  <refsection>
	<title>Description</title>
	<para>
	  <classname>SymTensorIndex</classname> is a &FieldIndex; subclass
	  used to refer to the components of a <link
	  linkend="Class-SymmMatrix3"><classname>SymmMatrix3</classname></link>
	  (symmetric 3&times;3 matrix or tensor) object.  Most of the
	  functionality comes from the base class, and is documented in
	  the &IndexP; wrapper class.
	</para>
	<para>
	  The <methodname>integer</methodname> method returns the
	  Voigt representation of the
	  <classname>SymTensorIndex</classname>, as shown in <xref
	  linkend="table:voigt"/>.
	</para>
	<table id="table:voigt">
	  <title>Voigt Indices</title>
	  <tgroup cols="4">
	    <thead>
	      <row>
		    <entry><varname>str</varname></entry>
		    <entry><varname>i</varname></entry>
		    <entry><varname>j</varname></entry>
		    <entry>Voigt</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		    <entry><literal>xx</literal></entry>
		    <entry><literal>0</literal></entry>
		    <entry><literal>0</literal></entry>
		    <entry>0</entry>
	      </row>
	      <row>
		    <entry><literal>yy</literal></entry>
		    <entry><literal>1</literal></entry>
		    <entry><literal>1</literal></entry>
		    <entry>1</entry>
	      </row>
	      <row>
		    <entry><literal>zz</literal></entry>
		    <entry><literal>2</literal></entry>
		    <entry><literal>2</literal></entry>
		    <entry>2</entry>
	      </row>
	      <row>
		    <entry><literal>yz</literal></entry>
		    <entry><literal>1</literal></entry>
		    <entry><literal>2</literal></entry>
		    <entry>3</entry>
	      </row>
	      <row>
		    <entry><literal>xz</literal></entry>
		    <entry><literal>0</literal></entry>
		    <entry><literal>2</literal></entry>
		    <entry>4</entry>
	      </row>
	      <row>
		    <entry><literal>xy</literal></entry>
		    <entry><literal>0</literal></entry>
		    <entry><literal>1</literal></entry>
		    <entry>5</entry>
	      </row>	
	    </tbody>
	  </tgroup>
	</table>
  </refsection><!-- Description -->
  <refsection>
	<title>Methods</title>
	<para>
	  Methods that are not defined in the base classes are listed here.
	</para>
	<refsection id="Class-SymTensorIndex-row">
	  <title><code>int row() const</code></title>
	  <para>
	    The matrix row referred to by the index.
	  </para>
	</refsection>
	<refsection id="Class-SymTensorIndex-col">
	  <title><code>int row() const</code></title>
	  <para>
	    The matrix column referred to by the index.
	  </para>
	</refsection>
	<refsection id="Class-SymTensorIndex-diagonal">
	  <title><code>bool diagonal() const</code></title>
	  <para>
	    This function indicates whether or not the
	    <classname>SymTensorIndex</classname> refers to one of the
	    diagonal entries, xx, yy, or zz.
	  </para>
	</refsection>
	<refsection id="Class-SymTensorIndex-str2voigt">
	  <title><code>static int str2voigt(const std::string&amp; str)</code></title>
	  <para>
	    This is a utility function that returns the integer Voigt
	    representation of a symmetric tensor index, given as a
	    string. Because &oof2; is written in C++, Voigt indices
	    start from 0.  See <xref linkend="table:voigt"/>.
	  </para>
	</refsection><!-- str2voigt -->
	<refsection id="Class-SymTensorIndex-ij2voigt">
	  <title><code>static int ij2voigt(int i, int j)</code></title>
	  <para>
	    This is a utility function that returns the integer Voigt
	    representation of a symmetric tensor index, given as a
	    pair of integers. Because &oof2; is written in C++, Voigt indices
	    start from 0.   See <xref linkend="table:voigt"/>.
	  </para>
	</refsection>
  </refsection>                 <!-- Methods -->
</refentry>                     <!-- SymTensorIndex -->

<!-- ============================================================ -->

<refentry id="Class-OutOfPlaneSymTensorIndex">
  <refnamediv>
	<refname>OutOfPlaneSymTensorIndex</refname>
	<refpurpose>Index the out-of-plane components of a 3&times;3
	symmetric tensor</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
	<title>Synopses</title>
	<refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
#include "engine/fieldindex.h" </literallayout>
	  <classsynopsis language="cpp">
	    <ooclass>
		  <classname>OutOfPlaneSymTensorIndex</classname>
	    </ooclass>
	    <ooclass>
		  <modifier>public</modifier>
		  <classname><link linkend="Class-SymTensorIndex">SymTensorIndex</link></classname>
	    </ooclass>
	  </classsynopsis>
	</refsect2><!-- C++ Synopsis -->
	<refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine.fieldindex import OutOfPlaneSymTensorIndex </literallayout>
	  <classsynopsis language="python">
	    <ooclass>
		  <classname>OutOfPlaneSymTensorIndex</classname>
	    </ooclass>
	    <ooclass>
		  <classname>SymTensorIndex</classname>
	    </ooclass>
	  </classsynopsis>
	</refsect2><!-- Python Synopsis -->
	<refsect2>
	  <title>Derived Classes</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara>
		    <link
		        linkend="Class-OutOfPlaneSymTensorIterator"><classname>OutOfPlaneSymTensorIterator</classname></link>
	      </simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2><!-- Derived Classes -->
	<refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.h</filename>:
		  C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.C</filename>:
		  C++ source code</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/fieldindex.swg</filename>:
	      SWIG source code</simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2><!-- Source Files -->
  </refsynopsisdiv>
  <refsection>
	<title>Description</title>
	<para>
	  A <classname>OutOfPlaneSymTensorIndex</classname> is a
	  &FieldIndex; that refers to the out-of-plane components of a
	  symmetric 3&times;3 tensor.  That is, the index can only take
	  the values "zz", "yz", and "xz".
	</para>
	<para>
	  <classname>OutOfPlaneSymTensorIndex</classname> are usually
	  wrapped inside an &IndexP; object.  See the &IndexP;
	  documentation for information about the available methods.
	</para>
	<para>
	  <methodname>OutOfPlaneSymTensorIndex::integer</methodname>
	  returns the Voigt index minus 2:
	  <table id="table:oopvoigt">
	    <title>Out-of-plane Voigt Indices</title>
	    <tgroup cols="4">
	      <thead>
		    <row>
		      <entry><varname>str</varname></entry>
		      <entry><varname>i</varname></entry>
		      <entry><varname>j</varname></entry>
		      <entry>Voigt</entry>
		    </row>
	      </thead>
	      <tbody>
		    <row>
		      <entry><literal>zz</literal></entry>
		      <entry><literal>2</literal></entry>
		      <entry><literal>2</literal></entry>
		      <entry>0</entry>
		    </row>
		    <row>
		      <entry><literal>yz</literal></entry>
		      <entry><literal>1</literal></entry>
		      <entry><literal>2</literal></entry>
		      <entry>1</entry>
		    </row>
		    <row>
		      <entry><literal>xz</literal></entry>
		      <entry><literal>0</literal></entry>
		      <entry><literal>2</literal></entry>
		      <entry>2</entry>
		    </row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
  </refsection>
</refentry>                     <!-- OutOfPlaneSymTensorIndex -->

<!-- ============================================================ -->


<refentry id="Class-ComponentsP">
  <refnamediv>
    <refname>ComponentsP</refname>
    <refpurpose>
      Generic wrapper for <link
      linkend="Class-Components"><classname>Components</classname></link>
      classes
    </refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopsis</title>
    <para>TODO</para>
  </refsynopsisdiv>
  <refsection>
    <title>Description</title>
    <para>
      TODO
    </para>
  </refsection>
</refentry>

<refentry id="Class-ComponentIterator">
  <refnamediv>
    <refname>ComponentIterator</refname>
    <refpurpose>
      An iterator that loops over a set of &FieldIndex;es
    </refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopsis</title>
    <para>TODO</para>
  </refsynopsisdiv>
  <refsection>
    <title>TODO</title>
    <para>TODO</para>
  </refsection>
</refentry>

<refentry id="Class-Components">
  <refnamediv>
    <refname>Components</refname>
    <refpurpose>
      Iterable object containing a set of &FieldIndex;es
    </refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopsis</title>
    <para>TODO</para>
  </refsynopsisdiv>
  <refsection>
    <title>TODO</title>
    <para>TODO</para>
  </refsection>
</refentry>

<!-- ============================================================ -->

<!-- ============================================================ -->

<refentry id="Class-Planarity">
  <refnamediv>
	<refname>Planarity</refname>
	<refpurpose>Specify the range of component iterators</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
	<refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
#include "engine/planarity.h"

enum Planarity {IN_PLANE, OUT_OF_PLANE, ALL_INDICES}; </literallayout>
	</refsect2>
	<refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine import planarity

planarity.IN_PLANE
planarity.OUT_OF_PLANE
planarity.ALL_INDICES </literallayout>
	</refsect2>
	<refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/planarity.h</filename></simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/planarity.swg</filename></simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2>
  </refsynopsisdiv>
  <refsection>
	<title>Description</title>
	<para>
	  The enumerated <classname>Planarity</classname> type is used
	  when specifying the range of an iterator that is looping
	  over the indices of a <classname><link
	  linkend="Class-Field-iterator">Field</link></classname>,
	  <link
	      linkend="Class-Flux-iterator"><classname>Flux</classname></link>,
	  or <link
	  linkend="Class-Equation-iterator"><classname>Equation</classname></link>.
	  It indicates whether the loop should cover the <link
	  linkend="Section-Concepts-Mesh-3D">in-plane or
	  out-of-plane</link> components, or both.
	</para>
  </refsection>
</refentry> <!-- Planarity -->

  
<!-- Keep this comment at the end of the file
  Local variables:
  sgml-omittag:t
  sgml-shorttag:t 
  sgml-namecase-general:nil
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("../man_oof2.xml" "book" "chapter")
  sgml-exposed-tags:nil
  sgml-local-ecat-files:nil
  End:
-->
