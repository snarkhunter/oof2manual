<!--
  This software was produced by NIST, an agency of the
  U.S. government, and by statute is not subject to copyright in the
  United States.  Recipients of this software assume all
  responsibilities associated with its operation, modification and
  maintenance. However, to facilitate maintenance we ask that before
  distributing modified versions of this software, you first contact
  the authors at oof_manager@nist.gov.
-->

<refentry id="Class-EqnProperty">
  <refnamediv>
    <refname>EqnProperty</refname>
    <refpurpose>A &Property; that contributes to an &Equation;</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <refsect2>
      <title>C++ Synopsis</title>
      <literallayout class="monospaced">
#include "engine/property.h" </literallayout>

      <classsynopsis language="cpp">
        <ooclass>
          <classname>EqnProperty</classname>
        </ooclass>
        <ooclass>
          <modifier>public</modifier>
          <classname><xref linkend="Class-PhysicalProperty"/></classname>
        </ooclass>

        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>void*</type>
          <methodname><link linkend="Class-EqnProperty-begin_point">begin_point</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Equation"/>*</type>
            <parameter>equation</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>       <!-- begin_point -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link linkend="Class-EqnProperty-end_point">end_point</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Equation"/>*</type>
            <parameter>equation</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type>void*</type>
            <parameter>data</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>       <!-- end_point -->
        
        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link
                          linkend="Class-EqnProperty-time_deriv_matrices">time_deriv_matrices</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-ElementFuncNodeIterator"/>&amp;</type>
            <parameter>node</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Equation"/>*</type>
            <parameter>equation</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type>void*</type>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>       <!-- first_time_deriv_matrix -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link
                          linkend="Class-EqnProperty-force_value">force_value</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Equation"/>*</type>
            <parameter>equation</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type>void*</type>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>       <!-- force_value -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link
                          linkend="Class-EqnProperty-force_deriv_mtx">force_deriv_matrix</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Equation"/>*</type>
            <parameter>equation</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-ElementFuncNodeIterator"/>&amp;</type>
            <parameter>node</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type>void*</type>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>       <!-- force_deriv_matrix -->
      </classsynopsis>
    </refsect2>                 <!-- C++ synopis -->
    
    <refsect2 id="Class-PyEqnProperty" xreflabel="PyEqnProperty">
      <title>Python Synopsis</title>
      <para>
        <classname>PyEqnProperty</classname> is a swigged C++ class
        that is derived (in C++) from
        <classname>EqnProperty</classname>.  It is used as a base
        class for <classname>EqnProperties</classname> that are
        defined in Python.  When the methods listed below are called
        from C++, they use the Python C API to invoke methods in the
        Python derived class.
      </para>
      <programlisting>
from ooflib.SWIG.engine import pypropertywrapper </programlisting>
      <classsynopsis language="python">
        <ooclass>
          <classname>PyEqnProperty</classname>
        </ooclass>
        <ooclass>
          <classname>EqnProperty</classname>
        </ooclass>

        <methodsynopsis>
          <methodname><link linkend="Class-EqnProperty-begin_point">begin_point </link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>equation</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
        </methodsynopsis>       <!-- begin_point -->
        
        <methodsynopsis>
          <methodname><link
                          linkend="Class-EqnProperty-end_point">end_point</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>equation</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>data</parameter>
          </methodparam>
        </methodsynopsis>       <!-- end_point -->

        <methodsynopsis>
          <methodname><link
                          linkend="Class-EqnProperty-time_deriv_matrices">time_deriv_matrices</link></methodname>

          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>node</parameter>
          </methodparam>
          <methodparam>
            <parameter>equation</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
        </methodsynopsis>       <!-- time_deriv_matrices -->

        <methodsynopsis>
          <methodname><link linkend="Class-EqnProperty-force_value">force_value</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>equation</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
        </methodsynopsis>       <!-- force_value -->

        <methodsynopsis>
          <methodname><link linkend="Class-EqnProperty-force_deriv_mtx">force_deriv_matrix</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>node</parameter>
          </methodparam>
          <methodparam>
            <parameter>equation</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
        </methodsynopsis>       <!-- force_deriv_matrix -->

      </classsynopsis>
    </refsect2>                 <!-- Python synopsis -->

    <refsect2>
      <title>Source Files</title>
      <itemizedlist spacing="compact">
        <listitem>
          <simpara>
            <filename>SRC/engine/property.C</filename>: C++ code
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/property.h</filename>: C++ header
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/property.swg</filename>: SWIG source
            code
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/property.swg</filename>: Python code
            included in the SWIG output
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/pypropertywrapper.C</filename>: C++
            code for <classname>Properties</classname> implemented in
            Python
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/pypropertywrapper.h</filename>: C++
            header
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/pypropertywrapper.swg</filename>:
            SWIG source code
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/pypropertywrapper.spy</filename>:
            Python code inserted into the SWIG output.
          </simpara>
        </listitem>
      </itemizedlist>
    </refsect2>
  </refsynopsisdiv>

  <refsection>
    <title>Overview</title>
    <para>
        An <classname>EqnProperty</classname> is a &Property; that
        makes a direct contribution to an &Equation; without being
        part of a &Flux;.  For instance <xref
        linkend="Property-Mechanical-MassDensity-ConstantMassDensity"/>
        makes a contribution to the second time derivative in the <xref
        linkend="Equation-Force_Balance"/>
        &Equation; but is not part of the <link
        linkend="Flux-Stress"><constant>Stress</constant></link> &Flux;.
        Similarly, <xref
        linkend="Property-Mechanical-Damping-Isotropic"/> makes a
        contribution to the first time derivative, and <xref
        linkend="Property-Mechanical-ForceDensity-ConstantForceDensity"/>
        contributes to the force term.
    </para>
    <para>
      A new subclass of <classname>EqnProperty</classname> must define
      at least one of following two virtual methods:
      <itemizedlist>
        <listitem>
          <para>
            <link
            linkend="Class-EqnProperty-time_deriv_matrices"><code>EqnProperty::time_deriv_matrices()</code></link>
            computes the <classname>Property</classname>'s
            contribution to the coefficient of the first and/or second time
            derivative in the divergence equation <xref
            linkend="Eqn-TimeDivergence"/>. 
          </para>
        </listitem>
        <listitem>
          <para>
            <link
            linkend="Class-EqnProperty-force_value"><code>EqnProperty::force_value()</code></link>
            computes the <classname>Property</classname>'s direct
            contribution to the force in Eq. <xref
            linkend="Eqn-TimeDivergence"/>.
          </para>
        </listitem>
      </itemizedlist>
      In addition, if <function>force_value()</function> is nonlinear,
      the new subclass must define:
      <itemizedlist>
        <listitem>
          <para>
            <link
                linkend="Class-EqnProperty-force_deriv_mtx"><code>EqnPropertry::force_deriv_matrix()</code></link> 
            computes the derivative of <code>force_value()</code> with
            respect to the &field; components.
          </para>
        </listitem>
      </itemizedlist>

      The functions listed above all have a <xref
      linkend="Class-SmallSystem"/>* argument, which represents a
      small part of the <link
      linkend="Class-LinearizedSystem"><classname>LinearizedSystem</classname></link>
      that is currently being built.
      <classname>SmallSystem</classname> methods handle all of the
      issues related to matrix indexing, element order, and so forth.
      The derived <classname>EqnProperty</classname> methods (and the
      developer) do not need to know anything about what equations are
      being solved or how they are discretized by the finite element
      machinery.  Details on all of the functions are provided below.
    </para>
    <para>
      In addition, two virtual utility functions, <link
      linkend="Class-EqnProperty-begin_point"><classname>begin_point()</classname></link>
      and <link
      linkend="Class-EqnProperty-end_point"><function>end_point()</function></link>,
      can be redefined to facilitate passing data between the other
      routines.
    </para>
  </refsection>                 <!-- Overview -->

  <refsection>
    <title>Constructor</title>
    <para>
      The C++ and Python constructors for
      <classname>EqnProperty</classname> are the same as the <link
      linkend="Class-Property-Constructors">base class
      constructors</link>.
    </para>
  </refsection>

  <refsection>
    <title>Methods</title>

    <refsection id="Class-EqnProperty-begin_point">
      <title><code>void* begin_point(...) const</code></title>
      <programlisting>
void *begin_point(const <xref linkend="Class-FEMesh"/>* mesh,
                  const <xref linkend="Class-Element"/>* element,
                  const <xref linkend="Class-Equation"/>* equation,
                  const <xref linkend="Class-MasterPosition"/>&amp; position,
                  double time) const </programlisting>
      <para>
        When building the finite element matrices and vectors, &oof2;
        loops over the Gauss points within each &Element;.  At each
        Gauss point, for each active &Equation;, it calls
        <classname>EqnProperty</classname> methods for each <xref
        linkend="Class-Property"/> that contributes the &Equation;,
        beginning with <function>begin_point()</function>, followed by
        <link
        linkend="Class-EqnProperty-time_deriv_matrices"><function>time_deriv_matrices()</function></link>,
        <link
        linkend="Class-EqnProperty-force_deriv_mtx"><function>force_deriv_matrix()</function></link>
        (for nonlinear properties), and finally <link
        linkend="Class-EqnProperty-force_value"><function>force_value()</function></link>.
        To avoid recomputing quantities that are required by more than
        one of these methods, computations can be done in
        <function>begin_point()</function> and their results stored in
        a data structure. <function>begin_point()</function> should
        return this structure (as a <code>void*</code> pointer in C++
        or an object in Python). The data structure will be passed
        through to the other <classname>FluxProperty</classname>
        methods.  If the data object was allocated in C++,
        <function>end_point()</function> should delete it.
      </para>
      <para>
        The arguments to <function>begin_point()</function> are:
        <variablelist>
          <varlistentry>
            <term><code>const <link
            linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
            <listitem>
              <para>
                The <classname><xref
                linkend="Class-FEMesh"/></classname> currently being
                solved.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <xref linkend="Class-Element"/>* element</code></term>
            <listitem>
              <para>
                The <link
                linkend="Class-Element"><classname>Element</classname></link>
                containing the current point.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <xref linkend="Class-Equation"/>*</code></term>
            <listitem>
              <para>
                The &Equation; being solved.  If the
                <classname>EqnProperty</classname> contributes to more
                than one &Equation;, <function>begin_point()</function>
                will be called once for each &Equation; and this value
                should be checked to determine which one is current.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <xref
            linkend="Class-MasterPosition">&amp;
            position</xref></code></term>
            <listitem>
              <para>
                The position within the <link
                linkend="Class-Element"><classname>Element</classname></link>
                where the &Property; is being evaluated.  The position
                is given in <link
                linkend="Class-MasterPosition">master
                coordinates</link>, which can be converted to physical
                coordinates by <link
                linkend="Class-Element-from_master"><function>Element::from_master()</function></link>
                if necessary.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>double time</code></term>
            <listitem>
              <para>
                The time at which the &Property; is being evaluated.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
      <para>
        The default implementation of
        <function>begin_point()</function> simply returns
        <constant>nullptr</constant> in C++ and
        <constant>None</constant> in Python.
      </para>
    </refsection>               <!-- begin_point -->

    <refsection id="Class-EqnProperty-end_point">
      <title><code>void end_point(...) const</code></title>
      <programlisting>
void end_point(const <xref linkend="Class-FEMesh"/>* mesh,
               const <xref linkend="Class-Element"/>* element,
               const <xref linkend="Class-Equation"/>* equation,
               const <xref linkend="Class-MasterPosition"/>&amp; position,
               double time,
               void *data) const </programlisting>
	  <para>
	    <function>end_point()</function> is just like <link
	    linkend="Class-EqnProperty-begin_point"><function>begin_point()</function></link>,
	    except that it's called <emphasis>after</emphasis> &oof2; is
	    done computing the contribution at a point.  The
	    <function>end_point()</function> method can be used to clean
	    up any temporary objects allocated by <link
	    linkend="Class-EqnProperty-begin_point"><methodname>begin_point</methodname></link>.
	  </para>
      <para>
        The arguments for <function>end_point()</function> are the same
        as the arguments for <methodname><link
        linkend="Class-EqnProperty-begin_point">begin_point()</link></methodname>,
        with the addition of a <code>void*</code> which points to the
        data returned by <link
	    linkend="Class-EqnProperty-begin_point"><methodname>begin_point()</methodname></link>.
      </para>
      <para>
        The default implementation of <function>end_point()</function>
        does nothing.
      </para>
    </refsection>               <!-- end_point -->
    
    <refsection id="Class-EqnProperty-time_deriv_matrices">
      <title><code>void time_deriv_matrices(...)
      const</code></title>
      <programlisting>
void time_deriv_matrices(const <xref linkend="Class-FEMesh"/>* mesh,
                         const <xref linkend="Class-Element"/>* element,
                         const <xref linkend="Class-ElementFuncNodeIterator"/>&amp; node,
                         const <xref linkend="Class-Equation"/>* equation,
                         const <xref linkend="Class-MasterPosition"/>&amp; position,
                         double time,
                         void *data,
                         <xref linkend="Class-SmallSystem"/>* linsys) const </programlisting>
      <para>
        <classname>EqnProperty</classname> classes that contribute to
        &Cmatrix; or &Mmatrix;, the coefficients of the first and second time derivatives of the
        &fields; in the time-dependent divergence equation <xref
        linkend="Eqn-TimeDivergence"/>, need to define
        <function>time_deriv_matrices()</function>.  It is analogous
        to <link
        linkend="Class-FluxProperty-flux_matrix"><function>FluxProperty::flux_matrix()</function></link>,
        but generally much simpler.
      </para>
      <para>
        <anchor id="first-deriv-dicussion"/>
        As in <link
        linkend="Class-FluxProperty-flux_matrix"><function>FluxProperty::flux_matrix()</function></link>,
        the derivation begins by expanding the &field; components in
        terms of the shape functions:<footnoteref linkend="summation"/>

	    <equation id="Eqn-EqnProperty-expansion">
	      <alt role="tex">
            \[\varphi_k({\bf x}) = N_\nu({\bf x}) \varphi_{k\nu}\]
          </alt>
	    </equation>

	    where
          
	    <inlineequation>
	      <alt role="tex">
            \(N_\nu({\bf x})\)
          </alt>
	    </inlineequation>
          
	    is the shape function that is 1 at node &nu; and 0 at all
	    other nodes, and

	    <equation>
	      <alt role="tex">
            \[\varphi_{k\nu} \equiv \varphi_k({\bf x_\nu})\]
          </alt>
        </equation>

        is the

        <inlineequation>
          <alt role="tex">\(k^\mathrm{th}\)</alt>
        </inlineequation>

        component of the field at node &nu;. &oof2; stores the
        values of &phiknu; for all nodes in a vector, where
        <inlineequation><alt
                            role="tex">\(k\nu\)</alt></inlineequation>
        should be understood as a single index.
      </para>
      <para>
        Because &phiknu; is a vector, Equation <xref
        linkend="Eqn-TimeDivergence"/> is a matrix equation, so the
        first derivative term is

        <equation>
          <alt role="tex">
            \[
            \left[ {\bf C}\frac{\partial\varphi}{\partial t}({\bf x}) \right]_i
            = {\bf C}_{ik}\frac{\partial\varphi_k}{\partial t}({\bf x})
            \]
          </alt>
        </equation>

        where &texi; is an equation index.

        Using Eq. <xref linkend="Eqn-EqnProperty-expansion"/>, this becomes
        
        <equation id="Eqn-EqnProperty-C">
          <alt role="tex">
            \[
            \left[ {\bf C}\frac{\partial\varphi}{\partial t}({\bf x}) \right]_i
            = \left[N_\nu({\bf x}){\bf C}_{ik}\right]
            \frac{\partial\varphi_{k\nu}}{\partial t}
            \]
          </alt>
        </equation>
        The derivation for &Mmatrix; is identical, except that the
        second time derivative is used instead of the first:
        <equation id="Eqn-EqnProperty-M">
          <alt role="tex">
            \[
            \left[ {\bf M}\frac{\partial^2\varphi}{\partial t^2}({\bf x}) \right]_i
            = \left[N_\nu({\bf x}){\bf C}_{ik}\right]
            \frac{\partial^2\varphi_{k\nu}}{\partial t^2}
            \]
          </alt>
        </equation>
        
      </para>
      <para>
        The job of <function>time_deriv_matrices()</function> is to
        compute the terms in square brackets on the right
        hand sides of <xref linkend="Eqn-EqnProperty-C"/> and <xref
        linkend="Eqn-EqnProperty-M"/>.
      </para>

      <para>
        The arguments to <function>time_deriv_matrices()</function>
        are:
        <variablelist>
          <varlistentry>
	        <term><code>const <link linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
	        <listitem>
		      <para>
		        The finite element mesh that's being solved.
		        <function>time_deriv_matrices()</function>
		        probably doesn't have to use the
		        <varname>mesh</varname> object directly, but it does
		        need to pass it through to other functions.
		      </para>
	        </listitem>
          </varlistentry>
	      <varlistentry>
	        <term><code>const <link linkend="Class-Element">Element</link>* element</code></term>
	        <listitem>
		      <para>
		        The finite <link
		        linkend="Class-Element">element</link> under
		        consideration.  This shouldn't be explicitly needed
		        except in cases in which the material parameters
		        depend on physical space coordinates, or if
		        history-dependent fields are stored in the element.
		      </para>
	        </listitem>
	      </varlistentry>

	      <varlistentry>
	        <term><code>const <link
	        linkend="Class-ElementFuncNodeIterator">ElementFuncNodeIterator</link>&amp; node</code></term>
	        <listitem>
		      <para>
		        This is the node &nu; referred to in the discussion
		        <link linkend="first-deriv-dicussion">above</link>.
		        It's passed in in the form of an iterator, which can
		        iterate over all of the nodes of the element, although
		        it should be thought of here simply as a way of
		        accessing the node's indices and shape
		        functions.<footnoteref linkend="node-as-iterator"/>
                The node's shape function
		        and its derivatives can be obtained from <link
		        linkend="Class-ElementShapeFuncIterator-shapefunction"><methodname>ElementFuncNodeIterator::shapefunction()</methodname></link>
		        and <link
		        linkend="Class-ElementShapeFuncIterator-dshapefunction"><methodname>ElementFuncNodeIterator::dshapefunction()</methodname></link>.
		      </para>
	        </listitem>
	      </varlistentry>
          <varlistentry>
            <term><code>&Equation;* equation</code></term>
            <listitem>
              <para>
                The &Equation; being computed.  Properties that
                contribute to more than one &Equation; may need to
                check this variable to know which one they're being
                asked to compute.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
	        <term><code>const <link
	        linkend="Class-MasterPosition">MasterPosition</link>&amp; position</code></term>
	        <listitem>
		      <para>
                This is the position &boldx; in <xref
                linkend="Eqn-EqnProperty-C"/>.
                <varname>position</varname> is a point in
                <varname>element</varname>'s <link
                linkend="Class-Element"><classname>Element</classname></link>'s
                <link linkend="Class-MasterPosition">master coordinate
                space</link>.  It is often a Gauss integration point,
                but not always.  Master coordinates can be converted
                to physical coordinates by calling <link
                linkend="Class-Element-from_master"><function>Element::from_master()</function></link>.
		      </para>
	        </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>double time</code></term>
            <listitem>
              <para>
                The time at which the coefficients are being evaluated.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>void* data</code></term>
            <listitem>
              <para>
                The data object, if any, returned by <link linkend="Class-EqnProperty-begin_point"><function>begin_point()</function></link>.
              </para>
            </listitem>
          </varlistentry>
	      <varlistentry>
	        <term>
              <code><link linkend="Class-SmallSystem">SmallSystem</link>*
	          linsys</code>
            </term>
	        <listitem>
		      <para>
                Storage for the portion of the the actual &Cmatrix;
                and &Mmatrix; that are currently being computed, along
                with other data.  <link
                linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>
                knows how to convert local &Element; and &Node;
                indices into global &FEMesh; indices.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
      <para>
        The default version of
        <function>time_deriv_matrices()</function> does nothing.
      </para>

      <refsection id="example-first-deriv">
        <title>
          Example of <function>time_deriv_matrices()</function> for
          first derivatives
        </title>
        <para>
          For example, here is the
          <function>first_time_deriv_matrix()</function> method
          for the <xref
          linkend="Property-Mechanical-Damping-Isotropic"/> &Property;
          in <filename>SRC/engine/properties/damping/damping.h</filename>.
          The &Property; adds a
          
          <equation id="Eqn-damping-term">
            <alt role="tex">
              \[ d\frac{\partial {\bf u}}{\partial t} \]\
            </alt>
          </equation>

          term to the &texx; and &texy; components of the <xref
          linkend="Field-Displacement"/> &texu; in the <link
          linkend="Equation-Force_Balance">force balance</link>
          equation <xref
          linkend="Eqn-Force_Balance"/>.<footnote><para> The damping
          does not represent physical damping, because it acts on the
          velocity in the lab frame, not the strain rate, but it can
          be useful to provide numerical stability.</para></footnote>
        </para>
        <programlisting id="damping-matrix-example">
void IsotropicDampingProp::time_deriv_matrices(
					   const FEMesh* mesh,
					   const Element* element,
					   const ElementFuncNodeIterator&amp; node, <co id="damping-node"/>
					   const Equation* eqn,
					   const MasterPosition&amp; mpos,
					   double time,
					   void *data, 
					   SmallSystem* linsys)
  const
{
  if(*eqn != force_balance) <co id="damping-precompute"/> <co id="damping-check-eqn"/>
     throw ErrProgrammingError("Unexpected equation.", __FILE__, __LINE__);
  double shapeFuncVal = node.shapefunction(mpos); <co id="damping-shape"/>
  for(IndexP component : *eqn->components()) { <co id="damping-eqncomp"/>
    eqndata->damping_matrix_element(component, displacement, component, node) <co id="damping-mtx-element"/>
      += coeff*shapeFuncVal; <co id="damping-constant"/>
  }
} </programlisting>
          
        <calloutlist>
          <callout arearefs="damping-node">
            <para>
              This is the node &nu; in Eq. <xref
              linkend="Eqn-EqnProperty-C"/>.
            </para>
          </callout>
          <callout arearefs="damping-precompute">
            <para>
              <varname>force_balance</varname> is an <xref
              linkend="Class-Equation"/>* that is set when
              <function>IsotropicDamping::precompute()</function> 
              calls <code>Equation::getEquation()</code>.  It is
              stored in the class instance.  Similiarly,
              <varname>dispacement</varname> is a &Field;* set by
              calling <code>Field::getField()</code>.  They could just
              as well have been set in the
              <classname>IsotropicDampingProp</classname> constructor.
            </para>
          </callout>
          <callout arearefs="damping-check-eqn">
            <para>
              Checking the equation is optional here.  It verifies
              that the equation <varname>eqn</varname> is actually the
              <xref linkend="Equation-Force_Balance"/> equation.  If
              the &Property; contributed to more than one &Equation;,
              a check like this would determine which one to compute.
            </para>
          </callout>
          <callout arearefs="damping-shape">
            <para>
              This is 

              <inlineequation>
                <alt role="tex">\( N_\nu({\bf x}) \)</alt>
              </inlineequation>

              in Eq. <xref linkend="Eqn-damping-term"/>.
            </para>
          </callout>
          <callout arearefs="damping-eqncomp">
            <para>
              See <xref linkend="Section-Coding-Indices"/> for a
              discussion about looping over components of an
              &Equation;. &oof2; divergence equations only have
              in-plane components, and this loops over all of them.
            </para>
          </callout>
          <callout arearefs="damping-mtx-element">
            <para>
              <link
              linkend="Class-SmallSystem-damping_matrix_element"><function>SmallSystem::damping_matrix_element()</function></link>
              returns a reference to the finite element matrix element
              that is being computed.

              The row is determined by the
              &Equation; component, and the
              column by the component of the
              <varname>displacement</varname> field at the &Node;
              <varname>node</varname>.  Since the damping coefficient
              is a scalar, <emphasis>aka</emphasis> a diagonal matrix,
              both indices are <varname>component</varname>. 
            </para>
          </callout>
          <callout arearefs="damping-constant">
            <para>
              This is where Eq. <xref linkend="Eqn-damping-term"/> is
              added to the finite element matrix.  It uses
              <code>+=</code> instead of <code>=</code> just in case
              some other &Property; has already made a contribution to
              that matrix element.
            </para>
            <para>
              <varname>coeff</varname> is the damping coefficient.  It
              is a parameter defined in the &Property;'s <xref
              linkend="Class-PropertyRegistration"/> and stored in the
              &Property; by its constructor.
            </para>
          </callout>
        </calloutlist>
      </refsection>             <!-- example-time_derivmatrices C -->

      <refsection id="example-second-deriv">
        <title>
          Example of <function>time_deriv_matrices()</function> for
          second derivatives
        </title>
        <para>
          Here is the <function>time_deriv_matrices()</function>
          method for the <xref
          linkend="Property-Mechanical-MassDensity-ConstantMassDensity"/>
          &Property; in
          <filename>SRC/engine/properties/massdensity/massdensity.C</filename>,
          which adds a term
          <equation>
            <alt role="tex">
              \[ m\frac{\partial^2 u}{\partial t^2} \]
            </alt>
          </equation>
          to the <link linkend="Equation-Force_Balance">force
          balance</link> equation <xref linkend="Eqn-Force_Balance"/>.
          It is essentially the same as the damping example above, but
          it calls <link
          linkend="Class-SmallSystem-mass_matrix_element"><function>SmallSystem::mass_matrix_element()</function></link>
          instead of <link
          linkend="Class-SmallSystem-damping_matrix_element"><function>SmallSystem::damping_matrix_element()</function></link>.
        </para>
        <programlisting>
void MassDensityProp::time_deriv_matrices(
				       const FEMesh* mesh,
				       const Element* element,
				       const ElementFuncNodeIterator&amp; node,
				       const Equation *eqn,
				       const MasterPosition&amp; mpos,
				       double time,
				       void*,
				       SmallSystem *eqdata) const
{
  double shapeFuncVal = node.shapefunction(mpos);
  for(IndexP eqncomp : *eqn->components()) {
    eqdata-><emphasis role="bold">mass_matrix_element</emphasis>(component, disp, component, node) <co id="mass-mtx-element"/>
      += rho_ * shapeFuncVal;
  }
} </programlisting>
        <calloutlist>
          <callout arearefs="mass-mtx-element">
            <para>
              <link
              linkend="Class-SmallSystem-mass_matrix_element"><function>SmallSystem::mass_matrix_element()</function></link>
              returns a reference to an entry in the finite element
              matrix element that is being computed.  The row is
              determined by the &Equation; component
              <varname>eqncomp</varname>, and the column by the
              <varname>k</varname> component of the
              <varname>displacement</varname> field at the &Node;
              <varname>node</varname>.
            </para>
          </callout>
        </calloutlist>
      </refsection>             <!-- example-second-deriv -->
    </refsection>               <!-- time_deriv_matrices -->

    <refsection id="Class-EqnProperty-force_value">
      <title><code>void force_value(...) const</code></title>
      <programlisting>
void force_value(const <xref linkend="Class-FEMesh"/>* mesh,
                 const <xref linkend="Class-Element"/>* element,
                 const <xref linkend="Class-Equation"/>* equation,
                 const <xref linkend="Class-MasterPosition"/>&amp; position,
                 double time,
                 void* data,
                 <xref linkend="Class-SmallSystem"/>* linsys) const </programlisting>
      <para>
        A &Property; that makes a direct contribution to the
        <varname>force</varname> term in Eq. <xref
        linkend="Eqn-TimeDivergence"/> must redefine
        <function>force_value()</function>, which must use <link
        linkend="Class-SmallSystem-forceVector"><function>SmallSystem::forceVector()</function></link>
        to set the value of the force at the given point in the given
        &Element;.  The arguments to
        <function>force_value()</function> are<footnote><para> Note
        that unlike the other <classname>EqnProperty</classname>
        methods, <function>force_value()</function> does
        <emphasis>not</emphasis> take a <xref
        linkend="Class-ElementFuncNodeIterator"/> argument.  It
        doesn't multiply a field or field derivative that is being
        expanded in shape functions.</para></footnote>:

        <variablelist>
          <varlistentry>
            <term><code>const <link
            linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
            <listitem>
            <para>
              The &FEMesh; that's currently being solved.
            </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <xref linkend="Class-Element"/>* element</code></term>
            <listitem>
              <para>
                The <link
                linkend="Class-Element"><classname>Element</classname></link>
                containing the current point.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <xref linkend="Class-Equation"/>*</code></term>
            <listitem>
              <para>
                The &Equation; being solved.  If the
                <classname>EqnProperty</classname> contributes to more
                than one &Equation;, <function>begin_point()</function>
                will be called once for each &Equation; and this value
                should be checked to determine which one is current.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <xref
            linkend="Class-MasterPosition">&amp;
            position</xref></code></term>
            <listitem>
              <para>
                The position within the <link
                linkend="Class-Element"><classname>Element</classname></link>
                where the &Property; is being evaluated.  The position
                is given in <link
                linkend="Class-MasterPosition">master
                coordinates</link>, which can be converted to physical
                coordinates by <link
                linkend="Class-Element-from_master"><function>Element::from_master()</function></link>
                if necessary.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>double time</code></term>
            <listitem>
              <para>
                The time at which the &Property; is being evaluated.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>void* data</code></term>
            <listitem>
              <para>
                The data object, if any, returned by <link linkend="Class-EqnProperty-begin_point"><function>begin_point()</function></link>.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
        The default version of <function>force_value()</function> does
        nothing.
      </para>
      <refsection id="example-force_value">
        <title>
          Example of <function>force_value()</function>
        </title>
        <para>
          Here is the <function>force_value()</function> method for
          <xref
          linkend="Property-Mechanical-ForceDensity-ConstantForceDensity"/>.
          It contributes a constant force density given by parameters
          <varname>gx</varname> and <varname>gy</varname>, which are
          stored in the &Property; as a <xref
          linkend="Class-DoubleVec"/> <varname>g</varname>.
        </para>
        <programlisting>
void ForceDensity::force_value(
                       const FEMesh *mesh,
                       const Element *element,
                       const Equation *eqn,
                       const MasterPosition &amp;x,
                       double time, void *data,
                       SmallSystem *linsys) const
{
  linsys->forceVector() += g; <co id="force-val-assign"/>
} </programlisting>

        <calloutlist>
          <callout arearefs="force-val-assign">
            <para>
              This line adds all components of <varname>g</varname> to
              the right hand side being constructed by
              <varname>linsys</varname>.  The indexing is handled by
              the <xref linkend="Class-SmallSystem"/> class.
            </para>
          </callout>
        </calloutlist>
      </refsection>
    </refsection>               <!-- force_value -->

    
    <refsection id="Class-EqnProperty-force_deriv_matrix">
      <title><code>void force_deriv_matrix(...) const</code></title>
      <programlisting>
 void force_deriv_matrix(const <xref linkend="Class-FEMesh"/>* mesh,
                         const <xref linkend="Class-Element"/>* element,
                         const <xref linkend="Class-ElementFuncNodeIterator"/>&amp; node,
                         const <xref linkend="Class-Equation"/>* equation,
                         const <xref linkend="Class-MasterPosition"/>&amp; position,
                         double time,
                         void* data, 
                         <xref linkend="Class-SmallSystem"/>* linsys) const </programlisting>

      <para>
        <function>force_deriv_matrix()</function> needs to be defined
        for any <classname>EqnProperty</classname> that defines a
        <emphasis>nonlinear</emphasis> <link
        linkend="Class-EqnProperty-force_value"><function>force_value()</function></link>.<footnote><para>Technically,
        it only needs to be defined if the nonlinear solver needs to
        compute the Jacobian.</para></footnote> It computes the
        derivatives of the force with respect to the &Fields;.  That
        is, it computes a <xref linkend="Class-SmallMatrix"/>

        <equation id="force-deriv-mtx">
          <alt role="tex">
            \[ J_{ij} = \frac{\partial f_i}{\partial \varphi_j} \]
          </alt>
        </equation>

        where <inlineequation><alt
        role="tex">\(f_i\)</alt></inlineequation> is a force component
        and <inlineequation><alt
        role="tex">\(\varphi_j\)</alt></inlineequation> is a &Field;
        component.  The result is stored in the given <xref
        linkend="Class-SmallSystem"/> by calling <link
        linkend="Class-SmallSystem-force_deriv_matrix_element"><function>SmallSystem::force_deriv_matrix_element()</function></link>,
        which handles all of the indexing.
      </para>
      <para>
        The arguments to <function>force_deriv_matrix()</function> are
        the same as the arguments to <link
        linkend="Class-EqnProperty-time_deriv_matrices"><function>time_deriv_matrices()</function></link>.
      </para>
      <para>
        The default version of
        <function>force_deriv_matrix()</function> does nothing.
      </para>
      <refsection>
        <title>
          Example of <function>force_deriv_matrix()</function>
        </title>
        <para>
          Here is a template for a
          <function>force_deriv_matrix()</function> in a &Property;
          that depends nonlinearly on the <xref
          linkend="Field-Displacement"/> &Field;:
          <programlisting>
void NonlinearForceDensity::force_deriv_matrix(const FEMesh *mesh,
					       const Element *element,
					       const ElementFuncNodeIterator &amp;node,
					       const Equation *eqn,
					       const MasterPosition &amp;point,
					       double time, void*,
					       SmallSystem *linsys) const
{
  DoubleVec fieldVal = displacement->values(mesh, element, point); <co id="force-deriv-disp"/>
  Coord coord = element->from_master(point); <co id="force-deriv-coord"/>
  SmallMatrix forceDeriv = nonlin_force_density_deriv(coord, time, fieldVal); <co id="force-deriv-nonlin"/>
  
  for(IndexP eqncomp : *eqn->components()) { <co id="force-deriv-rows"/>
    for (IndexP fieldcomp : *displacement->components(ALL_INDICES)) { <co id="force-deriv-cols"/>

      linsys->force_deriv_matrix_element(eqncomp, displacement, fieldcomp, node)
        += forceDeriv(eqno, fieldno); <co id="force-deriv-smallsys"/>
    }
  }
} </programlisting>

    <calloutlist>
            <callout arearefs="force-deriv-disp">
              <para>
                <varname>displacement</varname> is a <xref
                linkend="Class-TwoVectorField"/> that was set in the
                &Property;'s constructor like this:
                <programlisting>
displacement = dynamic_cast&lt;TwoVectorField*&gt;(Field::getField("Displacement")); </programlisting>
              </para>
            </callout>
            <callout arearefs="force-deriv-coord">
              <para>
                <varname>coord</varname> is the real space position of
                the point at which the derivatives are being
                evaluated. <link
                linkend="Class-Element-from_master"><function>Element::from_master()</function></link>
                converts the given <xref linkend="Class-MasterPostion"/> to
                laboratory coordinates.
              </para>
            </callout>
            <callout arearefs="force-deriv-rows">
              <para>
                This is the loop over the rows of <link
                linkend="force-deriv-mtx"><inlineequation><alt
                role="tex">\(J_{ij}\)</alt></inlineequation></link>.
              </para>
            </callout>
            <callout arearefs="force-deriv-cols">
              <para>
                This is the loop over the columns of  <link
                linkend="force-deriv-mtx"><inlineequation><alt
                role="tex">\(J_{ij}\)</alt></inlineequation></link>.
              </para>
            </callout>
            <callout arearefs="force-deriv-nonlin">
              <para>
                <function>nonlin_force_density_deriv()</function> is
                the function that computes the matrix <link
                linkend="force-deriv-mtx"><inlineequation><alt
                role="tex">\(J_{ij}\)</alt></inlineequation></link>.
              </para>
            </callout>
            <callout arearefs="force-deriv-smallsys">
              <para>
                This adds the components of the
                <varname>forceDeriv</varname> matrix to the
                appropriate entries in the <link
                linkend="Class-SmallSystem">linearized system</link>,
                <varname>linsys</varname>.
              </para>
            </callout>
          </calloutlist>
        </para>
      </refsection>
    </refsection>               <!-- force_deriv_matrix -->
  </refsection>                 <!-- methods -->

</refentry>                   <!-- EqnProperty -->

<!-- Keep this comment at the end of the file
  Local variables:
  sgml-omittag:t
  sgml-shorttag:t 
  sgml-namecase-general:nil
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("man_oof2.xml" "reference")
  sgml-exposed-tags:nil
  sgml-local-ecat-files:nil
  End:
-->
  
