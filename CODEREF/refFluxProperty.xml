<!-- 
  This software was produced by NIST, an agency of the
  U.S. government, and by statute is not subject to copyright in the
  United States.  Recipients of this software assume all
  responsibilities associated with its operation, modification and
  maintenance. However, to facilitate maintenance we ask that before
  distributing modified versions of this software, you first contact
  the authors at oof_manager@nist.gov.
-->

<!--
    TODO: Be consistent about whether args have names in the
    variablelist sections and have links in the the synopsis sections.
-->

<refentry id="Class-FluxProperty">
  <refnamediv>
    <refname>FluxProperty</refname>
    <refpurpose>A &Property; that contributes to a &Flux;</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <refsect2>
	  <title>C++ Synopsis</title>
      <programlisting>
#include "engine/property.h" </programlisting>

      <classsynopsis language="cpp">
        <ooclass>
          <classname>FluxProperty</classname>
        </ooclass>
        <ooclass>
          <modifier>public</modifier>
          <classname><xref linkend="Class-PhysicalProperty"/></classname>
        </ooclass>
  	    <methodsynopsis>
	      <modifier>virtual</modifier>
          <void/>
          <methodname><link
	                      linkend="Class-FluxProperty-begin_point">begin_point</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FEMesh*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><classname><xref linkend="Class-Element"/></classname>*</type>
		    <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>Flux*</type>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>MasterPosition&amp;</type>
		    <parameter>pt</parameter>
	      </methodparam>
	    </methodsynopsis>       <!-- begin_point -->
        
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link linkend="Class-FluxProperty-end_point">end_point</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FEMesh*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><classname><xref linkend="Class-Element"/></classname>*</type>
		    <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>Flux*</type>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>MasterPosition&amp;</type>
		    <parameter>pt</parameter>
	      </methodparam>
        </methodsynopsis>       <!-- end_point -->

	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link linkend="Class-FluxProperty-flux_matrix">flux_matrix</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
	        <type>FEMesh*</type>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
	        <type><classname><xref linkend="Class-Element"/></classname>*</type>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>             
	      <methodparam>
            <modifier>const</modifier>
		    <type>Flux*</type>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>MasterPosition&amp;</type>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>         <!-- flux_matrix -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link
                          linkend="Class-FluxProperty-flux_offset">flux_offset</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
			<type><xref linkend="Class-Flux"/>*</type>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>pt</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>            
        </methodsynopsis>     <!-- flux_offset -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link linkend="Class-FluxProperty-flux_value">flux_value</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
			<type><xref linkend="Class-Flux"/>*</type>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>pt</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>     <!-- flux_value -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link linkend="Class-FluxProperty-static_flux_value">static_flux_value</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
			<type><xref linkend="Class-Flux"/>*</type>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>pt</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>     <!-- static_flux_value -->
      </classsynopsis>
      
      <refsect3>
        <title>Source Files</title>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>
              <filename>SRC/engine/property.C</filename>: C++ code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/property.h</filename>: C++ header
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/property.swg</filename>: SWIG source
              code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/property.swg</filename>: Python code
              included in the SWIG output
            </simpara>
          </listitem>
        </itemizedlist>
      </refsect3>               <!-- Source files -->
    </refsect2>                 <!-- C++ FluxProperty Synopsis-->
    
    <refsect2 id="Class-PyFluxProperty" xreflabel="PyFluxProperty">
      <title>Python Synopsis</title>
      <para>
        <classname>PyFluxProperty</classname> is a swigged C++ class
        that is derived (in C++) from
        <classname>FluxProperty</classname>.  It is used as a base
        class for <classname>FluxProperties</classname> that are
        defined in Python.  When the methods listed below are called
        from C++, they use the Python C API to invoke methods in the
        Python derived class.
      </para>
      <programlisting>
from ooflib.SWIG.engine import pypropertywrapper </programlisting>
      <classsynopsis language="python">
        <ooclass>
          <classname>PyFluxProperty</classname>
        </ooclass>
        <ooclass>
          <classname>FluxProperty</classname>
        </ooclass>
        <methodsynopsis>
          <methodname><link linkend="Class-FluxProperty-begin_point">begin_point</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
        </methodsynopsis>       <!-- begin_point -->
        <methodsynopsis>
          <methodname><link linkend="Class-FluxProperty-end_point">end_point</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
        </methodsynopsis>       <!-- end_point -->

	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-flux_matrix">flux_matrix</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>node</parameter>
	      </methodparam>             
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- flux_matrix -->        

	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-flux_offset">flux_offset</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- flux_offset -->        

	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-flux_value">flux_value</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- flux_value -->        

	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-static_flux_value">static_flux_value</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- static_flux_value -->        

      </classsynopsis>
      <refsect3>
        <title>Source Files</title>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.C</filename>: C++
              code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.h</filename>: C++
              header
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.swg</filename>:
              SWIG source code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.spy</filename>:
              Python code inserted into the SWIG output.
            </simpara>
          </listitem>
        </itemizedlist>
      </refsect3>               <!-- Python source files -->
    </refsect2>                 <!-- Python Synopsis-->
    
  </refsynopsisdiv>

  <refsection>
    <title>Overview</title>
    <para>
      A <classname>FluxProperty</classname> is &Property; that
      contributes to a &flux;.  For example, <link
      linkend="PropertyType-Elasticity"><literal>Elasticity</literal></link>
      contributes to <xref linkend="Flux-Stress"/>, and <link
      linkend="PropertyType-ThermalConductivity"><literal>ThermalConductivity</literal></link>
      contributes to <xref linkend="Flux-Heat_Flux"/>.  The principal
      job of the <classname>FluxProperty</classname> is to compute the
      coefficients of the &fields; and their time derivatives in a
      linear expansion of a &flux;, &sigma;:
      <equation id="Eqn-flux1">
        <alt role="tex">
          \[
          \sigma =
          \sigma^0({\bf x})
          + {\cal A} ({\bf x}) \varphi
          + {\cal K} ({\bf x}) \nabla\varphi
          + {\cal D} ({\bf x}) \frac{\partial\varphi}{\partial t}
          + {\cal C} ({\bf x}) \frac{\partial\nabla\varphi}{\partial t}
          \]
        </alt>
      </equation>
      Here &varphi; is a &Field; or &Fields;.  &sigma0; is an
      field-independent offset, to first order. The coefficients are
      written as functions of position, &boldx;, but &sigma0;, &Acal;
      and &Kcal; may be nonlinear functions of the fields and their
      derivatives as well.  A future version of &oof2; may allow
      nonlinearities in &Ccal; and &Dcal; as well.
    </para>
    <para>
      A new subclass of <classname>FluxProperty</classname> must
      redefine some or all of the following four virtual methods:
      <itemizedlist>
        <listitem>
          <para>
            <link
            linkend="Class-FluxProperty-flux_matrix"><methodname>FluxProperty::flux_matrix()</methodname></link>
            computes the linearization of the &flux; at a given point
            in an &elem;, as a function of the relevant &fields;,
            their their gradients, and possibly their time
            derivatives.  That is, it determines the coefficients
            &Acal;, &Kcal;, &Dcal;, and &Ccal; in Eqn. <xref
            linkend="Eqn-flux1"/>. 
          </para>
        </listitem>
        <listitem>
          <para>
            <link
            linkend="Class-FluxProperty-flux_offset"><methodname>FluxProperty::flux_offset()</methodname></link>
            computes the value of the &flux; at a given point in an
            &elem; when the &fields; and their gradients are zero.
            This is &sigma0; in <xref linkend="Eqn-flux1"/>.
          </para>
        </listitem>
        <listitem>
          <para>
            <link
            linkend="Class-FluxProperty-flux_value"><methodname>FluxProperty::flux_value()</methodname></link>
            computes the actual value of the &flux; at a given point
            in an &elem;.  If the &property; is linear in the
            &fields;, <methodname>flux_value()</methodname> does not
            need to be redefined, since the &flux; value can be
            deduced from <methodname>flux_matrix()</methodname> and
            <methodname>flux_offset()</methodname>.
          </para>
        </listitem>
        <listitem>
          <para>
            <link
            linkend="Class-FluxProperty-static_flux_value"><methodname>static_flux_value()</methodname></link>
            computes the part of the &flux; value that depends only on
            the &fields; and not on their time derivatives, if the
            &flux; depends on the &field; derivatives.
          </para>
        </listitem>
      </itemizedlist>
      The functions listed above all have a <link
      linkend="ClassSmallSystem"><classname>SmallSystem</classname>*</link>
      argument, which represents a small part of the <link
      linkend="Class-LinearizedSystem"><classname>LinearizedSystem</classname></link>
      that is currently being built.
      <classname>SmallSystem</classname> methods handle all of the
      issues related to matrix indexing, element order, and so forth.
      The derived <classname>FluxProperty</classname> methods (and the
      developer) do not need to know anything about what equations are
      being solved or how they are discretized by the finite element
      machinery.  Details on all of the functions are provided below.
    </para>
    <para>
      In addition, two virtual utility functions, <link
      linkend="Class-FluxProperty-begin_point"><methodname>begin_point()</methodname></link>
      and <link
      linkend="Class-FluxProperty-end_point"><methodname>end_point()</methodname></link>
      can be redefined to facilitate the computations in the other
      routines.
    </para>
  </refsection>               <!-- FluxProperty Overview -->
  
  <refsection>
    <title>Constructor</title>
    <para>
      The C++ and Python constructors for
      <classname>FluxProperty</classname> are the same as the <link
      linkend="Class-Property-Constructors">base class
      constructors</link>.
    </para>
  </refsection>

  <refsection>
    <title>Methods</title>

    <refsection id="Class-FluxProperty-begin_point">
	  <title><code>void begin_point(const FEMesh* mesh, const Element*
      element, const Flux* flux, const MasterPosition&amp; pt)</code></title>
	  <para>
        When building the finite element matrices and vectors, &oof2;
        loops over the Gauss points within each &elem;.  At each Gauss
        point it calls all of the <classname>FluxProperty</classname>
        methods that have been redefined in the derived classes,
        starting with <function>begin_point()</function>.  If the
        other methods share some expensive computations, the
        computations can be performed in
        <function>begin_point()</function> and their results cached.
	  </para>
      <para>
        The arguments to <function>begin_point()</function> are
        <variablelist>
          <varlistentry>
            <term><code>const <link
            linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
            <listitem>
              <para>
                The <link
                linkend="Class-FEMesh"><classname>FEMesh</classname></link>
                currently being solved.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <link
            linkend="Class-Element">Element</link>* element</code></term>
            <listitem>
              <para>
                The <link
                linkend="Class-Element"><classname>Element</classname></link>
                containing the current point.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <link linkend="Class-Flux">Flux</link>*
            flux</code></term>
            <listitem>
              <para>
                The &flux; that this &Property; computes.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <link
            linkend="Class-MasterPosition">MasterPosition</link>&amp;
            point</code></term>
            <listitem>
              <para>
                The position within the <link
                linkend="Class-Element"><classname>Element</classname></link>
                where the &Property; is being evaluated.  The position
                is given in <link
                linkend="Class-MasterPosition">master
                coordinates</link>, which can be converted to physical
                coordinates by <link
                linkend="Class-Element-from_master"><function>Element::from_master</function></link>
                if necessary.
              </para>
            </listitem>
          </varlistentry>
          
        </variablelist>
      </para>
      <para>
        The default implementation of
        <function>begin_point()</function> does nothing.
      </para>
    </refsection>               <!-- begin_point -->
  
    <refsection id="Class-FluxProperty-end_point">
	  <title><code>void end_point(const FEMesh*, const Element*, const Flux*, const MasterPosition&amp;)</code></title>
	  <para>
	    <function>end_point</function> is just like <link
	    linkend="Class-Property-begin_point"><function>begin_point</function></link>,
	    except that it's called <emphasis>after</emphasis> &oof2; is
	    done computing the contribution at a point.  The
	    <function>end_point()</function> method can be used to clean
	    up any temporary objects allocated by <methodname><link
	    linkend="Class-Property-begin_point">begin_point</link></methodname>.
	  </para>
      <para>
        The arguments for <function>end_point</function> are the same
        as the arguments for <methodname><link
        linkend="Class-Property-begin_point">begin_point</link></methodname>.
      </para>
      <para>
        The default implementation of <function>end_point()</function>
        does nothing.
      </para>
    </refsection>               <!-- end_point -->
    
    <refsection id="Class-FluxProperty-flux_matrix">
	  <title>
        <code>void flux_matrix(const FEMesh* mesh, const Element*
        element, const ElementFuncNodeIterator&amp; node, ...)</code>
      </title>
	  <para>
	    <classname>FluxProperty</classname> subclasses that represent
	    the &Acal;, &Kcal;, &Dcal; or &Ccal; terms in the constitutive
	    equation <xref linkend="Eqn-flux1"/> must redefine the virtual
	    function <methodname>FluxProperty::flux_matrix()</methodname>.
	    <methodname>flux_matrix()</methodname> computes a matrix that,
	    when multiplied by a vector of degrees of freedom and/or their
	    time derivatives, produces a vector containing the components
	    of a &flux;.  Explaining this properly requires a brief review
	    of the finite element machinery.
	  </para>
	  <para>
        <anchor id="fluxmatrix_discussion"/>
	    Let

        <inlineequation>
	      <alt role="tex">\(\varphi_k({\bf x})\)</alt>
	    </inlineequation>

	    be the

        <inlineequation>
          <alt role="tex">\(k^\mathrm{th}\)</alt>
        </inlineequation>

	    component of a field &varphi; at position &boldx;.  If the
	    field values are known at nodes &nu;, which are at positions

	    <inlineequation>
          <alt role="tex">
            \({\bf x}_\nu\)
          </alt>
	    </inlineequation>,
        
        then the finite element shape functions

	    <inlineequation>
	      <alt role="tex">
            \(N_\nu({\bf x})\)
          </alt>
	    </inlineequation>
          
	    can be used to approximate the field at
	    &boldx;:<footnote><para> We are using the convention that
	    repeated indices, such as &nu; in <xref
	    linkend="Eqn-Property-expansion"/> are implicitly summed:
	    <inlineequation><alt role="tex">\(x_i y_i\equiv \sum_i x_i
	    y_i\)</alt></inlineequation></para></footnote>
        
	    <equation id="Eqn-Property-expansion">
	      <alt role="tex">
            \[\varphi_k({\bf x}) = N_\nu({\bf x}) \varphi_{k\nu}\]
          </alt>
	    </equation>

	    where
          
	    <inlineequation>
	      <alt role="tex">
            \(N_\nu({\bf x})\)
          </alt>
	    </inlineequation>
          
	    is the shape function that is 1 at node &nu; and 0 at all
	    other nodes, and

	    <equation>
	      <alt role="tex">
            \[\varphi_{k\nu}\equiv \varphi_k({\bf x_\nu})\]
          </alt>
        </equation>

        is the

        <inlineequation>
          <alt role="tex">\(k^\mathrm{th}\)</alt>
        </inlineequation>

        component of the field at node &nu;.  Similarly, the gradient
        of the field is

        <equation id="Eqn-Property-expansion-deriv">
          <alt role="tex">
            \[
            \nabla\varphi =
            \frac{\partial\varphi_k({\bf x})}{\partial{\bf x}} =
            \frac{\partial N_\nu({\bf x})}{\partial{\bf x}} \varphi_{k\nu}.
            \]
          </alt>
        </equation>
        
        Because &oof2; does its computations in 2D, gradients include
        only <emphasis>x</emphasis> and <emphasis>y</emphasis>
        derivatives, unless explicitly stated otherwise.
 	  </para>
	  <para>
        Temporarily ignoring the &varphidot; terms, a constitutive
        relation connects a &field; &varphi; and its gradient,
        &gradphi;, to a &flux; &sigma;, through moduli &Acal; and
        &Kcal;, and an offset, &sigma0;:

        <equation id="Eqn-constitutive">
          <alt role="tex">
            \[
            \sigma =
            \sigma^0 +
            \mathcal{A} \cdot \varphi +
            \mathcal{K} \cdot \nabla\varphi.
            \]
          </alt>
        </equation>

        This is the linearization of a more general relation.  &Acal;,
        &Kcal; and &sigma0; may all be functions of &boldx;, &varphi;,
        &gradphi;, or time.  (&sigma0; must not be a linear function
        of &varphi; or &gradphi;, though.)
      </para>
      <para>
        <xref linkend="Eqn-constitutive"/> can be written as a matrix
        equation:
        
	    <equation id="Eqn-Property-flux">
	      <alt role="tex">
	        \[
            \sigma_i =
            \sigma^0_i + 
            \mathcal{A}_{ik} \cdot \varphi_k +
            \mathcal{K}_{ijk} \cdot \nabla_j\varphi_k
            \]
	      </alt>
	    </equation>
        (repeated indices are summed).  The index &texi; is a flux
        component, &texj; is a space component, and &texk; is a field
        component.  Inserting <xref linkend="Eqn-Property-expansion"/>
        and <xref linkend="Eqn-Property-expansion-deriv"/> into <xref
        linkend="Eqn-Property-flux"/>

        <equation id="Eqn-Property-fluxmtx">
          <alt role="tex">
            \begin{align*}
            \sigma_i
            &amp;=
            \mathcal{A}_{ik} N_\nu({\bf x}) \varphi_{k\nu}
            +
            \mathcal{K}_{ijk}
            \frac{\partial N_\nu}{\partial{\bf x}_j} \varphi_{k\nu}
            +
            \sigma^0_i \\
            &amp;=
            \left[
               \mathcal{A}_{ik} N_\nu({\bf x}) +
               \mathcal{K}_{ijk} \frac{\partial N_\nu}{\partial{\bf x}_j}
             \right] \varphi_{k\nu} +
             \sigma^0_i \\
             \end{align*}
          </alt>
        </equation>
        
        shows that the vector of flux values &sigma; at &boldx; is
        related to the vector of field values &varphi; at the nodes by
        a matrix we call the <emphasis>flux matrix</emphasis>:

        <equation id="Eqn-flux-matrix">
          <alt role="tex">
            \[
            {\bf K}_{ik\nu} =
            \mathcal{A}_{ik}({\bf x})N_\nu + 
            \mathcal{K}_{ijk}
            \frac{\partial N_\nu}{\partial{\bf x}_j}
            \]
          </alt>
        </equation>

        and an offset &sigma0;.  The columns of &Kmatrix; correspond
        to field values

        <inlineequation>
	      <alt role="tex">\(\varphi_{k\nu}\)</alt>
        </inlineequation>

        and the rows to flux components
        
        <inlineequation>
          <alt role="tex">
            \(\sigma_i({\bf x})\)
	      </alt>
          </inlineequation>.

          &Kmatrix; is a part of what is generally called the
          <emphasis>stiffness matrix</emphasis>.
      </para>
      <para>
        Computing &Kmatrix; <xref linkend="Eqn-flux-matrix"/> is the
        purpose of the
        <function>FluxProperty::flux_matrix()</function> method.  On
        each call, <function>flux_matrix()</function> must make
        contributions to &Kmatrix; for all of the components of a
        given flux, all of the components of the relevant fields
        &varphi; (and their out-of-plane parts), and one given node
        &nu;.
	  </para>

      <para>
        The <link
        linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>
        object that is passed in to <function>flux_matrix</function>
        is a container for the various matrices that &Properties;
        compute.  <function>flux_matrix</function> contributes to
        &Kmatrix; by calling <link
        linkend="Class-SmallSystem-stiffness_matrix_element"><methodname>SmallSystem::stiffness_matrix_element()</methodname></link>,
        as shown in the example <link
        linkend="example-fluxmatrix">below</link>.
      </para>
      <para>
        Similarly, if the &flux; depends on the time derivative of the
        &field;, &varphidot;, or its gradient, &gradphidot;, through
        moduli &Dcal; and &Ccal; respectively, then
        <function>flux_matrix()</function> must also compute a
        <emphasis>damping matrix</emphasis>:

        <equation id="Eqn-damping-matrix">
          <alt role="tex">
            \[
            {\bf C}_{ik\nu} =
            \mathcal{D}_{ik}({\bf x})N_\nu + 
            \mathcal{C}_{ijk}({\bf x})
            \frac{\partial N_\nu}{\partial{\bf x}_j}
            \]
          </alt>
        </equation>

        It stores its results by calling <link
        linkend="Class-SmallSystem-damping_matrix_element"><methodname>SmallSystem::damping_matrix_element()</methodname></link>.

        &oof2; currently does not allow nonlinearities in the time
        derivative terms, so &Dcal; an &Ccal; cannot depend on the
        &Fields;, but they can be functions of position.
      </para>

	  <para>
	    It is important to note that it is <emphasis>not</emphasis>
	    necessary for the <function>flux_matrix()</function> routine
	    or its author to know anything about the following:
	  </para>
	  <para>
	    The arguments to <function>flux_matrix()</function> are:
	    <variablelist>
	      <varlistentry>
	        <term><code>const <link linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
	        <listitem>
		      <para>
		        The finite element mesh that's being solved.
		        <function>flux_matrix()</function> probably doesn't
		        have to use the <varname>mesh</varname> object
		        directly, but it does need to pass it through to other
		        functions.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code>const <link linkend="Class-Element">Element</link>* element</code></term>
	        <listitem>
		      <para>
		        The finite <link
		        linkend="Class-Element">element</link> under
		        consideration.  This shouldn't be explicitly needed
		        except in cases in which the material parameters
		        depend on physical space coordinates or in which
		        history-dependent fields are stored in the element.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code>const <link
	        linkend="Class-ElementFuncNodeIterator">ElementFuncNodeIterator</link>&amp; node</code></term>
	        <listitem>
		      <para>
		        This is the node &nu; referred to in the discussion
		        <link linkend="fluxmatrix_discussion">above</link>.
		        It's passed in in the form of an iterator, which can
		        iterate over all of the nodes of the element, although
		        it should be thought of here simply as a way of
		        accessing the node's indices and shape
		        functions.<footnote><simpara> It's not possible to use
		        a <link
		        linkend="Class-Node"><classname>Node</classname></link>
		        instead of an <link
		        linkend="Class-ElementFuncNodeIterator"><classname>ElementFuncNodeIterator</classname></link>
		        here.  <classname>Nodes</classname> are unable to
		        evaluate shape functions because they don't know which
		        <link
		        linkend="Class-Element"><classname>Element</classname></link>
		        is being computed.
		        <classname>ElementFuncNodeIterators</classname> know
		        which <classname>Element</classname> they're looping
		        over.</simpara></footnote> The node's shape function
		        and its derivatives can be obtained from <link
		        linkend="Class-ElementShapeFuncIterator-shapefunction"><methodname>ElementFuncNodeIterator::shapefunction</methodname></link>
		        and <link
		        linkend="Class-ElementShapeFuncIterator-dshapefunction"><methodname>ElementFuncNodeIterator::dshapefunction</methodname></link>.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code>const <link linkend="Class-Flux">Flux</link>*
	        flux</code></term>
	        <listitem>
		      <para>
		        The &flux; &sigma;.  Properties that contribute to
		        more than one &flux; need to check this variable to
		        know which flux they're computing now.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code>const <link
	        linkend="Class-MasterCoord">MasterPosition</link>&amp; position</code></term>
	        <listitem>
		      <para>
		        The flux matrix is evaluated at a physical coordinate
		        &boldx; (often a Gauss integration point, but not
		        always).  <varname>position</varname> is the point in
		        the <link
		        linkend="Class-Element"><classname>Element</classname></link>'s
		        master coordinate space<footnote
		        id="footnote-masterspace"> <simpara> Elements are
		        first defined in a master coordinate space, where
		        geometry is easy, and then mapped to their actual
		        positions in physical space.  The master quadrilateral
		        is a square of side 2 centered on the origin.  The
		        master triangle is a right isosceles triangle with
		        vertices (0,0), (1,0), and (0,1).  A master space
		        coordinate can be converted to a physical point by
                calling
		        <link
		        linkend="Class-Element-from_master"><methodname>Element::from_master</methodname></link>.</simpara></footnote>
		        corresponding to &boldx;.
		      </para>
	        </listitem>
	      </varlistentry>
          <varlistentry>
            <term><code>double time</code></term>
            <listitem>
              <para>
                The time at which the flux matrix is being evaluated.
              </para>
            </listitem>
          </varlistentry>
          
	      <varlistentry>
	        <term>
              <code><link linkend="Class-SmallSystem">SmallSystem</link>*
	          fluxdata</code>
            </term>
	        <listitem>
		      <para>
		        The <link
		        linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>
		        class stores the portion of the the actual flux matrix
		        &Kmatrix; and damping matrix &Cmatrix; that are
		        currently being computed, along with other flux
		        data.<footnote><para>This data can't be stored
		        directly in the &Flux; object because one &Flux; is
		        shared among many &FEMesh;es.  The <link
		        linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>
		        object is local to this computation.</para></footnote>
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
      
      <refsection id="example-fluxmatrix">
        <title>Example of <function>flux_matrix()</function></title>
	    <para>
	      For example, for <link
	      linkend="Property-Thermal-Conductivity-Anisotropic-Cubic">thermal
	      conductivity</link> the field &varphi; is the temperature T,
	      and the heat flux is the vector

          <inlineequation>
            <alt role="tex">
              \({\bf J}\)
            </alt>
            </inlineequation>:

            <equation id="Eqn-ThermalFlux">
              <alt role="tex">
                \[
                {\bf J}_i({\bf x}) = -\kappa_{ij} \nabla_jT({\bf x}) -
                \kappa_{iz} T_z
                \]
              </alt>
            </equation>

            The <emphasis>z</emphasis> component in <xref
            linkend="Eqn-ThermalFlux"/> has been separated out
            because, as explained in <xref
            linkend="Section-Concepts-Mesh-3D"/>, the
            <emphasis>z</emphasis> derivatives of &fields; are treated
            differently from the <emphasis>x</emphasis> and
            <emphasis>y</emphasis> derivatives in &oof2;.

            <inlineequation>
              <alt role="tex">
                \(T_z \equiv \partial T/\partial z \)
              </alt>
            </inlineequation>

            is treated as a separate scalar &field;, and is only
            present if Temperature is in-plane.  Because gradients of

            <inlineequation>
              <alt role="tex">
                \(T_z\)
              </alt>
            </inlineequation>

            don't appear in <xref linkend="Eqn-ThermalFlux"/>, it is
            treated as part of the &Acal; term in <xref
            linkend="Eqn-flux-matrix"/>.
        
	        <equation>
	          <alt role="tex">
	            \begin{align*}
                {\bf J}_i
                &amp;= -\kappa_{ij} \frac{\partial}{\partial{\bf x}_j}
                (T_\nu N_\nu({\bf x}))
                -\kappa_{iz}T_{z\nu}N_\nu({\bf x})
                \\
                &amp;= -\left(\kappa_{ij}
                \frac{\partial N_\nu({\bf x})}{\partial {\bf x}_j}\,
                \right) T_\nu
                -\left(\kappa_{iz}N_\nu({\bf x})\right) T_{z\nu}
                \\
                \end{align*} 
	          </alt>
            </equation>

	        from which we get
            
	        <equation id="Eqn-Property-K">
	          <alt role="tex">
                \[
	            {\bf K}_{i\nu} = -\kappa_{ij}
                \frac{\partial N_\nu({\bf x})}{\partial {\bf x}_j}
	            \]
	          </alt>
	        </equation>

            for <inlineequation><alt role="tex">\(T\)</alt></inlineequation>
            and

            <equation id="Eqn-Property-Kp">
              <alt role="tex">
                \[
                {\bf K}_{z\nu} = -\kappa_{iz}N_\nu({\bf x})
                \]
              </alt>
            </equation>

            for <inlineequation><alt role="tex">\(T_z\)</alt></inlineequation>.
            

            Note that there is no <inlineequation><alt
            role="tex">\(k\)</alt></inlineequation> index because
            Temperature is a scalar.
	    </para>
 	    <para>
          Here is the <methodname>fluxmatrix</methodname> routine for
          the <classname>HeatConductivity</classname> class, from
          <filename>SRC/engine/properties/heatconductivity/heatconductivity.C</filename>
          in the &oof2; source code:
	    </para>

        <programlisting>
void HeatConductivity::flux_matrix(const FEMesh  *mesh,
				   const Element *el,
				   const ElementFuncNodeIterator &amp;nu,
				   const Flux *flux,
				   const MasterPosition &amp;pt,
				   double time,
				   SmallSystem *fluxdata) const
{
  if (*flux != *heat_flux) { <co id="flux_matrix-test"/>
    throw ErrProgrammingError("Unexpected flux", __FILE__, __LINE__); <co id="flux_matrix-error"/>
  }

  double sf   = nu.shapefunction( pt ); <co id="flux_matrix-shapefun"/>
  double dsf0 = nu.dshapefunction( 0, pt ); <co id="flux_matrix-dshapefun"/>
  double dsf1 = nu.dshapefunction( 1, pt ); <coref linkend="flux_matrix-dshapefun"/>

  const SymmMatrix3 cond(conductivitytensor(mesh, el, pt)); <co id="flux_matrix-modulus"/>

  for(IndexP i : *flux->components(ALL_INDICES)) { <co id="flux_matrix-loop"/>
     <co id="flux_matrix-fieldcomps"/>
    // in-plane temperature gradient contributions
    fluxdata->stiffness_matrix_element(i, temperature, nu) -= <co id="flux_matrix-temperature"/> <co id="flux_matrix-mat"/>
        cond(i.integer(), 0) * dsf0 +  <co id="flux_matrix-K"/>
        cond(i.integer(), 1) * dsf1;   <coref linkend="flux_matrix-K"/>

    // out-of-plane temperature gradient contribution
    if(!temperature->in_plane(mesh)) <co id="flux_matrix-oopcheck"/>
      <coref linkend="flux_matrix-fieldcomps"/>
      fluxdata->stiffness_matrix_element(i, temperature->out_of_plane(), nu) <co id="flux_matrix-oop"/>
              -= cond(i.integer(), 2) * sf; <co id="flux_matrix-Kp"/>
  }
} 
        </programlisting>
        <calloutlist>
          <callout arearefs="flux_matrix-test">
            <para>
              We don't really need to do this.  It's a sanity check to
              make sure that we got the &flux; we wanted.
              <varname>heat_flux</varname> is a protected data member of
              <classname>HeatConductivity</classname> and was set in
              the constructor by calling <code><link
              linkend="Function-getFlux">Flux::getFlux</link>("Heat_Flux")</code>
              and dynamically casting the result to a
              <classname>VectorFlux*</classname>.  If a Property makes
              contributions to more than one &Flux; then a statement
              like this must used to determine which flux it is being
              asked to compute.
            </para>
          </callout>
          <callout arearefs="flux_matrix-error">
            <para>
              <link
              linkend="Class-ErrProgrammingError"><classname>ErrProgrammingError</classname></link>
              is declared in
              <filename>SRC/common/ooferror.h</filename>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-shapefun">
            <para>
              Here is where the shape functions are evaluated.  This
              is <inlineequation><alt
              role="tex">\(N_\nu\)</alt></inlineequation>.  Values are
              precomputed and cached at the Gauss integration points,
              so the evaluation here is fast.
            </para>
          </callout>
          <callout arearefs="flux_matrix-dshapefun">
            <para>
              These are the derivatives of the shape functions.  The
	          first argument is the component of the
	          gradient. <literal>0</literal> is <emphasis>x</emphasis>
	          and <literal>1</literal> is <emphasis>y</emphasis>.
	          These values are also cached at Gauss points.
            </para>
          </callout>
          <callout arearefs="flux_matrix-modulus">
            <para>
	          <function>conductivity_tensor()</function> is a virtual function
	          defined in the <classname>HeatConductivity</classname>
	          subclasses.  It takes <classname>FEMesh*</classname>,
	          <classname>Element*</classname>, and
	          <classname>MasterPosition&amp;</classname> arguments so
	          that a subclass can define a position-dependent modulus,
	          or something even more bizarre.
            </para>
          </callout>
          <callout arearefs="flux_matrix-loop">
            <para>
              Note that this loop is over all components of the
              &Flux;.  When solving a <link
              linkend="Section-Concepts-Mesh-plane-flux">plane-flux</link>
              problem, the out-of-plane coefficients in &Kmatrix; are
              used to generate the constraint equations. Looping over
              the components of a &Field; or &Flux; is discussed in
              <xref linkend="Section-Coding-Indices"/>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-fieldcomps">
            <para>
              If the field weren't a scalar, there would be a loop
              over its components here.
            </para>
          </callout>
          <callout arearefs="flux_matrix-temperature">
            <para>
              <varname>temperature</varname> is a variable stored in
              the <classname>HeatConductivity</classname> class and
              initialized by calling <code><link
              linkend="Function-getField">Field::getField</link>("Displacement")</code>
              in the <classname>HeatConductivity</classname>
              constructor.
            </para>
          </callout>
          <callout arearefs="flux_matrix-mat">
            <para>
              <link linkend="Class-SmallSystem-stiffness_matrix_element">
	          <methodname>SmallSystem::stiffness_matrix_element()</methodname>
              </link> retrieves a C++ reference to the matrix element
	          that couples flux component <varname>i</varname> to the
	          <varname>temperature</varname> field at node
	          <varname>nu</varname>.
              Note that we use <code>-=</code>
	          instead of <code>=</code> because a previous call to
	          <methodname>fluxmatrix</methodname> may already have
	          addressed this matrix element.
            </para>
          </callout>
          <callout arearefs="flux_matrix-K">
            <para>
              This is <xref linkend="Eqn-Property-K"/>, summing over
              <inlineequation><alt
              role="tex">\(j\)</alt></inlineequation>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-oopcheck">
            <para>
              This checks to see if the temperature field has an
              <link
              linkend="Section-Concepts-Mesh-3D">out-of-plane</link>
              part.  If it does, its contribution to the stress is
              computed.
            </para>
          </callout>
          <callout arearefs="flux_matrix-oop">
            <para>
	          This retrieves a reference to the matrix element
	          coupling the <link
	          linkend="Section-Concepts-Mesh-3D">out-of-plane</link>
	          part of the Temperature &field; to flux component
	          <inlineequation><alt
	          role="tex">\(i\)</alt></inlineequation>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-Kp">
            <para>
              This is <xref linkend="Eqn-Property-Kp"/>.
            </para>
          </callout>
        </calloutlist>
      </refsection>             <!--flux_matrix example-->
    </refsection>               <!-- flux_matrix -->


    <refsection id="Class-FluxProperty-flux_offset">
	    <title><code>void flux_offset(const FEMesh* mesh, const Element* element, const Flux* flux, ...) const</code></title>
	    <para>
          <methodname>FluxProperty::flux_offset()</methodname>
          computes the &sigma0; term in <xref linkend="Eqn-flux1"/>.
          It is the value of the linearized &flux; when the &fields;
          are zero.  It is similar in purpose to <link
          linkend="Class-Property-flux_matrix"><methodname>FluxProperty::flux_matrix()</methodname></link>,
          but generally simpler to implement.
        </para>
        <para>
          Because &sigma0; is not proportional to a &field; or its
          gradient, <function>flux_offset()</function> does not have
          to worry about expansions and shape functions.  It just
          computes the value of &sigma0; and stores it in the given
          <link
          linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>.
        </para>
        <para>
          As an example, consider <link
          linkend="PropertyType-ThermalExpansion">thermal
          expansion</link>.
          The flux (stress) is

          <equation id="Eqn-thermal-stress">
            <alt role="tex">
              \[
              \sigma_{ij} = C_{ijkl}(\epsilon_{kl} - \alpha_{kl}(T-T_0)).
              \]
            </alt>
          </equation>

          <inlineequation>
            <alt role="tex">
              \(\alpha_{kl}\)
            </alt>
          </inlineequation>

          is the thermal expansion coefficient and
            
          <inlineequation>
            <alt role="tex">
              \(T_0\)
            </alt>
          </inlineequation>
          is the temperature at which the thermal stress vanishes.

          The

          <inlineequation>
            <alt role="tex">
              \(C_{ijkl}\alpha_{kl}\,T\)
            </alt>
          </inlineequation>

          term in <xref linkend="Eqn-thermal-stress"/> is handled by
          <methodname>ThermalExpansion::flux_matrix()</methodname>
          because of its field dependence, but

          <inlineequation>
            <alt role="tex">
              \(C_{ijkl}\alpha_{kl}\,T_0\)
            </alt>
          </inlineequation>
          
          makes a field <emphasis>independent</emphasis> contribution
          to the flux, and needs to be handled by
          <function>flux_offset()</function>.
        </para>
        <para>
          The arguments to
          <methodname>FluxProperty::flux_offset()</methodname> are:
          <variablelist>
            <varlistentry>
              <term><code>const <link linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
              <listitem>
                <para>
		          The finite element mesh that's being solved.
		          <function>flux_offset()</function> probably doesn't
		          have to use the <varname>mesh</varname> object
		          directly, but it does have to pass it through to
		          other functions.
                </para>
              </listitem>
            </varlistentry>
	        <varlistentry>
	          <term><code>const <link linkend="Class-Element">Element</link>* element</code></term>
	          <listitem>
		        <para>
		          The finite <link
		          linkend="Class-Element">element</link> under
		          consideration.  This shouldn't be explicitly needed
		          except in cases in which the material parameters
		          depend on physical space coordinates or in which
		          history-dependent fields are stored in the element.
		        </para>
	          </listitem>
	        </varlistentry>
	        <varlistentry>
	          <term><code>const <link linkend="Class-Flux">Flux</link>*
	          flux</code></term>
	          <listitem>
		        <para>
		          The &flux; &sigma;.  Properties that contribute to
		          more than one &flux; need to check this variable to
		          know which flux they're computing now.
		        </para>
	          </listitem>
	        </varlistentry>
	        <varlistentry>
	          <term><code>const <link
	          linkend="Class-MasterCoord">MasterPosition</link>&amp; position</code></term>
	          <listitem>
		        <para>
		          The flux offset is evaluated at a physical
		          coordinate &boldx; (often a Gauss integration point,
		          but not always).  <varname>position</varname> is the
		          point in the <link
		          linkend="Class-Element"><classname>Element</classname></link>'s
		          master coordinate space.<footnoteref
		          linkend="footnote-masterspace"/>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>double time</code></term>
              <listitem>
                <para>
                  The time at which the flux offset is being evaluated.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code><link linkend="Class-SmallSystem">SmallSystem</link>*
                fluxdata</code>
              </term>
              <listitem>
                <para>
                  The <classname>SmallSystem</classname> class stores
                  the portion of the finite element matrices and
                  vectors that are currently being computed.   The
                  results of the <function>flux_offset()</function>
                  calculation are stored here.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>       <!-- flux_offset arguments -->
        </para>
        <para>
          Here is the <function>flux_offset</function> routine for the
          <classname>ThermalExpansion</classname> class, from
          <filename>SRC/engine/properties/thermalexpansion/thermalexpansion.C</filename>:
        </para>
        <programlisting>
void ThermalExpansion::flux_offset(const FEMesh* mesh,
				   const Element* element,
				   const Flux* flux,
				   const MasterPosition&amp; x,
				   double time,
				   SmallSystem* fluxdata) const {

  if(*flux != *stress_flux) { <co id="flux_offset-fluxcheck"/>
    throw ErrProgrammingError("Unexpected flux.", __FILE__, __LINE__);
  }
  const Cijkl modulus = elasticity->cijkl(mesh, element, x); <co id="flux_offset-modulus"/>
  SymmMatrix3 expten = expansiontensor(mesh, element, x); <co id="flux_offset-alpha"/>

  for(IndexP ij : *flux->components(ALL_INDICES)) { <co id="flux_offset-loop"/>
    double &amp;offset_el = fluxdata->offset_vector_element(ij); <co id="flux_offset-reference"/>
    for(SymTensorIndex kl : symTensorIJComponents) { <co id="flux_offset-loop2"/>
      if(kl.diagonal()) {
	offset_el -= modulus(ij,kl)*expten[kl]*T0;
      }
      else {
	offset_el -= 2.0*modulus(ij,kl)*expten[kl]*T0;
      }
    }
  }
}
        </programlisting>
        <calloutlist>
          <callout arearefs="flux_offset-fluxcheck">
            <para>
              This is optional here, to check that we got the &Flux;
              we were expecting.  If a
              <classname>FluxProperty</classname> contributes to more
              than one &Flux;, then a statement like this can be used
              to determine which one is being computed.  The variable
              <varname>stress_flux</varname> was set by the
              <classname>ThermalExpansion</classname> constructor by
              calling <code><link
              linkend="Function-getFlux">Flux::get_Flux</link>("Stress")</code>
              and dynamically casting the result to a <code><link
              linkend="Class-SymmetricTensorFlux">SymmetricTensorFlux</link>*</code>.
            </para>
          </callout>
          <callout arearefs="flux_offset-modulus">
            <para>
              This extracts the elastic modulus from the <link
              linkend="Class-Material"><classname>Material</classname>'s</link>
              <literal>Elasticity</literal>
              <classname>Property</classname>.
              <varname>elasticity</varname> is a variable set in <link
              linkend="Class-Property-cross_reference"><methodname>ThermalExpansion::cross_reference()</methodname></link>
              by calling <code><link
              linkend="Class-Material-fetchProperty">Material::fetchProperty</link>("Elasticity")</code>.
            </para>
          </callout>
          <callout arearefs="flux_offset-alpha">
            <para>
              This is <inlineequation><alt
              role="tex">\(\alpha_{kl}\)</alt></inlineequation> in
              <xref linkend="Eqn-thermal-stress"/>.
              <function>expansiontensor()</function> is a virtual
              function in the <classname>ThermalExpansion</classname>
              class.  The various isotropic and anisotropic subclasses
              define <function>expansiontensor()</function> in
              different ways.
            </para>
          </callout>
          <callout arearefs="flux_offset-loop">
            <para>
              This loop is over all components of the stress, even if
              the problem is being solved in plane stress.  The
              out-of-plane components are used in the constraint
              equations.  Looping over components is discussed in
              <xref linkend="Section-Coding-Indices"/>.
            </para>
          </callout>
          <callout arearefs="flux_offset-reference">
            <para>
              <varname>offset_el</varname> is a reference to the
              <varname>ij</varname> component of &sigma0; in the <link
              linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>
              object.  This value will be incorporated into the global
              vectors constructed by
              <classname>SmallSystem</classname>.
            </para>
          </callout>
          <callout arearefs="flux_offset-loop2">
            <para>
              This loops over all components of the stress.
              The line could have been written
              <programlisting>
for(IndexP kl : *flux->components(ALL_INDICES)) { ... } </programlisting>
              but the generic <link
              linkend="Class-IndexP"><classname>IndexP</classname></link>
              would have to be cast into a <link
              linkend="Class-SymTensorIndex"><classname>SymTensorIndex*</classname></link>
              in order to call <link
              linkend="Class-SymTensorIndex-diagonal"><methodname>SymTensorIndex::diagonal()</methodname></link>
              on the next line.<footnote><para>
              It would look like
              <programlisting>
for(IndexP kl : *flux->components(ALL_INDICES)) {
  const SymTensorIndex* kayell = dynamic_cast&lt;const SymTensorIndex*&gt;(kl.fieldindex());
  if(kayell->diagonal()) {
    offset_el -= modulus(ij,kl)*expten[kl]*T0;
  }
  else {
    offset_el -= 2.0*modulus(ij,kl)*expten[kl]*T0;
  }
} </programlisting></para></footnote>
            Using <link
              linkend="Class-SymTensorIJComponents"><varname>symTensorIJComponents</varname></link>
              (note the lower-case <quote>s</quote>!) avoids this
              complication.
            </para>
          </callout>
        </calloutlist>
      </refsection>             <!-- flux_offset-->

      <refsection id="Class-FluxProperty-flux_value">
        <title>
          <code>void flux_value(const FEMesh* mesh, const Element*
          element, const Flux* flux, ...)</code>
        </title>
        <para>
          <methodname>FluxProperty::flux_value()</methodname> computes
          the value of a given &flux;, as in <xref
          linkend="Eqn-flux1"/>.  
        </para>
        <para>
          Is flux_value() ever used other than in
          Material::find_fluxdata?  No class redefines it.  The base
          class version just calls static_flux_value().
        </para>
      </refsection>
      
      <refsection>
        <title>OLD</title>
      <para>

          OLD
          
	  &oof2; <classname>Properties</classname> that represent
	  external (generalized) forces or otherwise contribute to the
	  right hand side of a <link
	  linkend="Section-Concepts-Mesh-Equation-Divergence">divergence
	  equation</link> must define
	  <methodname>Property::fluxrhs</methodname>.
	  <methodname>fluxrhs</methodname> is similar to <link
	  linkend="Class-Property-fluxmatrix"><methodname>Property::fluxmatrix</methodname></link>
	  in its role and its arguments, but is generally simpler to
	  implement.  Each <methodname>fluxrhs</methodname>
	  implementation must compute a quantity at a given point
	  within an element, but does not have to concern itself with
	  nodes and shapefunctions.
	</para>
	<para>
	  There are two kinds of contributions to the right hand side
	  of the divergence equation.  <emphasis>Body
	  forces</emphasis> contribute directly to the right hand side
	  of the divergence equation <xref linkend="Eqn-Divergence"/>,
	  but <emphasis>offsets</emphasis> contribute a
	  field-independent value to the flux on the left hand side of
	  <xref linkend="Eqn-Divergence"/>.
	  (Field-<emphasis>dependent</emphasis> contributions are made
	  by <link
	  linkend="Class-Property-fluxmatrix"><methodname>Property::fluxmatrix</methodname></link>.)
	</para>
	<para>
	  For an example, consider linear thermal expansion.
	  The flux (stress) is
	  <equation>
	    <alt role="tex">
	      \[
	      \sigma_{ij} = C_{ijkl}
	      \left(\epsilon_{kl} - \alpha_{kl}(T-T_0)\right)
	      \]
	    </alt>
	  </equation>
	  <inlineequation>
	    <alt role="tex">\(T_0\)</alt>
	  </inlineequation>
	  is the temperature at which the stress-free strain vanishes,
	  and makes a field independent <emphasis>offset</emphasis>,
	  <inlineequation>
	    <alt role="tex">\(C_{ijkl}\alpha_{kl}T_0\)</alt>
	  </inlineequation>,
	  to the flux.  On the other hand, gravitational forces do not
	  contribute to the flux, but appear as body forces:
	  <equation>
	    <alt role="tex">
	      \[\nabla\cdot\sigma = -g\hat{\mathrm{\bf y}}\]
	    </alt>
	  </equation>
	</para>
	<para>
	  The arguments to <methodname>Property::fluxrhs</methodname> are:
	  <variablelist>
	    <varlistentry>
	      <term><code>const <link linkend="Class-FEMesh">FEMesh</link> *mesh</code></term>
	      <listitem>
		<para>
		  The finite element mesh that's being solved.
		  <methodname>fluxrhs</methodname> probably doesn't
		  have to use the <varname>mesh</varname> object
		  directly, but it might need to pass it through to
		  other functions.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><code>const <link linkend="Class-Element">Element</link> *element</code></term>
	      <listitem>
		<para>
		  The finite <link
		  linkend="Class-Element">element</link> under
		  consideration.  This shouldn't be explicitly needed
		  except in cases in which the material parameters
		  depend on physical space coordinates or in which
		  history-dependent fields are stored in the element.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><code>const <link linkend="Class-Flux">Flux</link>
		*flux</code></term>
	      <listitem>
		<para>
		  The &flux; under consideration.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><code><link linkend="Class-FluxData">FluxData</link> *fluxdata</code></term>
	      <listitem>
		<para>
		  The <varname>fluxdata</varname> object stores the
		  results computed by
		  <methodname>fluxrhs</methodname>.  It's the same
		  object that was passed to <link
		  linkend="Class-Property-fluxmatrix"><methodname>fluxmatrix</methodname></link>. <link
		  linkend="Class-FluxData-offset_element"><methodname>FluxData::offset_element</methodname></link>
		  accumulates offsets, and <link
		  linkend="Class-FluxData-rhs_element"><methodname>FluxData::rhs_element</methodname></link>
		  accumulates body forces.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><code>const <link
	      linkend="Class-MasterCoord">MasterPosition</link>
	      &amp;x</code></term>
	      <listitem>
		<para>
		  Each call to <methodname>fluxrhs</methodname>
		  evaluates the rhs or flux offset at a given point
		  within the given <link
		  linkend="Class-Element"><classname>Element</classname></link>. <varname>x</varname>
		  is the master space<footnoteref
		  linkend="footnote-masterspace"/> coordinate of the
		  point.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Here is the <methodname>fluxrhs</methodname> function from
	  the <classname>ForceDensity</classname> class, from
	  <filename>SRC/engine/property/forcedensity/forcedensity.C</filename>
	  in the &oof2; source code.  It provides an example of a
	  <emphasis>body force</emphasis>:
	</para>
	<programlisting>
void ForceDensity::fluxrhs(const FEMesh *mesh, const Element *element,
			      const Flux *flux, FluxData *fluxdata,
			      const MasterPosition &amp;x) const 
{
  if(*flux != *stress_flux) { <co id="fluxrhs-test"/>
    throw ErrProgrammingError("Unexpected flux", __FILE__, __LINE__); <co id="fluxrhs-error"/>
  }
  
  fluxdata->rhs_element(0) -= gx; <co id="fluxrhs-rhs_element"/>
  fluxdata->rhs_element(1) -= gy;
} </programlisting>
	<calloutlist>
	  <callout arearefs="fluxrhs-test">
	    <para>
	      As in <link
	      linkend="Class-Property-fluxmatrix"><methodname>fluxmatrix</methodname></link>,
	      above, this is a sanity check.
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-error">
	    <para>
	      <classname>ErrProgrammingError</classname> is declared
	      in <filename>SRC/common/ooferror.h</filename>.
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-rhs_element">
	    <para>
	      <code>FluxData::rhs_element(i)</code> returns a
	      reference to the
	      <varname>i</varname><superscript>th</superscript>
	      component of the divergence of the flux.  Some other
	      <classname>Property</classname> may already have made a
	      contribution to it, so here its value is changed with
	      <code>-=</code> instead of <code>=</code>.  All of the
	      components of the divergence should be addressed.
	      <note>
		<para>
		  As far as <classname>FluxData</classname> is
		  concerned, the divergence of a symmetric 3&times;3
		  tensor flux, such as stress, has only 2 components!
		  This is because the out-of-plane forces are
		  irrelevant.<footnote>
		    <para>
		      If the flux is in-plane, then
		      <inlineequation>
			<alt role="tex">\(\sigma_{iz}=0\)</alt>
		      </inlineequation>
		      and the out-of-plane force must be zero too.  If
		      the flux is not in-plane, then
		      <inlineequation>
			<alt role="tex">\(\sigma_{iz}\)</alt>
		      </inlineequation>
		      will be found during the solution process, and
		      the out-of-plane forces can be computed.  In
		      both cases it's meaningless to specify the
		      forces ahead of time.
		    </para>
		  </footnote>
		  The function <link
		  linkend="Class-Flux-divergence_dim">Flux::divergence_dim</link>
		  can be used to find the number of components of the
		  divergence of a flux.
		</para>
	      </note>
	    </para>
	  </callout>
	</calloutlist>
	<para>
	  Here is the <methodname>fluxrhs</methodname> method from the
	  <classname>ThermalExpansion</classname> property, which is
	  an example of a flux <emphasis>offset</emphasis>.  It
	  computes the field-independent term
	  <inlineequation id="Eqn-thermalexpfluxrhs">
	    <alt role="tex">\(C_{ijkl}\alpha_{kl}T_0\)</alt>
	  </inlineequation>
	  The original version can be found in
	  <filename>SRC/engine/property/thermalexpansion/thermalexpansion.C</filename>
	  in the &oof2; source code.
	</para>
	<programlisting>
void ThermalExpansion::fluxrhs(const FEMesh *mesh, const Element *element,
				   const Flux *flux, FluxData *fluxdata,
				   const MasterPosition &amp;x) const {
  
  if(*flux!=*stress_flux) {
    throw ErrProgrammingError("Unexpected flux." __FILE__, __LINE__);
  }
  const Cijkl modulus = elasticity->cijkl(mesh, element, x); <co id="fluxrhs-mod"/>

  for(SymTensorIterator ij; !ij.end(); ++ij) { <co id="fluxrhs-ij"/>
    double &amp;offset_el = fluxdata->offset_element(mesh, ij); <co id="fluxrhs-offset"/>
    for(SymTensorIterator kl; !kl.end(); ++kl) { <co id="fluxrhs-kl"/>
      if(kl.diagonal()) { <co id="fluxrhs-sum"/>
	offset_el += modulus(ij,kl)*expansiontensor[kl]*tzero_;
      }
      else {
	offset_el += 2.0*modulus(ij,kl)*expansiontensor[kl]*tzero_;
      }
    }
  }
} </programlisting>
	<calloutlist>
	  <callout arearefs="fluxrhs-mod">
	    <para>
	      This retrieves the elastic modulus
	      <inlineequation>
		<alt role="tex">\(C_{ijkl}\)</alt>
	      </inlineequation>
	      from the <classname>Material</classname>'s
	      <classname>Elasticity</classname> property.  The
	      variable <varname>elasticity</varname> was set by
	      this <classname>Property</classname>'s
	      <methodname>cross_reference</methodname> function, like
	      this:
	      <programlisting>
void ThermalExpansion::cross_reference(Material *mat) {
  elasticity = dynamic_cast&lt;Elasticity*>(mat->fetchProperty("Elasticity"));
} </programlisting>
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-ij">
	    <para>
	      This is the loop over components of the flux, just like
	      item <xref linkend="fluxmatrix:stressloop"/> in the
	      <methodname>fluxmatrix</methodname> example.
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-offset">
	    <para>
	      <code>FluxData::offset_element(i)</code> returns a
	      reference to a component of the flux offset.  The
	      variable <varname>i</varname> must be the appropriate
	      kind of <link
	      linkend="Class-FieldIndex"><classname>FieldIndex</classname></link>
	      or <link
	      linkend="Class-FieldIterator"><classname>FieldIterator</classname></link>
	      object.
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-kl">
	    <para>
	      This is the loop over the indices
	      <inlineequation>
		<alt role="tex">\(kl\)</alt>
	      </inlineequation>
	      in Eq. <xref linkend="Eqn-thermalexpfluxrhs"/>. 
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-sum">
	    <para>
	      The next few lines compute terms in the sum,
	      accumulating them in the <classname>FluxData</classname>
	      object.  <methodname>expansiontensor</methodname> is a
	      <link
		linkend="Class-SymmMatrix3"><classname>SymmMatrix3</classname></link>
	      object stored in the
	      <classname>ThermalExpansion</classname>
	      object, containing the matrix
	      <inlineequation>
		<alt role="tex">\(\alpha_{kl}\)</alt>
	      </inlineequation>.
	      The loop <xref linkend="fluxrhs-kl"/> addresses
	      only the independent symmetric tensor entries
	      <inlineequation>
		<alt role="tex">\(kl\)</alt>
	      </inlineequation>, but the sum in <xref
		linkend="Eqn-thermalexpfluxrhs"/> includes the other
	      half of the tensor as well.  Therefore, we need to
	      include a factor of 2 for the off-diagonal
	      terms. <varname>tzero_</varname> is <inlineequation>
		<alt role="tex">\(T_0\)</alt>
	      </inlineequation>, which is set when the
	      <classname>ThermalExpansion</classname> object is constructed.
	    </para>
	  </callout>
	</calloutlist>
  </refsection>                 <!-- fluxrhs OLD -->
  
  </refsection>               <!-- FluxProperty Methods-->
  
</refentry>                    <!-- FluxProperty -->



  <!-- Keep this comment at the end of the file
  Local variables:
  sgml-omittag:t
  sgml-shorttag:t 
  sgml-namecase-general:nil
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("man_oof2.xml" "book" "part" "reference")
  sgml-exposed-tags:nil
  sgml-local-ecat-files:nil
  End:
-->
