<!-- 
  This software was produced by NIST, an agency of the
  U.S. government, and by statute is not subject to copyright in the
  United States.  Recipients of this software assume all
  responsibilities associated with its operation, modification and
  maintenance. However, to facilitate maintenance we ask that before
  distributing modified versions of this software, you first contact
  the authors at oof_manager@nist.gov.
-->

<refentry id="Class-Field">
  <refnamediv>
    <refname>Field</refname>
    <refpurpose>Base class for fields</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <para>
	  Only those methods useful when extending &oof2; are listed here.
    </para>
    <refsect2>
	  <title>C++ Synopsis</title>

	  <literallayout class="monospaced">
#include "engine/field.h"	  </literallayout>

      <classsynopsis language="cpp">
	    <ooclass>
	      <classname>Field</classname>
	    </ooclass>
	    <methodsynopsis>
          <modifier>const</modifier>
	      <type>std::string&amp;</type>
	      <methodname><link linkend="Class-Field-name">name</link></methodname>
	      <void/>
	      <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
	      <type>int</type>
	      <methodname><link
		                  linkend="Class-Field-ndof">ndof</link></methodname>
	      <void/>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <type>bool</type>
	      <methodname><link
		                  linkend="Class-Field-is_defined">is_defined</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>CSubProblem*</type>
		    <parameter>subproblem</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <type>bool</type>
	      <methodname><link
		                  linkend="Class-Field-is_active">is_active</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>CSubProblem*</type>
		    <parameter>subproblem</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-Field-dofoperator">operator()</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FuncNode*</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <type>int</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
          <modifier>virtual</modifier>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-Field-dofoperator">operator()</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <type>int</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-Field-dofoperator">operator()</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FuncNode&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <type>int</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-Field-dofoperator">operator()</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>IndexP&amp;</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>

	    <methodsynopsis>
	      <type>double</type>
	      <methodname><link
                          linkend="Class-Field-value">value</link></methodname>
          <methodparam>
            <type>const FEMesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FuncNode*</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <type>int</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <type>double</type>
	      <methodname><link
                          linkend="Class-Field-value">value</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>FEmesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
	      <methodparam>
		    <type>const ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <type>int</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>ArithmeticOutputValue</type>
	      <methodname><link
		                  linkend="Class-Field-output">output</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>FEMesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>ArithmeticOutputValue</type>
	      <methodname><link
		                  linkend="Class-Field-output">output</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>FEMesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>FuncNode&amp;</type>
            <parameter>node</parameter>
          </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>

        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>ComponentsP</type>
          <methodname><link
                          linkend="Class-Field-components">components</link></methodname>
          <methodparam>
            <type>Planarity</type>
            <parameter>planarity</parameter>
            <initializer>ALL_INDICES</initializer>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>

        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>ComponentsP</type>
          <methodname><link
                          linkend="Class-Field-oop-components">outOfPlaneComponents</link></methodname>
          <void/>
          <modifier>const</modifier>
        </methodsynopsis>
        
	  </classsynopsis>
    </refsect2><!-- Field C++ Synopsis -->
    
    <refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine.field import Field </literallayout>
      <classsynopsis language="python">
	    <ooclass>
	      <classname>Field</classname>
	    </ooclass>

	    <methodsynopsis>
	      <methodname><link
		                  linkend="Class-Field-ndof">ndof</link></methodname>
	      <void/>
	    </methodsynopsis>

	    <methodsynopsis>
	      <methodname><link
		                  linkend="Class-Field-is_defined">is_defined</link></methodname>
	      <methodparam>
		    <parameter>mesh</parameter>
	      </methodparam>
	    </methodsynopsis>

	    <methodsynopsis>
	      <methodname><link
		                  linkend="Class-Field-is_active">is_active</link></methodname>
	      <methodparam>
		    <parameter>mesh</parameter>
	      </methodparam>
	    </methodsynopsis>

	    <methodsynopsis>
	      <methodname><link
                          linkend="Class-Field-value">value</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
	      <methodparam>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>component</parameter>
	      </methodparam>
	    </methodsynopsis>

        <methodsynopsis>
          <methodname><link
                          linkend="Class-Field-components">components</link></methodname>
          <methodparam>
            <parameter>planarity</parameter>
            <initializer>ALL_INDICES</initializer>
          </methodparam>
        </methodsynopsis>

        <methodsynopsis>
          <methodname><link
                          linkend="Class-Field-oop-components">outOfPlaneComponents</link></methodname>
          <void/>
        </methodsynopsis>
        
	  </classsynopsis>
    </refsect2><!-- Field Python Synopsis -->

    <refsect2>
	  <title>Subclasses</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><link linkend="Class-CompoundField"><classname>CompoundField</classname></link></simpara>
	    </listitem>
	    <listitem>
	      <simpara><link linkend="Class-ScalarField"><classname>ScalarField</classname></link></simpara>
	    </listitem>
	    <listitem>
	      <simpara><link linkend="Class-TwoVectorField"><classname>TwoVectorField</classname></link></simpara>
	    </listitem>
	  </itemizedlist>
    </refsect2><!-- Field subclasses -->
    
    <refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/field.h</filename>: C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/field.C</filename>: C++ code</simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.swg</filename>: SWIG source code
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.spy</filename>: python code
	        included in <filename>field.swg</filename>.
	      </simpara>
	    </listitem>
	  </itemizedlist>
    </refsect2><!-- Field Source files -->
    
  </refsynopsisdiv>
  <refsection>
    <title>Description</title>
    <para>
	  <classname>Field</classname> is an abstract base class for all
	  types of fields in &oof2;.  The role of fields is described in
	  <xref linkend="Section-Concepts-Mesh-Field"/>.  Like <link
	  linkend="Class-Flux"><classname>Fluxes</classname></link> and
	  <link
	  linkend="Class-Equation"><classname>Equations</classname></link>,
	  &Field; instances are global objects &mdash; there is one
	  instance for each physical field and it is shared by all
	  &meshes; that use it.  &Fields; store information about
	  the physical field (such as its name and dimension), but do not
	  store the actual values of the &Field;. That's done by a
	  &mesh;, by using bookkeeping data from a &Field;.
    </para>
    <para>
	  Most of the programming interface for &Fields; is defined
	  in the base class, which is an abstract C++ class.  Most of the
	  API is available from both C++ and Python.
    </para>
    <para>
	  Most of the &Field; objects encountered by &oof2; users and
	  extenders are actually instances of the <link
	  linkend="Class-CompoundField"><classname>CompoundField</classname></link>
	  class, which groups the in-plane and out-of-plane parts of a
	  &Field;, along with their time derivatives, all of which
	  are &Fields; themselves.
    </para>
    <para>
      <classname>Field</classname> objects should only be created by
      calling the Python constructors of the <xref
      linkend="Class-CompoundField"/> subclasses.  See <xref
      linkend="Class-CompoundField"/> for the details.  After a
      <classname>Field</classname> has been created, it can be
      retrieved in C++ or Python via the <link
      linkend="Function-getField"><function>getField</function></link>
      function.  It is not necessary to keep an explicit Python
      reference to a newly created <classname>Field</classname>.
      For convenience in <link
      linkend="MenuItem-OOF.File.Load.Script">scripts</link>, a
      variable with the <classname>Field</classname>'s name referring
      to the <classname>Field</classname> is defined in the main
      &oof2; namespace, which is aslo used in <link
      linkend="Section-ScriptGUI">text mode</link> and the <link
      linkend="Section-Windows-Console">Console Window</link>.
    </para>
  </refsection>
  
  <refsection>
    <title>Methods</title>

    <refsection id="Class-Field-name">
      <title>name</title>
      <programlisting>
std::string&amp; name() const </programlisting>
	  <para>
	    <methodname>name</methodname> returns the name assigned to
	    the <classname>Field</classname> when it was created.
	  </para>
    </refsection><!-- name -->
    
    <refsection id="Class-Field-ndof">
	  <title>ndof</title>
      <programlisting>
int ndof() const </programlisting>
      <para>
	    <methodname>ndof</methodname> returns the number of degrees
	    of freedom in the <classname>Field</classname>.  This is the
	    number of data values that must be allocated to store the
	    <classname>Field</classname> at each &node; of the &mesh;.
	    For <link
	    linkend="Class-CompoundField"><classname>CompoundFields</classname></link>,
	    <methodname>ndof</methodname> returns the size of the
	    <emphasis>in-plane</emphasis> part.
	  </para>
    </refsection><!-- ndof -->
    
    <refsection id="Class-Field-is_defined">
	  <title>is_defined</title>
      <programlisting>
bool is_defined(const CSubProblem* subp) const </programlisting>
	  <para>
	    <methodname>is_defined</methodname> indicates whether the
	    <classname>Field</classname> has been <link
	    linkend="MenuItem-OOF.Mesh.Field.Define">defined</link> on the
	    given <link
	    linkend="Class-CSubProblem"><classname>CSubProblem</classname></link>.
	    Defined <classname>Fields</classname> have been assigned
	    values on &nodes;.
	  </para>
    </refsection><!-- is_defined -->
    
    <refsection id="Class-Field-is_active">
	  <title>is_active</title>
      <programlisting>
bool is_active(const CSubProblem *subp) const </programlisting>
	  <para>
	    <methodname>is_active</methodname> indicates whether the
	    <classname>Field</classname> has been <link
	    linkend="MenuItem-OOF.Mesh.Field.Activate">activated</link> on
	    the given <link
	    linkend="Class-CSubProblem"><classname>CSubProblem</classname></link>.
	    Active <classname>Fields</classname> are being solved for.
	  </para>
    </refsection><!-- is_active -->
    
    <refsection id="Class-Field-dofoperator">
	  <title>operator()</title>
	  <programlisting>
DegreeOfFreedom* operator()(const &FuncNode;*, int component) const;
DegreeOfFreedom* operator()(const &FuncNode;&amp;, int component) const;
DegreeOfFreedom* operator()(const &ElementFuncNodeIterator;&amp;, int component) const;
DegreeOfFreedom* operator()(const &ElementFuncNodeIterator;&amp;, const IndexP&amp;) const; </programlisting>
	  <para>
	    This family of methods are all ways of obtaining the value of
	    a <classname>Field</classname> at a given &FuncNode;.
	    (&FuncNode; is the subclass of &Node; for Nodes that
	    store <classname>Field</classname> data.)  The different
	    methods are provided for convenience, to allow different
	    representations of <classname>Nodes</classname> or
	    <classname>Field</classname> components.  All of these methods
	    return a pointer to a <link
	    linkend="Class-DegreeOfFreedom"><classname>DegreeOfFreedom</classname></link>
	    object, which wraps the actual <classname>Field</classname>
	    component value and is stored at the
	    <classname>Node</classname>.
	  </para>
	  <para>
	    <classname>DegreeOfFreedom</classname>s are low-level,
	    fairly primitive objects, so these methods cannot be used to
	    extract aggregate values (such as all of the components of a
	    multicomponent <classname>Field</classname>).  To do that,
	    see <link
	    linkend="Class-Field-output"><methodname>Field::output</methodname></link>.
	  </para>
	  <para>
	    These functions only return <classname>Field</classname>
	    values at <classname>Nodes</classname>. To get
	    <classname>Field</classname> values interpolated at an
	    arbitrary point within an <link
	    linkend="Class-Element"><classname>Element</classname></link>,
	    see <link
	    linkend="Class-Element-outputField"><methodname>Element::outputField</methodname></link>.
	  </para>
    </refsection><!-- operator() -->
    
    <refsection id="Class-Field-value">
	  <title>value</title>
      <programlisting>
double value(const &FEMesh;*, const &FuncNode;*, int component) const;
double value(const &FEMesh;*, const &ElementFuncNodeIterator;&amp;, int component) const; </programlisting>
	  <para>
	    The <methodname>value</methodname> function is a shortcut for
	    evaluating a component of a <classname>Field</classname> at a
        <classname>Node</classname>.  In C++, the given
	    <varname>node</varname> must be a &FuncNode; pointer or a
	    <link
	    linkend="Class-ElementFuncNodeIterator"><classname>ElementFuncNodeIterator</classname></link>
	    reference.  In Python, it must be a <link
	    linkend="Class-Node"><classname>FuncNode</classname></link>
	    object.
	  </para>
    </refsection>
    <refsection id="Class-Field-output">
	  <title>output</title>
	  <programlisting>
&ArithmeticOutputValue; output(const &FEMesh;*, const &ElementFuncNodeIterator;&amp;) const;
&ArithmeticOutputValue; output(const &FEMesh;*, const &FuncNode;&amp;) const; </programlisting>
	  <para>
	    These functions return an &OutputValue;
	    object which wraps an &OutputVal;
	    object which contains the value of the
	    <classname>Field</classname> at the given &Node;.
	    These calls are mostly used as a mechanism for generically
	    transferring <classname>Field</classname> values to Python
	    when plotting data, but they can also be useful when writing
	    <classname>Field</classname>-dependent <link
	    linkend="Class-Property"><classname>Property</classname></link>s.
	  </para>
	  <para>
	    The <methodname>output</methodname> functions differ from
	    <link
	    linkend="Class-Field-dofoperator"><methodname>Field::operator()</methodname></link>
	    and <link
	    linkend="Class-Field-value"><methodname>Field::value()</methodname></link>
	    by returning all of the components of a multi-dimensional
	    <classname>Field</classname> in one call.
	  </para>
    </refsection><!-- output -->

    <refsection id="Class-Field-components">
      <title>components</title>
      <programlisting>
&ComponentsP; components(&Planarity; planarity) const; </programlisting>
      <para>
        <methodname>components</methodname> returns a container-like
        object that can be iterated over to obtain the indices of a
        <classname>Field</classname>.  The optional
        <varname>planarity</varname> argument determines which
        <classname>Field</classname> components are included.  If it
        is omitted, <code><link
        linkend="Class-Planarity">ALL_INDICES</link></code> is
        assumed.
      </para>
      <para>
        For example,
        in C++ you can write
        <programlisting>
Field *displacement = Field::getField("Displacement");
for(&IndexP; i : displacement->components()) {   # ALL_INDICES is implicit
    // do something with &IndexP; i
} </programlisting>
        or
        <programlisting>
ComponentsP comps = Field::getField("Displacement")->components(ALL_INDICES);
for(&IndexP; i=comps.begin(); i!=comps.end(); i++) {
   // do something with &IndexP; i
} </programlisting>
        to loop over all components of the displacement field.  The
        equivalent in Python is
        <programlisting>
for index in displacement.components():
    # do something with &FieldIndex; index </programlisting>          

        Note that the index object returned in C++ is an &IndexP;,
        which is a wrapper around a &FieldIndex; pointer.  In Python
        the wrapping is unnecessary and the index object is a
        &FieldIndex;.
      </para>
      <para>
        See <xref linkend="Section-Coding-Indices"/> for an overview,
        and <xref linkend="Class-ComponentsP"/> for the details.
      </para>
    </refsection>               <!--Class-Field-components-->

    <refsection id="Class-Field-oop-components">
      <title>outOfPlaneComponents</title>
      <programlisting>
ComponentsP outOfPlaneComponents() const;</programlisting>
      
      <para>
        Like <link
        linkend="Class-Field-components"><methodname>components</methodname></link>,
        <methodname>outOfPlaneComponents</methodname> returns a
        container that can be iterated over. However, iterating only
        returns the out-of-plane components of the
        <classname>Field</classname>.
      </para>
      <caution id="Field-confusion">
        <title>A Possible Source of Confusion</title>
        <para>
          <code>Field::<emphasis
          role="bold">components(OUT_OF_PLANE)</emphasis></code> and
          <code>Field::<emphasis
          role="bold">outOfPlaneComponents()</emphasis></code> are
          similar but not identical.  They both refer to the same
          components of a <classname>Field</classname> and iterate
          over them in the same order.  But the first is used to
          locate the out-of-plane components in a list that contains
          all of the components, while the second is used to iterate
          over a list that contains only the out-of-plane components.
          The difference is illustrated by using the <link
          linkend="FieldIndex-integer"><function>FieldIndex::integer</function></link>
          method to examine the list indices of the components.
        </para>
        <para>
          For example, the out-of-plane part of the
          <varname>Displacement</varname> field is a 3-vector, with
          indices 0, 1, and 2 obtained from its
          <function>components()</function> method:
          <programlisting>
>>> list(Displacement.out_of_plane().<emphasis role="bold">components()</emphasis>)
[VectorFieldIndex(0), VectorFieldIndex(1), VectorFieldIndex(2)]
>>> list(i.integer() for i in Displacement.out_of_plane().<emphasis role="bold">components()</emphasis>)
[0, 1, 2] </programlisting>

          On the other hand,
          <function>outOfPlaneComponents()</function> returns only the
          z component, but gives it integer index 0, because it's the
          first and only out-of-plane component:
          
          <programlisting>
>>> list(Displacement.out_of_plane().<emphasis role="bold">outOfPlaneComponents()</emphasis>)
[OutOfPlaneVectorFieldIndex(2)]
>>> list(i.integer() for i in Displacement.<emphasis role="bold">out_of_plane().outOfPlaneComponents()</emphasis>)
[0]       </programlisting>
        </para>
        <para>
          A similar issue arises with <link
          linkend="Flux-confusion"><classname>Fluxes</classname></link>.
        </para>
      </caution>
    </refsection>               <!--Class-Field-oop-components-->

  </refsection>                 <!-- Field Methods -->
</refentry>                     <!-- Class:Field -->

<!-- ============================================================== -->

<refentry id="Class-CompoundField">
  <refnamediv>
    <refname>CompoundField</refname>
    <refpurpose>
	  A <classname>Field</classname> with both in- and
	  out-of-plane parts.
    </refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <para>
	  Only those methods useful for extending &oof2; are listed
	  here.  Base class functions are described in the &Field;
	  documentation.
    </para>
    <refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
#include "engine/field.h" </literallayout>
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname>CompoundField</classname>
	    </ooclass>
	    <ooclass>
	      <modifier>public</modifier>
          <modifier>virtual</modifier>
	      <classname><link linkend="Class-Field">Field</link></classname>
	    </ooclass>
        <methodsynopsis>
          <type>Field*</type>
          <methodname><link
                          linkend="Class-CompoundField-td">time_derivative</link></methodname>
          <void/>
          <modifier>const</modifier>
        </methodsynopsis>
	    <methodsynopsis>
	      <type>Field*</type>
	      <methodname><link
	                      linkend="Class-CompoundField-oop">out_of_plane</link></methodname>
	      <void/>
	      <modifier>const</modifier>
	    </methodsynopsis>
        <methodsynopsis>
          <type>Field*</type>
          <methodname><link linkend="Class-CompoundField-ooptd">out_of_plane_time_derivative</link></methodname>
          <void/>
          <modifier>const</modifier>
        </methodsynopsis>
	    <methodsynopsis>
	      <type>bool</type>
	      <methodname><link
	                      linkend="Class-CompoundField-in_plane">in_plane</link></methodname>
	      <methodparam>
		    <type>const FEMesh*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
	      <type>bool</type>
	      <methodname><link
		                  linkend="Class-CompoundField-in_plane">in_plane</link></methodname>
	      <methodparam>
		    <type>const CSubProblem*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
	  </classsynopsis>
    </refsect2><!-- C++ Synopsis -->
    <refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine.field import CompoundField
	    <classsynopsis language="python">
	      <ooclass>
	        <classname>CompoundField</classname>
	      </ooclass>
	      <ooclass>
	        <classname><link linkend="Class-Field">Field</link></classname>
	      </ooclass>
          <methodsynopsis>
            <methodname><link
                            linkend="Class-CompoundField-td">time_derivative</link></methodname>
            <void/>
          </methodsynopsis>
	      <methodsynopsis>
	        <methodname><link
		                    linkend="Class-CompoundField-oop">out_of_plane</link></methodname>
	        <void/>
	      </methodsynopsis>
	      <methodsynopsis>
	        <methodname><link
		                    linkend="Class-CompoundField-ooptd">out_of_plane_time_derivative</link></methodname>
	        <void/>
	      </methodsynopsis>

	      <methodsynopsis>
	        <type>bool</type>
	        <methodname><link linkend="Class-CompoundField-in_plane">in_plane</link></methodname>
	        <methodparam>
		      <type>const FEMesh*</type>
		      <parameter>mesh</parameter>
	        </methodparam>
	        <modifier>const</modifier>
	      </methodsynopsis>
	    </classsynopsis>
	  </literallayout>
    </refsect2>                 <!-- Python Synopsis -->
    <refsect2>
      <title>Subclasses</title>
      <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><link linkend="Class-ScalarField"><classname>ScalarField</classname></link></simpara>
	    </listitem>
	    <listitem>
	      <simpara><link linkend="Class-TwoVectorField"><classname>TwoVectorField</classname></link></simpara>
	    </listitem>
      </itemizedlist>
    </refsect2>
  </refsynopsisdiv>             <!-- CompoundField Subclasses -->
  <refsection>
    <title>Description</title>
    <para>
	  Most <classname>Field</classname>s that the user encounters in
	  &oof2; are instances of <classname>CompoundField</classname>
	  subclasses.  A <classname>CompoundField</classname> is a
	  <classname>Field</classname> that has been augmented with its
	  out-of-plane parts and the time derivatives of its in- and
	  out-of-plane parts.  These auxiliary parts are
	  <classname>Field</classname>s themselves, but they are not
	  <classname>CompoundField</classname>s.  See <xref
	  linkend="Section-Concepts-Mesh-3D"/> for the details.
    </para>
    <para>
	  When a <classname>CompoundField</classname> is created, its
	  out-of-plane and time derivative parts are created
	  automatically. Their names are the name of the original
	  <classname>CompoundField</classname> with a suffix appended:
	  <quote>_z</quote> for the out-of-plane field, <quote>_t</quote>
	  for the time derivative, and <quote>_tz</quote> for the time
	  derivative of the out-of-plane field.
    </para>
    <para>
      Because <classname>Field</classname> objects are accessible by
      name in the main &oof2; Python namespace, Creating a new
      <classname>CompoundField</classname> will create four new
      variables with names given by the names of the
      <classname>CompoundField</classname> and its auxiliary
      <classname>Field</classname>s.
    </para>
    <para>
      All operations on a <classname>CompoundField</classname> operate
      on the in-plane part, unless specifically noted otherwise.  That
      is, a <classname>CompoundField</classname> acts just like a
      regular <classname>Field</classname>, unless the auxiliary
      <classname>Field</classname>s are explicitly requested.
    </para>
    <para>
	  The C++ class hierarchies for
	  <classname>CompoundField</classname> subclasses are actually
	  moderately complicated, and are simplified somewhat in the
	  documentation.  An alert reader will notice that the
	  out-of-plane part of a <link
	  linkend="Class-ScalarField"><classname>ScalarField</classname></link>
	  can't be another <classname>ScalarField</classname>, because
	  <classname>ScalarField</classname> is derived from
	  <classname>CompoundField</classname>, but the out-of-plane
	  part isn't compounded.  However, for purposes of writing
	  &oof2; extensions, such complications are just distracting.
	  Readers who are interested in the details can consult
	  <filename>SRC/engine/field.h</filename>.
    </para>

    <caution>
      <title>A Possible Source of Confusion</title>
      <para>
        Iterating over the <emphasis role="bold">out-of-plane
        components of a <classname>Field</classname></emphasis> is
        different than iterating over the <emphasis
        role="bold">components of the out-of-plane part of a <link
        linkend="Class-CompoundField"><classname>CompoundField</classname></link></emphasis>.
        Consider <varname>Displacement</varname>, which is a <xref
        linkend="Class-TwoVectorField"/> with x and y components
        only.  As such, it has no out-of-plane components &emdash;
        it has a z component that is implicitly zero:
        <programlisting>
>>> list(Displacement.components())
[VectorFieldIndex(0), VectorFieldIndex(1)]
>>> list(Displacment.components(OUT_OF_PLANE))
[] </programlisting>
        As explained in <xref linkend="Section-Concepts-Mesh-3D"/>,
        the out-of-plane part of a
        <classname>CompoundField</classname> is the z derivative of
        all of its components (including its z components).  For
        <varname>Displacement</varname>, that's a 3-vector:
        <programlisting>
>>> list(Displacement.out_ouf_plane().components())
[VectorFieldIndex(0), VectorFieldIndex(1), VectorFieldIndex(2)] </programlisting>
         There is one out-of-plane component of the out-of-plane
         &Field;:
         <programlisting>
>>> list(Displacement.out_of_plane().components(OUT_OF_PLANE))
[VectorFieldIndex(2)] </programlisting>
      </para>
    </caution>

  </refsection><!-- Description -->
  <refsection>
    <title>Methods</title>
    <refsection id="Class-CompoundField-td">
      <title><code>Field *time_derivative() const</code></title>
      <para>
        <methodname>time_derivative</methodname> returns the &field;
        containing the time derivative of the in-plane parts of a
        <classname>CompoundField</classname>. 
      </para>
    </refsection>
    <refsection id="Class-CompoundField-oop">
	  <title><code>Field *out_of_plane() const</code></title>
	  <para>
	    <methodname>out_of_plane</methodname> returns the <link
	    linkend="Class-Field"><classname>Field</classname></link> that
	    contains the out-of-plane part
	    (<foreignphrase>i.e</foreignphrase>, the z-derivatives) of a
	    <classname>CompoundField</classname>.
	  </para>

    </refsection><!-- out_of_plane -->
    <refsection id="Class-CompoundField-ooptd">
      <title><code>Field *out_of_plane_time_derivative()
      const</code></title>
      <para>
        <methodname>out_of_plane_time_derivative</methodname> returns
        the <link
        linkend="Class-Field"><classname>Field</classname></link> that
        contains the time derivative of the out-of-plane part of a
        <classname>CompoundField</classname>.
      </para>
    </refsection><!-- out_of_plane_time_derivative -->
    <refsection id="Class-CompoundField-in_plane">
	  <title><code>bool in_plane(...) const</code></title>
	  <para>
	    <methodname>in_plane</methodname> indicates whether or not
	    the <classname>CompoundField</classname> is constrained to
	    be <link linkend="Section-Concepts-Mesh-3D">in-plane</link>.
	    In C++, the argument can be a pointer to either an <link
	    linkend="Class-FEMesh"><classname>FEMesh</classname></link>
	    or a <link
	    linkend="Class-CSubProblem"><classname>CSubProblem</classname></link>.
	    In Python, the argument must be an <link
	    linkend="Class-FEMesh"><classname>FEMesh</classname></link>.
	  </para>
	  <note>
	    <para>
	      The out-of-plane <classname>Field</classname> object
	      belonging to a <classname>CompoundField</classname> is
	      always created when the
	      <classname>CompoundField</classname> is created.  Whether
	      or not the <classname>CompoundField</classname> is
	      in-plane is determined by whether or not values for its
	      out-of-plane field are stored in a mesh and allowed to be
	      non-zero.
	    </para>
	  </note>
    </refsection>
  </refsection>                 <!-- Methods -->
</refentry>                     <!-- Field:CompoundField -->

<!-- ============================================================== -->

<refentry id="Class-ScalarField">
  <refnamediv>
    <refname>ScalarField</refname>
    <refpurpose>A scalar-valued <classname>Field</classname></refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <para>
	  Only functions relevant to people writing &oof2; extensions
	  are listed here.  Base class functions are described in the
	  <link
	      linkend="Class-Field"><classname>Field</classname></link>
	  and <link
	  linkend="Class-CompoundField"><classname>CompoundField</classname></link> documentation.
    </para>
    <refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
        #include "engine/field.h" </literallayout>
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname>ScalarField</classname>
	    </ooclass>
	    <ooclass>
	      <modifier>public</modifier>
	      <classname><link linkend="Class-CompoundField">CompoundField</link></classname>
	    </ooclass>
	    <methodsynopsis>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-ScalarField-dofoperator">operator()</link></methodname>
	      <methodparam>
		    <type>const FuncNode*</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-ScalarField-dofoperator">operator()</link></methodname>
	      <methodparam>
		    <type>const FuncNode&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-ScalarField-dofoperator">operator()</link></methodname>
	      <methodparam>
		    <type>const ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
	  </classsynopsis>
    </refsect2><!-- C++ Synopsis -->
    <refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine.field import ScalarField </literallayout>
	  <classsynopsis language="python">
	    <ooclass>
	      <classname>ScalarField</classname>
	    </ooclass>
	    <ooclass>
	      <classname>CompoundField</classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodparam>
		    <parameter>name</parameter>
	      </methodparam>
	    </constructorsynopsis>
	  </classsynopsis>
    </refsect2><!-- Python Synopsis -->
    <refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/field.h</filename>: C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/field.C</filename>: C++ code</simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.swg</filename>: SWIG source code
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.spy</filename>: python code
	        included in <filename>field.swg</filename>.
	      </simpara>
	    </listitem>
	  </itemizedlist>
    </refsect2>
  </refsynopsisdiv>
  <refsection>
    <title>Description</title>
    <para>
	  <classname>ScalarField</classname> is a &Field; whose value is
	  a number at every point in a &mesh;.
	  <classname>ScalarField</classname>s should always be
	  constructed in Python (see <xref
	  linkend="Section-Coding-AddFields"/>).  The constructor has a
	  single argument, which is the name of the &Field;.
    </para>
    <para>
	  Because <classname>ScalarField</classname> is a <link
	  linkend="Class-CompoundField"><classname>CompoundField</classname></link>,
	  when it is constructed its <link
	  linkend="Section-Concepts-Mesh-3D">out-of-plane part</link> and
	  time derivative parts will be constructed automatically.  The
	  out-of-plane part of a scalar field is its
	  <emphasis>z</emphasis> derivative, which is also a scalar.
    </para>
    <para>
	  It is not necessary to keep an explicit Python reference to a
	  newly constructed <classname>ScalarField</classname>.  Existing
	  <classname>Field</classname>s may be retrieved with <link
	  linkend="Function-getField"><function>getField</function></link>.
    </para>
  </refsection><!-- Description -->
  <refsection>
    <title>Methods</title>
    <para>
	  Methods defined in the base classes are not mentioned here.
    </para>
    <refsection id="Class-ScalarField-dofoperator">
	  <title><code>DegreeOfFreedom* operator()(...)</code></title>
	  <programlisting>
DegreeOfFreedom* operator()(const FuncNode *node) const;
DegreeOfFreedom* operator()(const FuncNode&amp; node) const;
DegreeOfFreedom* operator()(const ElementFuncNodeIterator&amp; node) const; </programlisting>
	  <para>
	    These three functions are different ways of obtaining the
	    <classname>DegreeOfFreedom</classname> object containing the
	    value of a <classname>Field</classname> at a <link
	    linkend="Class-Node"><classname>Node</classname></link>.
	    They are identical to the <link
	    linkend="Class-Field-dofoperator"><methodname>operator()</methodname></link>
	    methods defined in the <link
	    linkend="Class-Field"><classname>Field</classname></link>
	    base class, except that they don't require the component
	    index to be specified.  Specifying the component of a scalar
	    field is a bit silly.  However, there is no Python equivalent
        of these functions.
	  </para>
    </refsection>
  </refsection>                 <!-- Methods -->
</refentry>                     <!-- Class:ScalarField -->

<!-- ============================================================== -->

<refentry id="Class-TwoVectorField">
  <refnamediv>
    <refname>TwoVectorField</refname>
    <refpurpose>
	  A two dimensional vector-valued <classname>Field</classname> object
    </refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <para>
	  Only functions relevant to people writing &oof2; extensions
	  are listed here.  Base class functions are described in the
	  <link
	      linkend="Class-Field"><classname>Field</classname></link>
	  and <link
	  linkend="Class-CompoundField"><classname>CompoundField</classname></link> documentation.
    </para>
    <refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
#include "engine/field.h"</literallayout>
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname>TwoVectorField</classname>
	    </ooclass>
	    <ooclass>
	      <modifier>public</modifier>
	      <classname><link
	                     linkend="Class-CompoundField">CompoundField</link></classname>
	    </ooclass>
	  </classsynopsis>
    </refsect2>                 <!-- C++ Synopsis -->
    <refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine.field import TwoVectorField </literallayout>
      <classsynopsis language="python">
	    <ooclass>
	      <classname>TwoVectorField</classname>
	    </ooclass>
	    <ooclass>
	      <classname><link linkend="Class-CompoundField">CompoundField</link></classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodparam>
		    <parameter>name</parameter>
	      </methodparam>
	    </constructorsynopsis>
	  </classsynopsis>
    </refsect2>                 <!-- Python Synopsis -->
    <refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/field.h</filename>: C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/field.C</filename>: C++ code</simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.swg</filename>: SWIG source code
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.spy</filename>: python code
	        included in <filename>field.swg</filename>.
	      </simpara>
	    </listitem>
	  </itemizedlist>
    </refsect2>                 <!-- Source files -->
  </refsynopsisdiv>
  <refsection>
    <title>Description</title>
    <para>
	  <classname>TwoVectorField</classname> is a &Field; whose value
	  is a two dimensional (in-plane) vector at every point in a
	  &mesh;. <classname>TwoVectorField</classname>s should always be
	  constructed in Python (see <xref
	  linkend="Section-Coding-AddFields"/>). The constructor has a
	  single argument, which is the name of the &Field;.
    </para>
    <para>
      Because <classname>TwoVectorField</classname> is a <link
      linkend="Class-CompoundField"><classname>CompoundField</classname></link>,
      when it is constructed its <link
      linkend="Section-Concepts-Mesh-3D">out-of-plane</link> and time
      derivative parts will be constructed automatically.  The
      out-of-plane part of a <classname>TwoVectorField</classname>
      field is a <xref linkend="Class-ThreeVectorField"/>, the three
      dimensional gradient of its <emphasis>z</emphasis> component.
    </para>
    <para>
	  It is not necessary to keep an explicit reference to a newly
	  constructed <classname>TwoVectorField</classname>.  Existing
	  fields may be retrieved with <link
	  linkend="Function-getField"><function>getField</function></link>.
    </para>
  </refsection>                 <!-- Description -->
  <refsection>
    <title>Methods</title>
    <para>
      <classname>TwoVectorField</classname> does not define any
      methods that aren't in its base classes.
    </para>
  </refsection>                 <!-- Methods -->
</refentry>                     <!-- Class:Field:TwoVectorField -->

<!-- ============================================================ -->

<refentry id="Class-ThreeVectorField">
  <refnamediv>
    <refname>ThreeVectorField</refname>
    <refpurpose>
      A three dimensional vector-valued <classname>FIeld</classname>
      object.
    </refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <refsect2>
	  <title>C++ Synopsis</title>
	  <literallayout class="monospaced">
#include "engine/field.h"</literallayout>
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname>ThreeVectorField</classname>
	    </ooclass>
	    <ooclass>
	      <modifier>public</modifier>
	      <classname><link
	                     linkend="Class-Field">Field</link></classname>
	    </ooclass>
	  </classsynopsis>
    </refsect2>                 <!-- C++ Synopsis -->
    <refsect2>
	  <title>Python Synopsis</title>
	  <literallayout class="monospaced">
from ooflib.SWIG.engine.field import ThreeVectorField </literallayout>
      <classsynopsis language="python">
	    <ooclass>
	      <classname>ThreeVectorField</classname>
	    </ooclass>
	    <ooclass>
	      <classname><link linkend="Class-Field">Field</link></classname>
	    </ooclass>
	  </classsynopsis>
    </refsect2>                 <!-- Python Synopsis -->
    <refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/field.h</filename>: C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/field.C</filename>: C++ code</simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.swg</filename>: SWIG source code
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.spy</filename>: python code
	        included in <filename>field.swg</filename>.
	      </simpara>
	    </listitem>
	  </itemizedlist>
    </refsect2>                 <!-- Source files -->
  </refsynopsisdiv>  
  <refsection>
    <title>Description</title>
    <para>
      <classname>ThreeVectorField</classname> is a subclass of &Field;
      that represents a three dimensional vector.  It is not a
      subclass of <link
      linkend="Class-CompoundField"><classname>CompoundField</classname></link>.
      It is used as the out-of-plane and out-of-plane derivative
      &Fields; for <link
      linkend="Class-TwoVectorField"><classname>TwoVectorField</classname></link>.
    </para>
  </refsection>
</refentry>


<!-- Keep this comment at the end of the file
  Local variables:
  sgml-omittag:t
  sgml-shorttag:t 
  sgml-namecase-general:nil
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("../man_oof2.xml" "book" "chapter")
  sgml-exposed-tags:nil
  sgml-local-ecat-files:nil
  End:
-->
