<!-- 
  This software was produced by NIST, an agency of the
  U.S. government, and by statute is not subject to copyright in the
  United States.  Recipients of this software assume all
  responsibilities associated with its operation, modification and
  maintenance. However, to facilitate maintenance we ask that before
  distributing modified versions of this software, you first contact
  the authors at oof_manager@nist.gov.
-->

<!-- TODO: Delete Function-acquirePylock and replace with a page for
     Python_Thread_Allow, Python_Thread_Block, and their macros.
-->

<refentry id="Function-acquirePyLock">
  <refnamediv>
	<refname>acquirePyLock</refname>
	<refpurpose>ensure thread-safe Python API calls</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
	<programlisting>
#include "common/threadstate.h" </programlisting>
	<funcsynopsis>
	  <funcprototype>
	    <funcdef>
	      <type>void</type>
	      <function>acquirePyLock</function>
	    </funcdef>
	    <void/>
	  </funcprototype>
	</funcsynopsis>
	<funcsynopsis>
	  <funcprototype>
	    <funcdef>
	      <type>void</type>
	      <function>releasePyLock</function>
	    </funcdef>
	    <void/>
	  </funcprototype>
	</funcsynopsis>	
  	<programlisting>
#include "common/ooferror.h" </programlisting>
	<funcsynopsis>
	  <funcprototype>
	    <funcdef>
	      <type>void</type>
	      <function>pythonErrorRelay</function>
	    </funcdef>
	    <void/>
	  </funcprototype>
	</funcsynopsis>
  </refsynopsisdiv>
  <refsection>
	<title>Description</title>
	<para>
	  The three functions described here are used whenever &oof2;
	  C++ code calls Python API functions that might invoke the
	  Python interpreter.  It's often difficult to tell when the
	  interpreter will be invoked, so it's a good idea to treat
	  <emphasis>all</emphasis> Python API calls in this way.  See
	  <ulink url="http://docs.python.org/ext/thinIce.html"
	         role="external"/> for a relevant discussion (although in a
	  different context).
	</para>
	<para>
	  Because the Python interpreter is not thread safe, whenever
	  a C++ function in &oof2; needs to call the Python API, it
	  must first acquire the Python global interpreter lock by
	  calling <function>acquirePyLock()</function>.  When it's
	  through with the Python API calls, it must release the lock
	  by calling <function>releasePyLock()</function>. 
	</para>
	<para>
	  A function that neglects to call
	  <function>acquirePyLock()</function> risks crashing the
	  Python interpreter.  A function that neglects to call
	  <function>releasePyLock</function> will probably deadlock
	  the program when the C++ routine finishes.  If running
	  &oof2; with the <link
	  linkend="CommandLineArg-unthreaded"><userinput>--unthreaded</userinput></link>
	  option solves a crashing or deadlocking problem, then check
	  the code for missing calls to
	  <function>acquirePyLock</function> and
	  <function>releasePyLock</function>.
	</para>
	<para>
	  It is important to ensure that
	  <function>releasePyLock</function> is called even if an
	  exception is thrown during the Python API calls.  Python API
	  calls should always occur within a <code>try
	  ... catch</code> block, like this:
	  <programlisting>
        #include "common/threadstate.h"

        acquirePyLock();
        try {
        // Call Python API
        }
        catch (...) {
        releasePyLock();
        throw;
        }
      releasePyLock(); </programlisting>
	</para>
	<para>
	  It's possible that calls to the Python API will raise a
	  Python exception but <emphasis>not</emphasis> throw a C++
	  exception.  Generally, if a Python API function returns
	  <varname>NULL</varname>, an exception has been raised.  The
	  &oof2; function <function>pythonErrorRelay</function>
	  ensures that Python exceptions are re-raised in Python when
	  the C++ function exits.  It should be used like this:

	  <programlisting>
        #include "common/ooferror.h"
        #include "common/threadstate.h"

        acquirePyLock();
        try {
        PyObject *func, *args; // assume these have been set
        PyObject *result = PyEval_Call_Object(func, args); // for example 
        if(result == NULL) 
        pythonErrorRelay();
        // do something with result
        }
        catch (...) {
        releasePyLock();
        throw;
        }
      releasePyLock(); </programlisting>	  

	  <function>pythonErrorRelay</function> raises a C++ exception
	  that will be converted back into a Python exception when
	  control returns to Python.  The mechanism even works if the
	  Python exception was caused by a C++ exception that occurred
	  during a second call back into C++, as long as the original
	  C++ exception was derived from the &oof2; <link
	  linkend="Class-ErrError"><classname>ErrError</classname></link>
	  class.
	</para>
  </refsection>
</refentry><!-- acquirePyLock -->

<!-- ============================================================== -->

<refentry id="Class-ErrError">
  <refnamediv>
	<refname>ErrError</refname>
	<refpurpose>Classes and functions for handling exceptions</refpurpose>
  </refnamediv>
      <refsynopsisdiv>
	    <title>Synopses</title>
	    <refsect2>
	      <title>C++ Synopsis</title>
	      <programlisting>
#include "common/ooferror.h" </programlisting>
	      <classsynopsis language="cpp">
	        <ooclass>
	          <classname>ErrError</classname>
	        </ooclass>
	        <methodsynopsis>
	          <modifier>virtual</modifier>
	          <type>std::string</type>
	          <methodname>pythonequiv</methodname>
	          <void/>
	        </methodsynopsis>
	        <methodsynopsis>
	          <modifier>virtual</modifier>
	          <type>std::string</type>
	          <methodname>message</methodname>
	          <void/>
	        </methodsynopsis>
	      </classsynopsis>      <!-- ErrError -->
	      <classsynopsis language="cpp">
	        <ooclass>
	          <modifier>template &lt;class E&gt;</modifier>
	          <classname>ErrErrorBase</classname>
	        </ooclass>
	        <ooclass>
	          <modifier>public</modifier>
	          <classname>ErrError</classname>
	        </ooclass>
	      </classsynopsis><!-- ErrErrorBase -->
	      <para>
	        The following subclasses are all derived from the
	        <classname>ErrErrorBase</classname> template, but the base
	        class has been omitted here for clarity.
	      </para>
	      <classsynopsis language="cpp">
	        <ooclass>
	          <classname><link linkend="Class-ErrProgrammingError">ErrProgrammingError</link></classname>
	        </ooclass>
	        <constructorsynopsis>
	          <methodname>ErrProgrammingError</methodname>
	          <methodparam>
		        <type>const std::string&amp;</type>
		        <parameter>filename</parameter>
	          </methodparam>
	          <methodparam>
		        <type>int</type>
		        <parameter>line</parameter>
	          </methodparam>
	        </constructorsynopsis>
	        <constructorsynopsis>
	          <methodname>ErrProgrammingError</methodname>
	          <methodparam>
		        <type>const std::string&amp;</type>
		        <parameter>message</parameter>
	          </methodparam>
	          <methodparam>
		        <type>const std::string&amp;</type>
		        <parameter>filename</parameter>
	          </methodparam>
	          <methodparam>
		        <type>int</type>
		        <parameter>line</parameter>
	          </methodparam>
	        </constructorsynopsis>
	      </classsynopsis>      <!-- ErrProgrammingError -->
	      <classsynopsis language="cpp">
	        <ooclass>
	          <classname><link linkend="Class-ErrIndexError">ErrIndexError</link></classname>
	        </ooclass>
	        <constructorsynopsis>
	          <methodname>ErrIndexError</methodname>
	          <methodparam>
		        <type>const std::string&amp;</type>
		        <parameter>message</parameter>
	          </methodparam>
	        </constructorsynopsis>
	      </classsynopsis>      <!-- ErrIndexError -->
	      <classsynopsis language="cpp">
	        <ooclass>
	          <classname><link linkend="Class-ErrUserError">ErrUserError</link></classname>
	        </ooclass>
	        <constructorsynopsis>
	          <methodname>ErrUserError</methodname>
	          <methodparam>
		        <type>const std::string&amp;</type>
		        <parameter>message</parameter>
	          </methodparam>
	        </constructorsynopsis>
	      </classsynopsis><!-- ErrUserError -->
	      <classsynopsis language="cpp">
	        <ooclass>
	          <classname><link linkend="Class-ErrSetupError">ErrSetupError</link></classname>
	        </ooclass>
	        <constructorsynopsis>
	          <methodname>ErrSetupError</methodname>
	          <methodparam>
		        <type>const std::string&amp;</type>
		        <parameter>message</parameter>
	          </methodparam>
	        </constructorsynopsis>
	      </classsynopsis><!-- ErrSetupError -->
	    </refsect2><!-- C++ Synopsis -->
	    <refsect2>
	      <title>Python Synopsis</title>
	      <programlisting>
from oof2.SWIG.common.ooferror import ErrProgrammingError
from oof2.SWIG.common.ooferror import ErrIndexError
from oof2.SWIG.common.ooferror import ErrUserError
from oof2.SWIG.common.ooferror import ErrSetupError </programlisting>
     	  <classsynopsis language="python">
	        <ooclass>
	          <classname><link linkend="Class-ErrProgrammingError">ErrProgrammingError</link></classname>
	        </ooclass>
	        <constructorsynopsis>
	          <methodparam>
		        <parameter>message</parameter>
	          </methodparam>
	          <methodparam>
		        <parameter>filename</parameter>
	          </methodparam>
	          <methodparam>
		        <parameter>line</parameter>
	          </methodparam>
	        </constructorsynopsis>
	      </classsynopsis>      <!-- ErrProgrammingError -->
	      <classsynopsis language="python">
	        <ooclass>
	          <classname><link linkend="Class-ErrPyProgrammingError">ErrPyProgrammingError</link></classname>
	        </ooclass>
	        <constructorsynopsis>
	          <methodparam>
		        <parameter>message</parameter>
	          </methodparam>
	        </constructorsynopsis>
	      </classsynopsis><!-- ErrPyProgrammingError -->
	      <classsynopsis language="python">
	        <ooclass>
	          <classname><link linkend="Class-ErrIndexError">ErrIndexError</link></classname>
	        </ooclass>
	        <constructorsynopsis>
	          <methodparam>
		        <parameter>message</parameter>
	          </methodparam>
	        </constructorsynopsis>
	      </classsynopsis><!-- ErrIndexError -->
	      <classsynopsis language="python">
	        <ooclass>
	          <classname><link linkend="Class-ErrUserError">ErrUserError</link></classname>
	        </ooclass>
	        <constructorsynopsis>
	          <methodparam>
		        <parameter>message</parameter>
	          </methodparam>
	        </constructorsynopsis>
	      </classsynopsis><!-- ErrUserError -->
	      <classsynopsis language="python">
	        <ooclass>
	          <classname><link linkend="Class-ErrSetupError">ErrSetupError</link></classname>
	        </ooclass>
	        <constructorsynopsis>
	          <methodparam>
		        <parameter>message</parameter>
	          </methodparam>
	        </constructorsynopsis>
	      </classsynopsis><!-- ErrSetupError -->
	      <programlisting>
<link linkend="Function-registerErrorClass">registerErrorClass</link>(exc_class)
</programlisting>
        </refsect2><!-- Python Synopsis -->
	    <refsect2>
	      <title>Source Files</title>
	      <itemizedlist spacing="compact">
	        <listitem>
	          <simpara><filename>SRC/common/ooferror.h</filename></simpara>
	        </listitem>
	        <listitem>
	          <simpara><filename>SRC/common/ooferror.C</filename></simpara>
	        </listitem>
	        <listitem>
	          <simpara><filename>SRC/common/ooferror.swg</filename></simpara>
	        </listitem>
	        <listitem>
	          <simpara><filename>SRC/common/ooferror.spy</filename></simpara>
	        </listitem>
	      </itemizedlist>
	    </refsect2>
      </refsynopsisdiv>
      <refsection>
	    <title>Description</title>
	    <para>
	      &oof2; predefines a number of useful exception classes for
	      handling errors, and includes a mechanism for adding new
	      classes.  The mechanism is non-trivial because exceptions
	      have to be able to pass back and forth between C++ and
	      Python.
	    </para>
	    <refsection>
	      <title>Predefined Exception Classes</title>
	      <para>
	        The following classes are all declared in
	        <filename>common/ooferror.h</filename>.  The Python
	        versions can be imported from
	        <code>oof2.SWIG.common.ooferror</code>.
	      </para>
	      <refsection id="Class-ErrProgrammingError">
	        <title><code>class ErrProgrammingError</code></title>
	        <para>
	          This exception indicates that an internal consistency
	          check failed.  Its constructor arguments are a message,
	          the name of the source file and the line number of the
	          code that raised the exception.  In C++, it's easily
	          called like this:
	          <programlisting>
throw ErrProgrammingError("Your message here", __FILE__, __LINE__);</programlisting>

	          In Python, it's easier to use <link
	          linkend="Class-ErrPyProgrammingError"><classname>ErrPyProgrammingError</classname></link>
	          instead.
	        </para>
	        <para>
	          Programming errors are usually fatal to the program.
	        </para>
	      </refsection><!-- ErrProgrammingError -->
	      <refsection id="Class-ErrPyProgrammingError">
	        <title><code>class ErrPyProgrammingError</code></title>
	        <para>
	          <classname>ErrPyProgrammingError</classname> is a Python
	          class derived from <link
	          linkend="Class-ErrProgrammingError"><classname>ErrProgrammingError</classname></link>.
	          It automatically sets the filename and line number
	          parameters by examining the Python traceback stack.  It
	          should be raised whenever an internal inconsistency is
	          detected in Python code.
	        </para>
	        <para>
	          Python programming errors are usually fatal to the
	          program.
	    </para>
	  </refsection><!-- ErrPyProgrammingError -->
	  <refsection id="Class-ErrIndexError">
	    <title><code>class ErrIndexError</code></title>
	    <para>
	      <classname>ErrIndexError</classname> indicates that an
	      array index is out of range.
	    </para> 
	  </refsection><!-- ErrIndexError -->
	  <refsection id="Class-ErrUserError">
	    <title><code>class ErrUserError</code></title>
	    <para>
	      <classname>ErrUserError</classname> indicates that the user
	      did something wrong.  The GUI should (and does) prevent most
	      user errors, but they can still occur if the user loads a
	      malformed script.  User errors should not be fatal (either
	      to the user or to the program).
	    </para>
	  </refsection><!-- ErrUserError -->
	  <refsection id="Class-ErrSetupError">
	    <title><code>class ErrSetupError</code></title>
	    <para>
	      An <classname>ErrSetupError</classname> is a particular
	      variety of <link linkend="Class-ErrUserError">user
	      error</link> indicating that the finite element system being
	      solved hasn't been defined properly.
	    </para>
	  </refsection>
	</refsection><!-- Predefined Exception Classes -->
	<refsection>
	  <title>Adding New Exception Classes</title>
	  <para>
	    In order for exceptions to propagate properly from C++ to
	    Python and back, all &oof2; exception classes must be derived
	    from <classname>ErrErrorBase</classname> in the following way:
	    <programlisting>
class MyError : public ErrErrorBase&lt;MyError&gt; {
public:
  MyError();
  virtual std::string pythonequiv() const;
  virtual std::string message() const;
}; </programlisting>
	  </para>
	  <para>
	    Note that the template parameter is the name of the subclass!
	  </para>
	  <para>
	    The function <methodname>pythonequiv()</methodname> must
	    return a string that, when evaluated by the Python
	    interpreter, will create the equivalent exception in
	    Python. The <classname>MyError</classname> example above would
	    define it like this:
	    <programlisting>
std::string MyError::pythonequiv() const {
  return "NewError()";
} </programlisting>
	  </para>
	  <para>
	    The function <methodname>message</methodname> should return a
	    string indicating what caused the exception.
	  </para>
	  <para>
        <anchor id="Function-registerErrorClass"/>
	    All new exception subclasses must be swigged, and the Python
	    function <function>registerErrorClass</function> must be
	    called with the swigged class as its argument.  (Exception
	    classes declared in <filename>SRC/common/ooferror.h</filename>
	    and swigged in <filename>SRC/common/ooferror.swg</filename>
	    are exempt from this requirement.)  For example, the
	    <classname>MyError</classname> class above would have a swig
	    file <filename>myerror.swg</filename> like this:
	    <programlisting>
%module myerror
%include "common/typemaps.swg"
%extern "common/ooferror.swg"
%{
#include "myerror.h"
%}

class MyError : public ErrError {
public:
  MyError();
  %addmethods {
    string __repr__() {
      return self->message();
    }
  }
};

%pragma(python) include="myerror.spy" </programlisting>

	    and <filename>myerror.spy</filename> would contain:
	    <programlisting>
from oof2.SWIG.common import ooferror
ooferror.registerErrorClass(MyError) </programlisting>
	  </para>
	  <para>
	    See <xref linkend="Section-Extending-swig"/> for more on
	    writing <application>swig</application> input files.
	  </para>
	  <para>
	    For more examples of &oof2; exception classes, see
	    <filename>SRC/engine/ooferror*</filename>.  (The exceptions
	    defined there have very specific internal uses and shouldn't
	    be used in &oof2; extensions, so they aren't discussed here.)
	    Note that it's not possible to derive new exceptions directly
	    from <link
	    linkend="Class-ErrUserError"><classname>ErrUserError</classname></link>
	    or <link
	    linkend="Class-ErrProgrammingError"><classname>ErrProgrammingError</classname></link>
	    because the template parameter would be wrong.  New exceptions
	    must be derived from the intermediate classes
	    <classname>ErrUserErrorBase</classname> or
	    <classname>ErrProgrammingErrorBase</classname>, or directly
	    from <classname>ErrErrorBase</classname>.
	  </para>
	</refsection><!-- Adding New Exception Classes -->
  </refsection>  <!-- Description -->
</refentry>      <!-- ErrError -->

<!-- ============================================================== -->

<refentry id="Function-conjugatePair">
  <refnamediv>
	<refname>conjugatePair</refname>
	<refpurpose>Establish conjugacy relations</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
	<title>Synopsis</title>
	<programlisting>
from oof2.SWIG.engine.conjugate import conjugatePair
      
conjugatePair(name, equation, eqncomp, field, fieldcomp) </programlisting>
  </refsynopsisdiv>
  <refsection>
	<title>Parameters</title>
	<variablelist>
	  <varlistentry>
	    <term><varname>name</varname></term>
	    <listitem>
	      <para>
		    <varname>name</varname> is the <link
		    linkend="para-propertyType"><classname>PropertyType</classname></link>
		    of the &property; that this conjugacy relation applies to.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><varname>equation</varname></term>
	    <listitem>
	      <para>
		    <varname>equation</varname> is the &Equation; object to
		    which the conjugacy relationship applies.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><varname>eqncomp</varname></term>
	    <listitem>
	      <para>
		    <varname>eqncomp</varname> indicates which components of
		    the <varname>equation</varname> the relation applies to.
		    It is either a single &FieldIndex; object or an iterable
		    container of &FieldIndex; objects.  For example, it could
		    be a list of &FieldIndexes;, or the &Components; object
		    returned by <link
		    linkend="Class-Equation-components"><code>Equation.components()</code></link>.		    
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><varname>field</varname></term>
	    <listitem>
	      <para>
		    <varname>field</varname> is the &Field; object to which
		    the conjugacy relationship applies.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><varname>fieldcomp</varname></term>
	    <listitem>
	      <para>
		    <varname>fieldcomp</varname> indicates which components of
		    <varname>field</varname> the relation applies to.  It is
		    either a single &FieldIndex; object or an iterable
		    container of &FieldIndex; objects.
		    <varname>fieldcomp</varname> must represent the same
		    number of components as <varname>eqncomp</varname>.  Each
		    <classname>Field</classname> component in
		    <varname>fieldcomp</varname> is conjugate to the
		    <classname>Equation</classname> component in the same
		    location in <varname>eqncomp</varname>.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
  </refsection>                 <!-- Parameters -->
  <refsection>
	<title>Description</title>
	<para>
	  <function>conjugatePair</function> establishes conjugacy
	  relationships between &Fields; and &Equations;, allowing
	  symmetric finite element stiffness matrices to be
	  constructed.  See <xref
	  linkend="Section-Coding-Conjugates"/> for an overview.
	</para>
	<para>
	  <function>conjugatePair</function> is only available in
	  Python.
	</para>
    <para>
      It is permissable, and even encouraged, to use <link
      linkend="Class-Equation-components"><code>Equation.components()</code></link>
      and <link
      linkend="Class-Field-components"><code>Field.components()</code></link>
      for the <varname>eqncomp</varname> and
      <varname>fieldcomp</varname> arguments.  In most cases this can
      be done simply.  For example, in
      <filename>SRC/engine/problem.py</filename> the <xref
      linkend="Equation-Force_Balance"/> equation and <xref
      linkend="Field-Displacement"/> field are made conjugate like
      this:
      <programlisting>
ForceBalanceEquation = equation.DivergenceEquation('Force_Balance', Stress, 2)
Displacement = field.TwoVectorField('Displacement')
conjugatePair("Elasticity",
              ForceBalanceEquation,
              ForceBalanceEquation.components(),
              Displacement,
              Displacement.components())</programlisting>
    </para>
    <para>
      Caution is required, however, because the order in which indices
      are returned by <code>Field.components()</code> might not match
      the order in which they're returned by
      <code>Equation.components()</code>.  Consider the <xref
      linkend="Equation-Plane_Stress"/> equation:
      <programlisting>
ForcesOutOfPlane = equation.PlaneFluxEquation('Plane_Stress', Stress, 3) </programlisting>

      The components of a <link
      linkend="Class-PlaneFluxEquation"><classname>PlaneFluxEquation</classname></link>
      are the out-of-plane components of its &Flux;, which in this case
      is a <link
      linkend="Class-SymmetricTensorFlux"><classname>SymmetricTensorFlux</classname></link>.
      The &ComponentIterator; for the tensor flux returns components
      in <link linkend="table-voigt">Voigt</link> order:
      <literallayout class="monospaced">
>>> list(Stress.components(OUT_OF_PLANE))
[SymTensorIndex(2,2), SymTensorIndex(1,2), SymTensorIndex(0,2)]</literallayout>

      which are Voigt indices 2, 3, and 4.  The &Field; that is
      conjugate to the out-of-plane parts of the <xref
      linkend="Flux-Stress"/> is the <link
      linkend="Section-Concepts-Mesh-3D">out-of-plane part</link> of
      the Displacement, <code>Displacement.out_of_plane()</code>,
      composed of the <emphasis>x</emphasis>, <emphasis>y</emphasis>,
      and <emphasis>z</emphasis> derivatives of the
      <emphasis>z</emphasis> component of the <xref
      linkend="Field-Displacement"/>.  This is a <link
      linkend="Class-ThreeVectorField"><classname>ThreeVectorField</classname></link>,
      and its components are simple vector field indices 0, 1, and 2:
      <literallayout class="monospaced">
>>> list(Displacement.out_of_plane().components())
[VectorFieldIndex(0), VectorFieldIndex(1), VectorFieldIndex(2)] </literallayout>

    </para>
    <para>
      The equation for the <emphasis>zz</emphasis> (ie, 22) component
      of the <xref linkend="Flux-Stress"/> should be conjugate to the
      <emphasis>z</emphasis> (ie, 2) component of the <xref
      linkend="Field-Displacement"/> derivatives.  But invoking
      <function>conjugatePair</function> naively, like this:
      <programlisting>
conjugatePair("Elasticity",
              ForcesOutOfPlane,
              ForcesOutOfPlane.components(),
              Displacement.out_of_plane(),
              Displacement.out_of_plane().components()) </programlisting>
      
      will associate &Equation; component
      <code>SymTensoorIndex(2,2)</code> (ie, <emphasis>zz</emphasis>)
      with &Field; component <code>VectorFieldIndex(0)</code> (ie,
      <emphasis>x</emphasis>), because those are the first components
      returned by the iterators.  It will similarly pair
      <code>SymTensorIndex(0,2)</code> with
      <code>VectorFieldIndex(2)</code>.  To get the correct conjugacy
      relations, it's necessary to reverse the order of one of the
      sets of components:
      <programlisting>
conjugatePair("Elasticity",
              ForcesOutOfPlane,
              ForcesOutOfPlane.components(),
              Displacement.out_of_plane(),
              reversed(list(Displacement.out_of_plane().components()))) </programlisting>

    </para>
  </refsection>                 <!-- Description -->
</refentry>                     <!-- conjugatePair -->

<!-- ============================================================== -->

  <refentry id="Function-xmlmenudump.loadFile">
    <refnamediv>
      <refname>loadFile</refname>
      <refpurpose>Specify an external file of documentation</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <title>Python Synopsis</title>
      <programlisting>
from oof2.common.IO.xmlmenudump import loadFile

loadFile(filename, func=None) </programlisting> 
    </refsynopsisdiv>
    <refsection>
      <title>Description</title>
      <para>
	Many &oof2; objects contain their own documentation.  The
	<link linkend="Chapter-Reference">reference section</link> of
	the &oof2; manual is generated automatically from the
	<varname>discussion</varname> data in menu items, <link
	linkend="Class-PropertyRegistration"><classname>PropertyRegistrations</classname></link>,
	<foreignphrase>etc</foreignphrase>.  Short
	<varname>discussions</varname> can be simple character
	strings, but longer discussions are more conveniently stored
	in separate files.  In those cases,
	<varname>discussion</varname> should be set to the return
	value of <code>loadFile(filename)</code>, where
	<varname>filename</varname> is the file containing the
	discussion.  The file must contain text that is suitable for
	inclusion in a <ulink url="http://www.docbook.org"
	role="external">DocBook</ulink>
	<literal>&lt;refentry&gt;</literal> element.<footnote>
	  <para>
	    The simplest such text would be a single paragraph
	    surrounded by <literal>&lt;para&gt;</literal> and
	    <literal>&lt;/para&gt;</literal> tags.
	  </para>
	</footnote>
      </para>
      <para>
	The <varname>func</varname> argument, if specified, should be
	a function that is called to preprocess the contents of the
	file before it's included in the manual.  The arguments to
	<varname>func</varname> are <varname>text</varname> (the
	contents of the file) and <varname>obj</varname> (the menu
	item or <classname>PropertyRegistration</classname> or other
	object being documented).
      </para>
      <para>
	The file specified by <function>loadFile</function> isn't
	actually read until the manual is built (using the command
	<xref linkend="MenuItem-OOF.Help.API_Listing"/>.)  That means
	that if you have no intention of building your own version of
	the manual, you can specify anything you want for the
	filename.  Of course, in that case you can also omit the
	<varname>discussions</varname> entirely as well.
      </para>
      <para>
	The given filename is assumed to be relative to the
	<filename>OOF2/MAN_OOF2</filename> directory.  Because of its
	size, this directory isn't included in the standard &oof2;
	distributions, so it will be difficult for extension authors
	to generate their own customized version of the manual.
	Please contact the &oof2; authors if you need a copy.
      </para>
    </refsection>
  </refentry>


<!-- Keep this comment at the end of the file
  Local variables:
  sgml-omittag:t
  sgml-shorttag:t 
  sgml-namecase-general:nil
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("../man_oof2.xml" "book" "chapter")
  sgml-exposed-tags:nil
  sgml-local-ecat-files:nil
  End:
-->
