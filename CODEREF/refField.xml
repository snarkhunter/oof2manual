<!-- 
  This software was produced by NIST, an agency of the
  U.S. government, and by statute is not subject to copyright in the
  United States.  Recipients of this software assume all
  responsibilities associated with its operation, modification and
  maintenance. However, to facilitate maintenance we ask that before
  distributing modified versions of this software, you first contact
  the authors at oof_manager@nist.gov.
-->

<reference>
  <title>Field Classes and Functions</title>
<refentry id="Class-Field">
  <refnamediv>
    <refname>Field</refname>
    <refpurpose>Base class for fields</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <para>
	  Only those methods useful when extending &oof2; are listed here.
    </para>
    <refsect2>
	  <title>C++ Synopsis</title>

      <programlisting>
#include "engine/field.h"</programlisting>

      <classsynopsis language="cpp">
	    <ooclass>
	      <classname>Field</classname>
	    </ooclass>
	    <methodsynopsis>
          <modifier>const</modifier>
	      <type>std::string&amp;</type>
	      <methodname><link linkend="Class-Field-name">name</link></methodname>
	      <void/>
	      <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
	      <type>int</type>
	      <methodname><link
		                  linkend="Class-Field-ndof">ndof</link></methodname>
	      <void/>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <type>bool</type>
	      <methodname><link
		                  linkend="Class-Field-is_defined">is_defined</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>CSubProblem*</type>
		    <parameter>subproblem</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <type>bool</type>
	      <methodname><link
		                  linkend="Class-Field-is_active">is_active</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>CSubProblem*</type>
		    <parameter>subproblem</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-Field-dofoperator">operator()</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FuncNode*</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <type>int</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
          <modifier>virtual</modifier>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-Field-dofoperator">operator()</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <type>int</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-Field-dofoperator">operator()</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FuncNode&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <type>int</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-Field-dofoperator">operator()</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>IndexP&amp;</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>

	    <methodsynopsis>
	      <type>double</type>
	      <methodname><link
                          linkend="Class-Field-value">value</link></methodname>
          <methodparam>
            <type>const FEMesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FuncNode*</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <type>int</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <type>double</type>
	      <methodname><link
                          linkend="Class-Field-value">value</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>FEmesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <type>int</type>
		    <parameter>component</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>

        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>double</type>
          <methodname><link
                          linkend="Class-Field-value">value</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>FEmesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>Element*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>MasterPosition&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>FieldIndex&amp;</type>
            <parameter>component</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>
        
        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>double</type>
          <methodname><link
          linkend="Class-Field-gradient">gradient</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>FEmesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>Element*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>MasterPosition&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>FieldIndex&amp;</type>
            <parameter>component</parameter>
          </methodparam>
          <methodparam>
            <type>SpaceIndex</type>
            <parameter>index</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>
        
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>ArithmeticOutputValue</type>
	      <methodname><link
		                  linkend="Class-Field-output">output</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>FEMesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
        
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>ArithmeticOutputValue</type>
	      <methodname><link
		                  linkend="Class-Field-output">output</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>FEMesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>FuncNode&amp;</type>
            <parameter>node</parameter>
          </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>

        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>Components*</type>
          <methodname><link
                          linkend="Class-Field-components">components</link></methodname>
          <methodparam>
            <type>Planarity</type>
            <parameter>planarity</parameter>
            <initializer>ALL_INDICES</initializer>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>

        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>Components*</type>
          <methodname><link
                          linkend="Class-Field-oop-components">outOfPlaneComponents</link></methodname>
          <void/>
          <modifier>const</modifier>
        </methodsynopsis>

        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>FieldIndex*</type>
          <methodname><link
                          linkend="Class-Field-getIndex">getIndex</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>std::string&amp;</type>
            <parameter>name</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>
        
	  </classsynopsis>
    </refsect2><!-- Field C++ Synopsis -->
    
    <refsect2>
	  <title>Python Synopsis</title>
      <programlisting>
from ooflib.SWIG.engine.field import Field</programlisting>
      <classsynopsis language="python">
	    <ooclass>
	      <classname>Field</classname>
	    </ooclass>

	    <methodsynopsis>
	      <methodname><link
		                  linkend="Class-Field-ndof">ndof</link></methodname>
	      <void/>
	    </methodsynopsis>

	    <methodsynopsis>
	      <methodname><link
		                  linkend="Class-Field-is_defined">is_defined</link></methodname>
	      <methodparam>
		    <parameter>mesh</parameter>
	      </methodparam>
	    </methodsynopsis>

	    <methodsynopsis>
	      <methodname><link
		                  linkend="Class-Field-is_active">is_active</link></methodname>
	      <methodparam>
		    <parameter>mesh</parameter>
	      </methodparam>
	    </methodsynopsis>

	    <methodsynopsis>
	      <methodname><link
                          linkend="Class-Field-value">value</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
	      <methodparam>
		    <parameter>node</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>component</parameter>
	      </methodparam>
	    </methodsynopsis>

        <methodsynopsis>
          <methodname><link
                          linkend="Class-Field-components">components</link></methodname>
          <methodparam>
            <parameter>planarity</parameter>
            <initializer>ALL_INDICES</initializer>
          </methodparam>
        </methodsynopsis>

        <methodsynopsis>
          <methodname><link
                          linkend="Class-Field-oop-components">outOfPlaneComponents</link></methodname>
          <void/>
        </methodsynopsis>

        <methodsynopsis>
          <methodname><link
                          linkend="Class-Field-getIndex">getIndex</link></methodname>
          <methodparam>
            <parameter>name</parameter>
          </methodparam>
        </methodsynopsis>
        
	  </classsynopsis>
    </refsect2><!-- Field Python Synopsis -->

    <refsect2>
	  <title>Subclasses</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><link linkend="Class-CompoundField"><classname>CompoundField</classname></link></simpara>
	    </listitem>
	    <listitem>
	      <simpara><link linkend="Class-ScalarField"><classname>ScalarField</classname></link></simpara>
	    </listitem>
	    <listitem>
	      <simpara><link linkend="Class-TwoVectorField"><classname>TwoVectorField</classname></link></simpara>
	    </listitem>
	  </itemizedlist>
    </refsect2><!-- Field subclasses -->
    
    <refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/field.h</filename>: C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/field.C</filename>: C++ code</simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.swg</filename>: SWIG source code
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.spy</filename>: python code
	        included in <filename>field.swg</filename>.
	      </simpara>
	    </listitem>
	  </itemizedlist>
    </refsect2><!-- Field Source files -->
    
  </refsynopsisdiv>
  <refsection>
    <title>Description</title>
    <para>
	  <classname>Field</classname> is an abstract base class for all
	  types of fields in &oof2;.  The role of fields is described in
	  <xref linkend="Section-Concepts-Mesh-Field"/>.  Like <link
	  linkend="Class-Flux"><classname>Fluxes</classname></link> and
	  <link
	  linkend="Class-Equation"><classname>Equations</classname></link>,
	  &Field; instances are global objects &mdash; there is one
	  instance for each physical field and it is shared by all
	  &meshes; that use it.  &Fields; store information about
	  the physical field (such as its name and dimension), but do not
	  store the actual values of the &Field;. That's done by a
	  &mesh;, by using bookkeeping data from a &Field;.
    </para>
    <para>
	  Most of the programming interface for &Fields; is defined
	  in the base class, which is an abstract C++ class.  Most of the
	  API is available from both C++ and Python.
    </para>
    <para>
	  Most of the &Field; objects encountered by &oof2; users and
	  extenders are actually instances of the <link
	  linkend="Class-CompoundField"><classname>CompoundField</classname></link>
	  class, which groups the in-plane and out-of-plane parts of a
	  &Field;, along with their time derivatives, all of which
	  are &Fields; themselves.
    </para>
    <para>
      <classname>Field</classname> objects should only be created by
      calling the Python constructors of the <xref
      linkend="Class-CompoundField"/> subclasses.  See <xref
      linkend="Class-CompoundField"/> for the details.  After a
      <classname>Field</classname> has been created, it can be
      retrieved in C++ or Python via the <link
      linkend="Function-getField"><function>getField</function></link>
      function.  It is not necessary to keep an explicit Python
      reference to a newly created <classname>Field</classname>.
      For convenience in <link
      linkend="MenuItem-OOF.File.Load.Script">scripts</link>, a
      variable with the <classname>Field</classname>'s name referring
      to the <classname>Field</classname> is defined in the main
      &oof2; namespace, which is aslo used in <link
      linkend="Section-ScriptGUI">text mode</link> and the <link
      linkend="Section-Windows-Console">Console Window</link>.
    </para>
    <para>
      Several methods are available for computing the values of
      &Fields; at points within an &FEMesh;.
      <itemizedlist>
        <listitem>
          <para>
            Various versions of <function><link
            linkend="Class-Field-value">Field::value()</link></function>
            return the value of a component of a &Field; at a given
            &Node;.
          </para>
        </listitem>
        <listitem>
          <para>
            Versions of <function><link
            linkend="Class-Field-value">Field::value()</link></function>
            with &Element; and position arguments return the value of
            a field component interpolated within the given &Element;.
          </para>
        </listitem>
        <listitem>
          <para>
            <function><link linkend="Class-Field-value">Field::value()</link></function> returns the
            value of a &Field; component at an arbitrary position
            within an &Element;.  <link
            linkend="Class-ScalarField"><classname>ScalarField</classname></link>
            has a version that doesn't require a
            <varname>component</varname> argument.
          </para>
        </listitem>
        <listitem>
          <para>
            Each concrete non-scalar subclass of &Field; has a
            <function>values()</function> method that returns all of
            the &Field; components at an arbitrary point within an
            &Element;, and a <function>gradients()</function> method
            that returns the gradient components.  These non-virtual
            methods return different types of objects for different
            types of &Fields;.
          </para>
        </listitem>
        <listitem>
          <para>
            The virtual <function><link
            linkend="Class-Field-output">Field::output()</link></function>
            methods return generic <link
            linkend="Class-Output"><classname>Output</classname></link>
            objects meant for transferring data and modifying it for
            output, although they can be useful in other situations.
          </para>
        </listitem>
        <listitem>
          <para>
            Various forms of <link
            linkend="Class-Field-dofoperator"><function>Field::operator()</function></link>
            return a pointer to the low-level <link
            linkend="Class-DegreeOfFreedom"><classname>DegreeOfFreedom</classname></link>
            objects that store &Field; values in an &FEMesh;.
          </para>
        </listitem>
      </itemizedlist>
      See the documentation of each subclass for the details.
    </para>
  </refsection>
  
  <refsection>
    <title>Methods</title>

    <refsection id="Class-Field-name">
      <title><code>std::string&amp; name() const</code></title>
	  <para>
	    <methodname>name()</methodname> returns the name assigned to
	    the <classname>Field</classname> when it was created.
	  </para>
    </refsection><!-- name -->
    
    <refsection id="Class-Field-ndof">
	  <title><code>int ndof() const</code></title>
      <para>
	    <methodname>ndof()</methodname> returns the number of degrees
	    of freedom in the <classname>Field</classname>.  This is the
	    number of data values that must be allocated to store the
	    <classname>Field</classname> at each &node; of the &mesh;.
	    For <link
	    linkend="Class-CompoundField"><classname>CompoundFields</classname></link>,
	    <methodname>ndof</methodname> returns the size of the
	    <emphasis>in-plane</emphasis> part.
	  </para>
    </refsection><!-- ndof -->
    
    <refsection id="Class-Field-is_defined">
      <title><code>bool is_defined(const CSubProblem* subp) const</code></title>
	  <para>
	    <methodname>is_defined()</methodname> indicates whether the
	    <classname>Field</classname> has been <link
	    linkend="MenuItem-OOF.Mesh.Field.Define">defined</link> on the
	    given <link
	    linkend="Class-CSubProblem"><classname>CSubProblem</classname></link>.
	    Defined <classname>Fields</classname> have been assigned
	    values on &nodes;.
	  </para>
    </refsection><!-- is_defined -->
    
    <refsection id="Class-Field-is_active">
	  <title><code> bool is_active(const CSubProblem *subp) const</code></title>
	  <para>
	    <methodname>is_active()</methodname> indicates whether the
	    <classname>Field</classname> has been <link
	    linkend="MenuItem-OOF.Mesh.Field.Activate">activated</link> on
	    the given <link
	    linkend="Class-CSubProblem"><classname>CSubProblem</classname></link>.
	    Active <classname>Fields</classname> are being solved for.
	  </para>
    </refsection><!-- is_active -->
    
    <refsection id="Class-Field-dofoperator">
	  <title><code>DegreeOfFreedom* operator()(...) const</code></title>
	  <programlisting>
DegreeOfFreedom* operator()(const &FuncNode;*, int component) const;
DegreeOfFreedom* operator()(const &FuncNode;&amp;, int component) const;
DegreeOfFreedom* operator()(const &ElementFuncNodeIterator;&amp;, int component) const;
DegreeOfFreedom* operator()(const &ElementFuncNodeIterator;&amp;, const <link linkend="Class-IndexP">IndexP</link>&amp;) const; </programlisting>
	  <para>
	    This family of methods are all ways of obtaining the value of
	    a <classname>Field</classname> at a given &FuncNode;.
	    (&FuncNode; is the subclass of &Node; for Nodes that
	    store <classname>Field</classname> data.)  The different
	    methods are provided for convenience, to allow different
	    representations of <classname>Nodes</classname> or
	    <classname>Field</classname> components.  All of these methods
	    return a pointer to a <link
	    linkend="Class-DegreeOfFreedom"><classname>DegreeOfFreedom</classname></link>
	    object, which wraps the actual <classname>Field</classname>
	    component value and is stored at the
	    <classname>Node</classname>.
	  </para>
	  <para>
	    <classname>DegreeOfFreedom</classname>s are low-level, fairly
	    primitive objects, so these methods cannot be used to extract
	    aggregate values, such as all of the components of a
	    multicomponent &Field;.  To do that, or to interpolate a
	    &Field; value at an arbitrary point within an &Element;, see
	    <link
	    linkend="Class-Field-value"><function>Field::value()</function></link>
	    or <link
	    linkend="Class-Field-output"><methodname>Field::output()</methodname></link>.
	  </para>
    </refsection><!-- operator() -->
    
    <refsection id="Class-Field-value">
	  <title><code>double value(...) const</code></title>
      <programlisting>
double value(const &FEMesh;*, const &FuncNode;*, int component) const;
double value(const &FEMesh;*, const &ElementFuncNodeIterator;&amp;, int component) const;
double value(const &FEMesh;*, const &Element;*, const <classname><link
linkend="Class-MasterPosition">MasterPosition</link></classname>&amp;, const <classname><link linkend="Class-FieldIndex">FieldIndex</link></classname>&amp; component) const; </programlisting>
	  <para>
	    The first two forms of <methodname>value()</methodname> 
	    evaluate a component of a &Field; at a &Node;.
        In C++, the given
	    <varname>node</varname> must be a &FuncNode; pointer or a
	    <link
	    linkend="Class-ElementFuncNodeIterator"><classname>ElementFuncNodeIterator</classname></link>
	    reference.  In Python, it must be a <link
	    linkend="Class-Node"><classname>FuncNode</classname></link>
	    object.
	  </para>
      <para>
        The third form of <methodname>value()</methodname> returns the
        value of a component of a &Field; interpolated at an arbitrary
        point within an &Element;.  The point is given in the
        &Element;'s master coordinate space.  (This version is
        currently only available in C++.)
      </para>
    </refsection>               <!-- Field::value() -->

    <refsection id="Class-Field-gradient">
      <title><code>double gradient(...) const</code></title>
      <programlisting>
double gradient(const &FEMesh;*, const &Element;*, const <classname><link linkend="Class-MasterPosition">MasterPosition</link></classname>&amp; position,
                const <classname><link linkend="Class-FieldIndex">FieldIndex</link></classname>&amp; component, <classname><link linkend="Class-SpaceIndex">SpaceIndex</link></classname> direction) const; </programlisting>
      <para>
        <function>gradient()</function> returns the gradient in
        direction <varname>dir</varname> of the given
        <varname>component</varname> of the &Field; at the given
        <varname>position</varname> inside an &Element;.  The position
        is given in the &Element;'s <link
        linkend="Class-MasterPosition">master coordinate</link> space.
        The <varname>direction</varname> is 0, 1, or 2, for &xhat;,
        &yhat;, and &zhat;, respectively.
      </para>
    </refsection> <!-- Field::gradient -->
    
    <refsection id="Class-Field-output">
	  <title><code>ArithmeticOutputvalue output(...)</code></title>
	  <programlisting>
&ArithmeticOutputValue; output(const &FEMesh;*, const &ElementFuncNodeIterator;&amp;) const;
&ArithmeticOutputValue; output(const &FEMesh;*, const &FuncNode;&amp;) const; </programlisting>
	  <para>
	    These functions return an &OutputValue;
	    object which wraps an &OutputVal;
	    object which contains the value of the
	    <classname>Field</classname> at the given &Node;.
	    These calls are mostly used as a mechanism for generically
	    transferring <classname>Field</classname> values to Python
	    when plotting data, but they can also be useful when writing
	    <classname>Field</classname>-dependent <link
	    linkend="Class-Property"><classname>Property</classname></link>s.
	  </para>
	  <para>
	    The <methodname>output</methodname> functions differ from
	    <link
	    linkend="Class-Field-dofoperator"><methodname>Field::operator()</methodname></link>
	    and <link
	    linkend="Class-Field-value"><methodname>Field::value()</methodname></link>
	    by returning all of the components of a multi-dimensional
	    <classname>Field</classname> in one call.
	  </para>
    </refsection><!-- output -->

    <refsection id="Class-Field-components">
      <title><code>Components* components(Planarity planarity) const;</code></title>
      <para>
        <methodname>components()</methodname> returns a container-like
        object that can be iterated over to obtain the indices of a
        <classname>Field</classname>.  The optional
        &Planarity; argument determines which
        <classname>Field</classname> components are included.  If it
        is omitted, <code><link
        linkend="Class-Planarity">ALL_INDICES</link></code> is
        assumed.
      </para>
      <para>
        For example,
        in C++ you can write
        <programlisting>
Field *displacement = Field::getField("Displacement");
for(IndexP index : *displacement->components()) { <lineannotation>// ALL_INDICES is implicit</lineannotation>
    ...                                           <lineannotation>//  Do something with IndexP index</lineannotation>
} </programlisting>
        or, equivalently,
        <programlisting>
Components* comps = Field::getField("Displacement")->components(ALL_INDICES);
for(ComponentIteratorP i=comps->begin(); i!=comps->end(); i++) {
   IndexP index = *i;                        <lineannotation>// Dereference ComponentIterator to get IndexP</lineannotation>
   ...                                       <lineannotation>// Do something with IndexP index</lineannotation>
} </programlisting>
        to loop over all components of the displacement field.  The
        equivalent in Python is
        <programlisting>
for index in displacement.components():
    ...                                       <lineannotation># Do something with FieldIndex index</lineannotation> </programlisting>          

        Note that the index object returned in C++ is an &IndexP;,
        which is a wrapper around a &FieldIndex; pointer.  In Python
        the wrapping is unnecessary and the index object is a
        &FieldIndex;.
      </para>
      <para>
        See <xref linkend="Section-Coding-Indices"/> for an overview,
        and <xref linkend="Class-Components"/> for the details.
      </para>
    </refsection>               <!--Class-Field-components-->

    <refsection id="Class-Field-oop-components">
      <title><code>Components* outOfPlaneComponents() const;</code></title>
      <para>
        Like <link
        linkend="Class-Field-components"><methodname>components</methodname></link>,
        <methodname>outOfPlaneComponents</methodname> returns a
        container that can be iterated over. However, iterating only
        returns the out-of-plane components of the
        <classname>Field</classname>.
      </para>
      <caution id="Field-confusion">
        <title>A Possible Source of Confusion</title>
        <para>
          <code>Field::<emphasis
          role="bold">components(OUT_OF_PLANE)</emphasis></code> and
          <code>Field::<emphasis
          role="bold">outOfPlaneComponents()</emphasis></code> are
          similar but not identical.  They both refer to the same
          components of a <classname>Field</classname> and iterate
          over them in the same order.  But the first is used to
          locate the out-of-plane components in a list that contains
          all of the components, while the second is used to iterate
          over a list that contains only the out-of-plane components.
          The difference is illustrated by using the <link
          linkend="FieldIndex-integer"><function>FieldIndex::integer</function></link>
          method to examine the list indices of the components.
        </para>
        <para>
          For example, the out-of-plane part of the
          <varname>Displacement</varname> field is a 3-vector, with
          indices 0, 1, and 2 obtained from its
          <function>components()</function> method:
          <literallayout class="monospaced">
>>> list(Displacement.out_of_plane().<emphasis role="bold">components()</emphasis>)
[VectorFieldIndex(0), VectorFieldIndex(1), VectorFieldIndex(2)]
>>> list(i.integer() for i in Displacement.out_of_plane().<emphasis role="bold">components()</emphasis>)
[0, 1, 2] </literallayout>

          On the other hand,
          <function>outOfPlaneComponents()</function> returns only the
          z component, but gives it integer index 0, because it's the
          first and only out-of-plane component:
          
          <literallayout class="monospaced">
>>> list(Displacement.out_of_plane().<emphasis role="bold">outOfPlaneComponents()</emphasis>)
[OutOfPlaneVectorFieldIndex(2)]
>>> list(i.integer() for i in Displacement.out_of_plane().<emphasis role="bold">outOfPlaneComponents()</emphasis>)
[0] </literallayout>
        </para>
        <para>
          A similar issue arises with <link
          linkend="Flux-confusion"><classname>Fluxes</classname></link>.
        </para>
      </caution>
    </refsection>               <!--Class-Field-oop-components-->

    <refsection id="Class-Field-getIndex">
      <title><code>FieldIndex* getIndex(std::string&amp; name) const;</code></title>
      <para>
        <function>getIndex()</function> returns a &FieldIndex; object,
        given the <varname>name</varname> of the desired index.
        Different <classname>Field</classname> subclasses expect
        different strings, and return different subclasses of
        &FieldIndex;.  For example, a <link
        linkend="Class-TwoVectorField"><classname>TwoVectorField</classname></link>
        expects the <varname>name</varname> to be
        <userinput>"x"</userinput> or <userinput>"y"</userinput>, and
        returns a <link
        linkend="Class-VectorFieldIndex"><classname>VectorFieldIndex</classname></link>.
      </para>
      <para>
        In C++ the returned value is a pointer to a newly allocated
        object.  The caller is responsible for deleting it.  An easy
        way to do that is to wrap it in an &IndexP;, which will delete
        the pointer in the &IndexP;'s destructor:
        <programlisting>
Field *field = ...;
IndexP index = IndexP(field->getIndex("x")); </programlisting>
      </para>
    </refsection>

  </refsection>                 <!-- Field Methods -->
</refentry>                     <!-- Field -->

<!-- ============================================================== -->

<refentry id="Class-CompoundField">
  <refnamediv>
    <refname>CompoundField</refname>
    <refpurpose>
	  A <classname>Field</classname> with both in- and
	  out-of-plane parts.
    </refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <para>
	  Only those methods useful for extending &oof2; are listed
	  here.  Base class functions are described in the &Field;
	  documentation.
    </para>
    <refsect2>
	  <title>C++ Synopsis</title>
      <programlisting>
#include "engine/field.h"</programlisting>
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname>CompoundField</classname>
	    </ooclass>
	    <ooclass>
	      <modifier>public</modifier>
          <modifier>virtual</modifier>
	      <classname><link linkend="Class-Field">Field</link></classname>
	    </ooclass>
        <methodsynopsis>
          <type>Field*</type>
          <methodname><link
                          linkend="Class-CompoundField-td">time_derivative</link></methodname>
          <void/>
          <modifier>const</modifier>
        </methodsynopsis>
	    <methodsynopsis>
	      <type>Field*</type>
	      <methodname><link
	                      linkend="Class-CompoundField-oop">out_of_plane</link></methodname>
	      <void/>
	      <modifier>const</modifier>
	    </methodsynopsis>
        <methodsynopsis>
          <type>Field*</type>
          <methodname><link linkend="Class-CompoundField-ooptd">out_of_plane_time_derivative</link></methodname>
          <void/>
          <modifier>const</modifier>
        </methodsynopsis>
	    <methodsynopsis>
	      <type>bool</type>
	      <methodname><link
	                      linkend="Class-CompoundField-in_plane">in_plane</link></methodname>
	      <methodparam>
		    <type>const FEMesh*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
	      <type>bool</type>
	      <methodname><link
		                  linkend="Class-CompoundField-in_plane">in_plane</link></methodname>
	      <methodparam>
		    <type>const CSubProblem*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
	  </classsynopsis>
    </refsect2><!-- C++ Synopsis -->
    <refsect2>
	  <title>Python Synopsis</title>
      <programlisting>
from ooflib.SWIG.engine.field import CompoundField </programlisting>
      <classsynopsis language="python">
	    <ooclass>
	      <classname>CompoundField</classname>
	    </ooclass>
	    <ooclass>
	      <classname><link linkend="Class-Field">Field</link></classname>
	    </ooclass>
        <methodsynopsis>
          <methodname><link
                          linkend="Class-CompoundField-td">time_derivative</link></methodname>
          <void/>
        </methodsynopsis>
	    <methodsynopsis>
	      <methodname><link
		                  linkend="Class-CompoundField-oop">out_of_plane</link></methodname>
	      <void/>
	    </methodsynopsis>
	    <methodsynopsis>
	      <methodname><link
		                  linkend="Class-CompoundField-ooptd">out_of_plane_time_derivative</link></methodname>
	      <void/>
	    </methodsynopsis>

	    <methodsynopsis>
	      <type>bool</type>
	      <methodname><link linkend="Class-CompoundField-in_plane">in_plane</link></methodname>
	      <methodparam>
		    <type>const FEMesh*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
	  </classsynopsis>
    </refsect2>                 <!-- Python Synopsis -->
    <refsect2>
      <title>Subclasses</title>
      <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><link linkend="Class-ScalarField"><classname>ScalarField</classname></link></simpara>
	    </listitem>
	    <listitem>
	      <simpara><link linkend="Class-TwoVectorField"><classname>TwoVectorField</classname></link></simpara>
	    </listitem>
      </itemizedlist>
    </refsect2>
  </refsynopsisdiv>             <!-- CompoundField Subclasses -->
  <refsection>
    <title>Description</title>
    <para>
	  Most <classname>Field</classname>s that the user encounters in
	  &oof2; are instances of <classname>CompoundField</classname>
	  subclasses.  A <classname>CompoundField</classname> is a
	  <classname>Field</classname> that has been augmented with its
	  out-of-plane parts and the time derivatives of its in- and
	  out-of-plane parts.  These auxiliary parts are
	  <classname>Field</classname>s themselves, but they are not
	  <classname>CompoundField</classname>s.  See <xref
	  linkend="Section-Concepts-Mesh-3D"/> for the details.
    </para>
    <para>
	  When a <classname>CompoundField</classname> is created, its
	  out-of-plane and time derivative parts are created
	  automatically. Their names are the name of the original
	  <classname>CompoundField</classname> with a suffix appended:
	  <quote>_z</quote> for the out-of-plane field, <quote>_t</quote>
	  for the time derivative, and <quote>_tz</quote> for the time
	  derivative of the out-of-plane field.
    </para>
    <para>
      Because <classname>Field</classname> objects are accessible by
      name in the main &oof2; Python namespace, Creating a new
      <classname>CompoundField</classname> will create four new
      variables with names given by the names of the
      <classname>CompoundField</classname> and its auxiliary
      <classname>Field</classname>s.
    </para>
    <para>
      All operations on a <classname>CompoundField</classname> operate
      on the in-plane part, unless specifically noted otherwise.  That
      is, a <classname>CompoundField</classname> acts just like a
      regular <classname>Field</classname>, unless the auxiliary
      <classname>Field</classname>s are explicitly requested.
    </para>
    <para>
	  The C++ class hierarchies for
	  <classname>CompoundField</classname> subclasses are actually
	  moderately complicated, and are simplified somewhat in the
	  documentation.  An alert reader will notice that the
	  out-of-plane part of a <link
	  linkend="Class-ScalarField"><classname>ScalarField</classname></link>
	  can't be another <classname>ScalarField</classname>, because
	  <classname>ScalarField</classname> is derived from
	  <classname>CompoundField</classname>, but the out-of-plane
	  part isn't compounded.  However, for purposes of writing
	  &oof2; extensions, such complications are just distracting.
	  Readers who are interested in the details can consult
	  <filename>SRC/engine/field.h</filename>.
    </para>

    <caution>
      <title>A Possible Source of Confusion</title>
      <para>
        Iterating over the <emphasis role="bold">out-of-plane
        components of a <classname>Field</classname></emphasis> is
        different than iterating over the <emphasis
        role="bold">components of the out-of-plane part of a <link
        linkend="Class-CompoundField"><classname>CompoundField</classname></link></emphasis>.
        Consider <varname>Displacement</varname>, which is a <xref
        linkend="Class-TwoVectorField"/> with x and y components
        only.  As such, it has no out-of-plane components &emdash;
        it has a z component that is implicitly zero:
        <literallayout class="monospaced">
>>> list(Displacement.components())
[VectorFieldIndex(0), VectorFieldIndex(1)]
>>> list(Displacment.components(OUT_OF_PLANE))
[] </literallayout>
        As explained in <xref linkend="Section-Concepts-Mesh-3D"/>,
        the out-of-plane part of a
        <classname>CompoundField</classname> is the z derivative of
        all of its components (including its z components).  For
        <varname>Displacement</varname>, that's a 3-vector:
        <literallayout class="monospaced">
>>> list(Displacement.out_ouf_plane().components())
[VectorFieldIndex(0), VectorFieldIndex(1), VectorFieldIndex(2)] </literallayout>
         There is one out-of-plane component of the out-of-plane
         &Field;:
         <literallayout class="monospaced">
>>> list(Displacement.out_of_plane().components(OUT_OF_PLANE))
[VectorFieldIndex(2)] </literallayout>
      </para>
    </caution>

  </refsection><!-- Description -->
  <refsection>
    <title>Methods</title>
    <refsection id="Class-CompoundField-td">
      <title><code>Field *time_derivative() const</code></title>
      <para>
        <methodname>time_derivative</methodname> returns the &field;
        containing the time derivative of the in-plane parts of a
        <classname>CompoundField</classname>. 
      </para>
    </refsection>
    <refsection id="Class-CompoundField-oop">
	  <title><code>Field *out_of_plane() const</code></title>
	  <para>
	    <methodname>out_of_plane</methodname> returns the <link
	    linkend="Class-Field"><classname>Field</classname></link> that
	    contains the out-of-plane part
	    (<foreignphrase>i.e</foreignphrase>, the z-derivatives) of a
	    <classname>CompoundField</classname>.
	  </para>

    </refsection><!-- out_of_plane -->
    <refsection id="Class-CompoundField-ooptd">
      <title><code>Field *out_of_plane_time_derivative()
      const</code></title>
      <para>
        <methodname>out_of_plane_time_derivative</methodname> returns
        the <link
        linkend="Class-Field"><classname>Field</classname></link> that
        contains the time derivative of the out-of-plane part of a
        <classname>CompoundField</classname>.
      </para>
    </refsection><!-- out_of_plane_time_derivative -->
    <refsection id="Class-CompoundField-in_plane">
	  <title><code>bool in_plane(...) const</code></title>
	  <para>
	    <methodname>in_plane</methodname> indicates whether or not
	    the <classname>CompoundField</classname> is constrained to
	    be <link linkend="Section-Concepts-Mesh-3D">in-plane</link>.
	    In C++, the argument can be a pointer to either an <link
	    linkend="Class-FEMesh"><classname>FEMesh</classname></link>
	    or a <link
	    linkend="Class-CSubProblem"><classname>CSubProblem</classname></link>.
	    In Python, the argument must be an <link
	    linkend="Class-FEMesh"><classname>FEMesh</classname></link>.
	  </para>
	  <note>
	    <para>
	      The out-of-plane <classname>Field</classname> object
	      belonging to a <classname>CompoundField</classname> is
	      always created when the
	      <classname>CompoundField</classname> is created.  Whether
	      or not the <classname>CompoundField</classname> is
	      in-plane is determined by whether or not values for its
	      out-of-plane field are stored in a mesh and allowed to be
	      non-zero.
	    </para>
	  </note>
    </refsection>
  </refsection>                 <!-- Methods -->
</refentry>                     <!-- Field:CompoundField -->

<!-- ============================================================== -->

<refentry id="Class-ScalarField">
  <refnamediv>
    <refname>ScalarField</refname>
    <refpurpose>A scalar-valued <classname>Field</classname></refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <para>
	  Only functions relevant to people writing &oof2; extensions
	  are listed here.  Base class functions are described in the
	  <link
	      linkend="Class-Field"><classname>Field</classname></link>
	  and <link
	  linkend="Class-CompoundField"><classname>CompoundField</classname></link> documentation.
    </para>
    <refsect2>
	  <title>C++ Synopsis</title>
      <programlisting>
#include "engine/field.h" </programlisting>
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname>ScalarField</classname>
	    </ooclass>
	    <ooclass>
	      <modifier>public</modifier>
	      <classname><link linkend="Class-CompoundField">CompoundField</link></classname>
	    </ooclass>
	    <methodsynopsis>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-ScalarField-dofoperator">operator()</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FuncNode*</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-ScalarField-dofoperator">operator()</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FuncNode&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>
	    <methodsynopsis>
	      <type>DegreeOfFreedom*</type>
	      <methodname><link linkend="Class-ScalarField-dofoperator">operator()</link></methodname>
	      <methodparam>
		    <type>const ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>       <!--operator()-->

        <methodsynopsis>
          <type>double</type>
          <methodname><link
                          linkend="Class-ScalarField-value">value</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>FEMesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>Element</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>MasterPosition&amp;</type>
            <parameter>point</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>       <!--value-->

        <methodsynopsis>
          <type>double</type>
          <methodname><link
                          linkend="Class-ScalarField-gradient">gradient</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>FEMesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>Element</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type>MasterPosition&amp;</type>
            <parameter>point</parameter>
          </methodparam>
          <methodparam>
            <type>SpaceIndex</type>
            <parameter>direction</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>       <!--gradient-->
        
        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>FieldIndex*</type>
          <methodname><link linkend="Class-ScalarField-getIndex">getIndex</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>std::string&amp;</type>
            <parameter>name</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>       <!-- getIndex -->
	  </classsynopsis>
    </refsect2><!-- C++ Synopsis -->
    <refsect2>
	  <title>Python Synopsis</title>
      <programlisting>
from ooflib.SWIG.engine.field import ScalarField </programlisting>
	  <classsynopsis language="python">
	    <ooclass>
	      <classname>ScalarField</classname>
	    </ooclass>
	    <ooclass>
	      <classname>CompoundField</classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodparam>
		    <parameter>name</parameter>
	      </methodparam>
	    </constructorsynopsis>
        <methodsynopsis>
          <methodname><link linkend="Class-ScalarField-getIndex">getIndex</link></methodname>
          <methodparam>
            <parameter>name</parameter>
          </methodparam>
        </methodsynopsis>
	  </classsynopsis>
    </refsect2>                 <!-- Python Synopsis -->
    <refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/field.h</filename>: C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/field.C</filename>: C++ code</simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.swg</filename>: SWIG source code
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.spy</filename>: python code
	        included in <filename>field.swg</filename>.
	      </simpara>
	    </listitem>
	  </itemizedlist>
    </refsect2>                 <!-- Source files -->
  </refsynopsisdiv>
  <refsection>
    <title>Description</title>
    <para>
	  <classname>ScalarField</classname> is a &Field; whose value is
	  a number at every point in a &mesh;.
	  <classname>ScalarField</classname>s should always be
	  constructed in Python (see <xref
	  linkend="Section-Coding-AddFields"/>).  The constructor has a
	  single argument, which is the name of the &Field;.
    </para>
    <para>
	  Because <classname>ScalarField</classname> is a <link
	  linkend="Class-CompoundField"><classname>CompoundField</classname></link>,
	  when it is constructed its <link
	  linkend="Section-Concepts-Mesh-3D">out-of-plane part</link> and
	  time derivative parts will be constructed automatically.  The
	  out-of-plane part of a scalar field is its
	  <emphasis>z</emphasis> derivative, which is also a scalar.
    </para>
    <para>
	  It is not necessary to keep an explicit Python reference to a
	  newly constructed <classname>ScalarField</classname>.  Existing
	  <classname>Field</classname>s may be retrieved with <link
	  linkend="Function-getField"><function>getField</function></link>.
    </para>
    <para>
      The &FieldIndex; class for <classname>ScalarField</classname> is
      <link
      linkend="Class-ScalarFieldIndex"><classname>ScalarFieldIndex</classname></link>.
    </para>
  </refsection><!-- Description -->
  <refsection>
    <title>Methods</title>
    <para>
	  Methods defined in the base classes are not mentioned here,
      unless the derived class functions behave differently in some way.
    </para>
    <refsection id="Class-ScalarField-dofoperator">
	  <title><code>DegreeOfFreedom* operator()(...)</code></title>
	  <programlisting>
DegreeOfFreedom* operator()(const FuncNode *node) const;
DegreeOfFreedom* operator()(const FuncNode&amp; node) const;
DegreeOfFreedom* operator()(const ElementFuncNodeIterator&amp; node) const; </programlisting>
	  <para>
	    These three functions are different ways of obtaining the
	    <classname>DegreeOfFreedom</classname> object containing the
	    value of a <classname>Field</classname> at a <link
	    linkend="Class-Node"><classname>Node</classname></link>.
	    They are identical to the <link
	    linkend="Class-Field-dofoperator"><methodname>operator()</methodname></link>
	    methods defined in the <link
	    linkend="Class-Field"><classname>Field</classname></link>
	    base class, except that they don't require the component
	    index to be specified.  Specifying the component of a scalar
	    field is a bit silly.  However, there is no Python equivalent
        of these functions.
	  </para>
    </refsection>               <!-- ScalarField::operator() -->

    <refsection id="Class-ScalarField-value">
      <title><code>double value(...) const</code></title>
      <programlisting>
double value(const <link linkend="Class-FEMesh">FEMesh</link>* mesh, const <link linkend="Class-Element">Element</link>* element, const <link linkend="Class-MasterPosition">MasterPosition</link>&amp; point) const;</programlisting>
      <para>
        This version of <function>value()</function> computes the
        value of a <classname>ScalarField</classname> at the given
        <varname>point</varname> within the given
        <varname>element</varname>. It is a non-virtual method,
        inaccessible from a generic &Field; pointer.  Unlike the
        <link linkend="Class-Field-value">generic virtual
        method</link> in the &Field; class, this version does
        not require a <varname>component</varname> argument.
      </para>
    </refsection>               <!-- ScalarField::value -->

    <refsection id="Class-ScalarField-gradient">
      <title><code>double gradient(...) const</code></title>
      <programlisting>
double gradient(const <link linkend="Class-FEMesh">FEMesh</link>* mesh, const <link linkend="Class-Element">Element</link>* element, const <link linkend="Class-MasterPosition">MasterPosition</link>&amp; point,
                <link linkend="Class-SpaceIndex">SpaceIndex</link> direction) const;
      </programlisting>
      <para>
        <function>gradient()</function> is like <link
        linkend="Class-ScalarField-value"><function>value()</function></link>,
        but it computes the gradient of the &Field; in the given
        <varname>direction</varname>.
      </para>
    </refsection>               <!--ScalarField::gradient-->
    <refsection>
      <title><code>double gradient(...) const</code></title>
      <programlisting>
double gradient(const <link linkend="Class-FEMesh">FEMesh</link>* mesh, const <link linkend="Class-Element">Element</link>* element, const <link linkend="Class-MasterPosition">MasterPosition</link>&amp; point, <link linkend="Class-SpaceIndex">SpaceIndex</link> direction) const;</programlisting>
      <para>
        This version of <function>gradient()</function> computes the
        gradient of a <classname>ScalarField</classname> in the given
        <varname>direction</varname> at the given
        <varname>point</varname> within the given
        <varname>element</varname>. It is a non-virtual method,
        inaccessible from a generic &Field; pointer.  Unlike the <link
        linkend="Class-Field-gradient">generic virtual method</link>
        in the &Field; class, this version does not require a
        <varname>component</varname> argument.
      </para>
    </refsection>               <!-- ScalarField::gradient -->

    <refsection id="Class-ScalarField-getIndex">
      <title>
        <code>FieldIndex *getIndex(const std::string &amp;name) const</code>
      </title>
      <para>
        <code>ScalarField::getIndex()</code> returns a pointer to a
        <link
        linkend="Class-ScalarFieldIndex"><classname>ScalarFieldIndex</classname></link>.
        The <varname>name</varname> argument is ignored.
      </para>
    </refsection>               <!-- ScalarField::getIndex -->
  </refsection>                 <!-- Methods -->
</refentry>                     <!-- Class:ScalarField -->

<!-- ============================================================== -->

<refentry id="Class-TwoVectorField">
  <refnamediv>
    <refname>TwoVectorField</refname>
    <refpurpose>
	  A two dimensional vector-valued <classname>Field</classname> object
    </refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <para>
	  Only functions relevant to people writing &oof2; extensions
	  are listed here.  Base class functions are described in the
	  <link
	      linkend="Class-Field"><classname>Field</classname></link>
	  and <link
	  linkend="Class-CompoundField"><classname>CompoundField</classname></link> documentation.
    </para>
    <refsect2>
	  <title>C++ Synopsis</title>
      <programlisting>
#include "engine/field.h" </programlisting>
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname>TwoVectorField</classname>
	    </ooclass>
	    <ooclass>
	      <modifier>public</modifier>
	      <classname><link
	                     linkend="Class-CompoundField">CompoundField</link></classname>
	    </ooclass>
        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>FieldIndex*</type>
          <methodname><link linkend="Class-TwoVectorField-getIndex">getIndex</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>std::string&amp;</type>
            <parameter>name</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>       <!-- getIndex -->

        <methodsynopsis> 
          <type>DoubleVec</type>
          <methodname><link
                          linkend="Class-TwoVectorField-values">values</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><link linkend="Class-FEMesh">FEMesh</link>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><link linkend="Class-Element">Element</link>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><link
                      linkend="Class-MasterPosition">MasterPosition</link>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
        </methodsynopsis>       <!-- values -->
        <methodsynopsis> 
          <type>DoubleVec</type>
          <methodname><link
                          linkend="Class-TwoVectorField-gradients">gradients</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><link linkend="Class-FEMesh">FEMesh</link>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><link linkend="Class-Element">Element</link>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><link
                      linkend="Class-MasterPosition">MasterPosition</link>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <type><link linkend="Class-SpaceIndex">SpaceIndex</link></type>
            <parameter>direction</parameter>
          </methodparam>
        </methodsynopsis>       <!-- gradients -->
	  </classsynopsis>
    </refsect2>                 <!-- C++ Synopsis -->
    <refsect2>
	  <title>Python Synopsis</title>
      <programlisting>
from ooflib.SWIG.engine.field import TwoVectorField </programlisting>
      <classsynopsis language="python">
	    <ooclass>
	      <classname>TwoVectorField</classname>
	    </ooclass>
	    <ooclass>
	      <classname><link linkend="Class-CompoundField">CompoundField</link></classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodparam>
		    <parameter>name</parameter>
	      </methodparam>
	    </constructorsynopsis>
        <methodsynopsis>
          <methodname><link linkend="Class-TwoVectorField-getIndex">getIndex</link></methodname>
          <methodparam>
            <parameter>name</parameter>
          </methodparam>
        </methodsynopsis>       <!-- getIndex -->
	  </classsynopsis>
    </refsect2>                 <!-- Python Synopsis -->
    <refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/field.h</filename>: C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/field.C</filename>: C++ code</simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.swg</filename>: SWIG source code
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.spy</filename>: python code
	        included in <filename>field.swg</filename>.
	      </simpara>
	    </listitem>
	  </itemizedlist>
    </refsect2>                 <!-- Source files -->
  </refsynopsisdiv>
  <refsection>
    <title>Description</title>
    <para>
	  <classname>TwoVectorField</classname> is a &Field; whose value
	  is a two dimensional (in-plane) vector at every point in a
	  &mesh;. <classname>TwoVectorField</classname>s should always be
	  constructed in Python (see <xref
	  linkend="Section-Coding-AddFields"/>). The constructor has a
	  single argument, which is the name of the &Field;.
    </para>
    <para>
      Because <classname>TwoVectorField</classname> is a <link
      linkend="Class-CompoundField"><classname>CompoundField</classname></link>,
      when it is constructed its <link
      linkend="Section-Concepts-Mesh-3D">out-of-plane</link> and time
      derivative parts will be constructed automatically.  The
      out-of-plane part of a <classname>TwoVectorField</classname>
      field is a <xref linkend="Class-ThreeVectorField"/>, the three
      dimensional gradient of its <emphasis>z</emphasis> component.
    </para>
    <para>
	  It is not necessary to keep an explicit reference to a newly
	  constructed <classname>TwoVectorField</classname>.  Existing
	  fields may be retrieved with <link
	  linkend="Function-getField"><function>getField</function></link>.
    </para>
    <para>
      The &FieldIndex; class for <classname>TwoVectorField</classname>
      is <link
      linkend="Class-VectorFieldIndex"><classname>VectorFieldIndex</classname></link>. The
      &Components; class is <link
      linkend="Class-VectorFieldComponents"><classname>VectorFieldComponents</classname></link>,
      and the &ComponentIterator; is <link
      linkend="Class-VectorFieldIterator"><classname>VectorFieldIterator</classname></link>.
    </para>
  </refsection>                 <!-- Description -->
  <refsection>
    <title>Methods</title>
    <refsection id="Class-TwoVectorField-getIndex">
      <title>
        <code>FieldIndex *getIndex(const std::string &amp;name) const</code>
      </title>
      <para>
        <code>TwoVectorField::getIndex()</code> returns a pointer to a
        <link
        linkend="Class-VectorFieldIndex"><classname>VectorFieldIndex</classname></link>.
        The <varname>name</varname> argument can be
        <userinput>"x"</userinput> or <userinput>"y"</userinput>.
      </para>
    </refsection>               <!-- getIndex -->

    <refsection id="Class-TwoVectorField-values">
      <title> <code>DoubleVec values(...) const</code> </title>
      <programlisting>
<link linkend="Class-DoubleVec">DoubleVec</link> values(const <link linkend="Class-FEMesh">FEMesh</link>* mesh, const <link linkend="Class-Element">Element</link>* element, const <link linkend="Class-MasterPosition">MasterPosition</link>&amp; point) const;</programlisting>
      <para>
        <function>values()</function> is a non-virtual method that
        returns all (that is, both) components of a
        <classname>TwoVectorField</classname> in a vector at the given
        <varname>point</varname> within the given
        <varname>element</varname>.
      </para>
      <para>
        To retrieve &Field; values from a generic <code>Field*</code>
        pointer, either cast the pointer to the derived type and call
        <function>values()</function>:
        <programlisting>
DoubleVec vals = dynamic_cast&lt;const TwoVectorField*&gt;(field)->values(mesh, element, point); </programlisting>
         or access the components individually via the &Field; base
         class methods:
         <programlisting>
DoubleVec vals(field->ndof());
for(IndexP i : *field->components())
  vals[i] = field->value(mesh, element, point, i);</programlisting>
      </para>
    </refsection>               <!-- values -->

    <refsection id="Class-TwoVectorField-gradients">
      <title><code>DoubleVec gradients(...) const</code></title>
      <programlisting>
<link linkend="Class-DoubleVec">DoubleVec</link> gradients(const <link linkend="Class-FEMesh">FEMesh</link>* mesh, const <link linkend="Class-Element">Element</link>* element, const <link linkend="Class-MasterPosition">MasterPosition</link>&amp; point, <link linkend="Class-SpaceIndex">SpaceIndex</link> direction) const; </programlisting>

      <para>
        <function>gradients()</function> is just like <link
        linkend="Class-TwoVectorField-values"><function>values()</function></link>,
        but it returns the components of the gradients in the given
        <varname>direction</varname>.  That is, <code>gradients(mesh,
        element, x, j)</code> returns a vector whose
        <inlineequation><alt
        role="tex">\(i^\mathrm{th}\)</alt></inlineequation> component
        is the <inlineequation><alt
        role="tex">\(j\)</alt></inlineequation>-derivative of the
        <inlineequation><alt
        role="tex">\(i^\mathrm{th}\)</alt></inlineequation> component
        of the <classname>TwoVectorField</classname>.
      </para>
    </refsection>               <!-- gradients -->
  </refsection>                 <!-- Methods -->
</refentry>                     <!-- Class:Field:TwoVectorField -->

<!-- ============================================================ -->

<refentry id="Class-ThreeVectorField">
  <refnamediv>
    <refname>ThreeVectorField</refname>
    <refpurpose>
      A three dimensional vector-valued <classname>Field</classname>
      object.
    </refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <refsect2>
	  <title>C++ Synopsis</title>
      <programlisting>
#include "engine/field.h" </programlisting>
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname>ThreeVectorField</classname>
	    </ooclass>
	    <ooclass>
	      <modifier>public</modifier>
	      <classname><link
	                     linkend="Class-Field">Field</link></classname>
	    </ooclass>
        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>FieldIndex*</type>
          <methodname><link linkend="Class-ThreeVectorField-getIndex">getIndex</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>std::string&amp;</type>
            <parameter>name</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>       <!-- getIndex -->
        <methodsynopsis> 
          <type>DoubleVec</type>
          <methodname><link
                          linkend="Class-ThreeVectorField-values">values</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><link linkend="Class-FEMesh">FEMesh</link>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><link linkend="Class-Element">Element</link>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><link
                      linkend="Class-MasterPosition">MasterPosition</link>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
        </methodsynopsis>       <!-- values -->
        <methodsynopsis> 
          <type>DoubleVec</type>
          <methodname><link
                          linkend="Class-ThreeVectorField-gradients">gradients</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><link linkend="Class-FEMesh">FEMesh</link>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><link linkend="Class-Element">Element</link>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><link
                      linkend="Class-MasterPosition">MasterPosition</link>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <type><link linkend="Class-SpaceIndex">SpaceIndex</link></type>
            <parameter>direction</parameter>
          </methodparam>
        </methodsynopsis>       <!-- gradients -->
        
	  </classsynopsis>
    </refsect2>                 <!-- C++ Synopsis -->
    <refsect2>
	  <title>Python Synopsis</title>
      <programlisting>
from ooflib.SWIG.engine.field import ThreeVectorField </programlisting>
      <classsynopsis language="python">
	    <ooclass>
	      <classname>ThreeVectorField</classname>
	    </ooclass>
	    <ooclass>
	      <classname><link linkend="Class-Field">Field</link></classname>
	    </ooclass>
        <methodsynopsis>
          <methodname><link linkend="Class-ThreeVectorField-getIndex">getIndex</link></methodname>
          <methodparam>
            <parameter>name</parameter>
          </methodparam>
        </methodsynopsis>       <!-- getIndex -->
	  </classsynopsis>
    </refsect2>                 <!-- Python Synopsis -->
    <refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/field.h</filename>: C++ header</simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/engine/field.C</filename>: C++ code</simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.swg</filename>: SWIG source code
	      </simpara>
	    </listitem>
	    <listitem>
	      <simpara>
	        <filename>SRC/engine/field.spy</filename>: python code
	        included in <filename>field.swg</filename>.
	      </simpara>
	    </listitem>
	  </itemizedlist>
    </refsect2>                 <!-- Source files -->
  </refsynopsisdiv>  
  <refsection>
    <title>Description</title>
    <para>
      <classname>ThreeVectorField</classname> is a subclass of &Field;
      that represents a three dimensional vector.  It is not a
      subclass of <link
      linkend="Class-CompoundField"><classname>CompoundField</classname></link>.
      It is used as the out-of-plane and out-of-plane derivative
      &Fields; for <link
      linkend="Class-TwoVectorField"><classname>TwoVectorField</classname></link>.
    </para>
    <para>
      The &FieldIndex; type for a
      <classname>ThreeVectorField</classname> is <link
      linkend="Class-VectorFieldIndex"><classname>VectorFieldIndex</classname></link>.
      The &Components; type is <link
      linkend="Class-VectorFieldComponents"><classname>VectorFieldComponents</classname></link>,
      and the &ComponentIterator; is <link
      linkend="Class-VectorFieldIterator"><classname>VectorFieldIterator</classname></link>.
    </para>
  </refsection>
  <refsection>
    <title>Methods</title>
    <refsection id="Class-ThreeVectorField-getIndex">
      <title>
        <code>FieldIndex *getIndex(const std::string &amp;name) const</code>
      </title>
      <para>
        <code>ThreeVectorField::getIndex()</code> returns a pointer to
        a <link
        linkend="Class-VectorFieldIndex"><classname>VectorFieldIndex</classname></link>.
        The <varname>name</varname> argument can be
        <userinput>"x"</userinput>, <userinput>"y"</userinput>, or
        <userinput>"z"</userinput>.
      </para>
    </refsection>               <!-- getIndex -->
    <refsection id="Class-ThreeVectorField-values">
      <title> <code>DoubleVec values(...) const</code> </title>
      <programlisting>
<link linkend="Class-DoubleVec">DoubleVec</link> values(const <link linkend="Class-FEMesh">FEMesh</link>* mesh, const <link linkend="Class-Element">Element</link>* element, const <link linkend="Class-MasterPosition">MasterPosition</link>&amp; point) const;</programlisting>
      <para>
        <function>values()</function> is a non-virtual method that
        returns all components of a
        <classname>ThreeVectorField</classname> in a vector at the
        given <varname>point</varname> within the given
        <varname>element</varname>.
      </para>
      <para>
        To retrieve &Field; values from a generic <code>Field*</code>
        pointer, either cast the pointer to the derived type and call
        <function>values()</function>:
        <programlisting>
DoubleVec vals = dynamic_cast&lt;const ThreeVectorField*&gt;(field)->values(mesh, element, point); </programlisting>
         or access the components individually via the &Field; base
         class methods:
         <programlisting>
DoubleVec vals(field->ndof());
for(IndexP i : *field->components())
  vals[i] = field->value(mesh, element, point, i);</programlisting>
      </para>
    </refsection>               <!-- values -->

    <refsection id="Class-ThreeVectorField-gradients">
      <title><code>DoubleVec gradients(...) const</code></title>
      <programlisting>
<link linkend="Class-DoubleVec">DoubleVec</link> gradients(const <link linkend="Class-FEMesh">FEMesh</link>* mesh, const <link linkend="Class-Element">Element</link>* element, const <link linkend="Class-MasterPosition">MasterPosition</link>&amp; point, <link linkend="Class-SpaceIndex">SpaceIndex</link> direction) const; </programlisting>

      <para>
        <function>gradients()</function> is just like <link
        linkend="Class-ThreeVectorField-values"><function>values()</function></link>,
        but it returns the components of the gradients in the given
        <varname>direction</varname>.  That is, <code>gradients(mesh,
        element, x, j)</code> returns a vector whose
        <inlineequation><alt
        role="tex">\(i^\mathrm{th}\)</alt></inlineequation> component
        is the <inlineequation><alt
        role="tex">\(j\)</alt></inlineequation>-derivative of the
        <inlineequation><alt
        role="tex">\(i^\mathrm{th}\)</alt></inlineequation> component
        of the <classname>ThreeVectorField</classname>.
      </para>
    </refsection>               <!-- gradients -->
  </refsection>                 <!-- Methods -->
</refentry>

<!-- ============================================================ -->

<refentry id="Function-getField">
  <refnamediv>
    <refname>getField</refname>
    <refpurpose>Retrieve a <classname>Field</classname> object by
    name</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>Synopses</title>
    <refsect2>
      <title>C++</title>
      <programlisting>
#include "engine/field.h"
static Field* Field::getField(const std::string&amp; name); </programlisting>
    </refsect2>
    
    <refsect2>
      <title>Python</title>
      <programlisting>
from ooflib.SWIG.engine import field
f = field.getField(name) </programlisting>
    </refsect2>
    <refsect2>
      <title>Source Files</title>
      <itemizedlist spacing="compact">
        <listitem>
          <simpara>
            <filename>SRC/engine/field.h</filename>: C++ headers
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/field.C</filename>: C++ code
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/field.swg</filename>: SWIG source code
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/field.spy</filename>: Python code
            included in <filename>field.swg</filename>.
          </simpara>
        </listitem>
      </itemizedlist>
    </refsect2>
  </refsynopsisdiv>
  <refsection>
    <title>Parameters</title>
    <variablelist>
      <varlistentry>
        <term><varname>name</varname></term>
        <listitem>
          <para>
            The name of an existing &Field;.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Description</title>
    <para>
      <function>getField</function> returns a previously created
      &Field; object.  In C++ it returns a pointer to the base class,
      which may be cast to the derived class:
      <programlisting>
ScalarField *T = dynamic_cast&lt;ScalarField*&gt;(getField("Temperature")); </programlisting>
      In Python, it returns a reference to an object
      of the appropriate derived class:
      <literallayout class="monospaced">
>>> T = getField("Temperature")
>>> type(T)
&lt;class 'ooflib.SWIG.engine.field.ScalarField'&gt; </literallayout>

      <function>getFlux</function> is defined in the main &oof2;
      namespace so that it can be used freely in <link
      linkend="MenuItem-OOF.File.Load.Script">scripts</link>, <link
      linkend="Section-ScriptGUI">text mode</link> and the <link
      linkend="Section-Windows-Console">Console Window</link>.

    </para>
  </refsection>
</refentry>                     <!-- getField -->

</reference>
<!-- Keep this comment at the end of the file
  Local variables:
  sgml-omittag:t
  sgml-shorttag:t 
  sgml-namecase-general:nil
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("../man_oof2.xml" "reference")
  sgml-exposed-tags:nil
  sgml-local-ecat-files:nil
  End:
-->
