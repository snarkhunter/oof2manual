<!-- 
  This software was produced by NIST, an agency of the
  U.S. government, and by statute is not subject to copyright in the
  United States.  Recipients of this software assume all
  responsibilities associated with its operation, modification and
  maintenance. However, to facilitate maintenance we ask that before
  distributing modified versions of this software, you first contact
  the authors at oof_manager@nist.gov.
-->

<!-- TODO: Be consistent about whether or not argument types in
     synopses are links. -->

<refentry id="Class-Property">
  <refnamediv>
    <refname>Property</refname>
    <refpurpose>Base class for material properties</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <refsect2>
	  <title>C++ Synopsis</title>
      <para>
        This synopsis lists the virtual base class methods that may be
        redefined when deriving a new <classname>Property</classname>
        class.  It is not a complete list of
        <classname>Property</classname> methods.  Do not derive new
        C++ <classname>Properties</classname> directly from this
        class.  They should be derived from one of the subclasses
        <link linkend="Class-Property-subclasses">listed below</link>.
      </para>
	  <programlisting >
#include "engine/property.h" </programlisting>
      <classsynopsis language="cpp">
	    <ooclass>
	      <classname>Property</classname>
	    </ooclass>
        <constructorsynopsis>
          <methodname>Property</methodname>
          <methodparam>
            <modifier>const</modifier>
            <type>std::string&amp;</type>
            <parameter>name</parameter>
          </methodparam>
          <methodparam>
            <type>PyObject*</type>
            <parameter>registration</parameter>
          </methodparam>
        </constructorsynopsis>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link linkend="Class-Property-cross_reference">cross_reference</link></methodname>
	      <methodparam>
		    <type>Material*</type>
		    <parameter>material</parameter>
	      </methodparam>
	    </methodsynopsis>

        <methodsynopsis>
          <modifier>virtual</modifier>
          <type>bool</type>
          <methodname><link
                          linkend="Class-Property-constant_in_space">constant_in_space</link></methodname>
          <void/>
          <modifier>const</modifier>
        </methodsynopsis>     <!-- constant_in_space -->

	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link
		                  linkend="Class-Property-precompute">precompute</link></methodname>
          <methodparam>
            <type>FEMesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
	    </methodsynopsis>     <!-- precompute -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link
                          linkend="Class-Property-clear_mesh_data">clear_mesh_data</link></methodname>
          <methodparam>
            <type>FEMesh*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <type>void*</type>
            <parameter>data</parameter>
          </methodparam>
        </methodsynopsis>       <!-- clear_mesh_data -->
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link
		                  linkend="Class-Property-begin_element">begin_element</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>CSubProblem*</type>
		    <parameter>subproblem</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><classname><xref linkend="Class-Element"/></classname>*</type>
		    <parameter>element</parameter>
	      </methodparam>
	    </methodsynopsis>     <!-- begin_element -->
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link
	                      linkend="Class-Property-end_element">end_element</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>const CSubProblem*</type>
		    <parameter>subproblem</parameter>
	      </methodparam>
	      <methodparam>
		    <type>const Element*</type>
		    <parameter>element</parameter>
	      </methodparam>
	    </methodsynopsis>     <!-- end_element -->

	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link
		                  linkend="Class-Property-post_process">post_process</link></methodname>
	      <methodparam>
		    <type>CSubProblem*</type>
		    <parameter>subproblem</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><classname><xref linkend="Class-Element"/></classname>*</type>
		    <parameter>element</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>     <!-- post_process -->

	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>bool</type>
	      <methodname><link linkend="Class-Property-is_symmetric">is_symmetric_K</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>CSubProblem*</type>
		    <parameter>subproblem</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>         <!-- is_symmetric_K -->
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>bool</type>
	      <methodname><link linkend="Class-Property-is_symmetric">is_symmetric_C</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>CSubProblem*</type>
		    <parameter>subproblem</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>         <!-- is_symmetric_C -->
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>bool</type>
	      <methodname><link linkend="Class-Property-is_symmetric">is_symmetric_M</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>CSubProblem*</type>
		    <parameter>subproblem</parameter>
	      </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>         <!-- is_symmetric_M -->

	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link linkend="Class-Property-output">output</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FEMesh*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><classname><xref linkend="Class-Element"/></classname>*</type>
		    <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-PropertyOutput"/>*</type>
		    <parameter>p_output</parameter>
	      </methodparam> 
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-MasterPosition"/>&amp;</type>
		    <parameter>position</parameter>
	      </methodparam>
	      <methodparam>
		    <type><xref linkend="Class-OutputVal"/>*</type>
		    <parameter>value</parameter>
	      </methodparam>
	    </methodsynopsis><!-- output -->
        
	  </classsynopsis>            <!-- C++ Synopsis-->

      <para>
        In addition, the following non-virtual utility functions are
        available:
      </para>
      <programlisting>
  void <link linkend="Class-Property-set_mesh_data">set_mesh_data</link>(const FEMesh* mesh,
                     void* data) const;
  void* <link linkend="Class-Property-get_mesh_data">get_mesh_data</link>(const FEMesh* mesh); </programlisting>

      <refsect3 id="Class-Property-subclasses">
        <title>C++ Derived Classes</title>
        <itemizedlist spacing="compact">
          <listitem>
            <para>
              <classname><xref
              linkend="Class-PhysicalProperty"/></classname>
              <itemizedlist spacing="compact">
                <listitem>
                  <simpara>
                    <classname><xref linkend="Class-FluxProperty"/></classname>
                  </simpara>
                </listitem>
                <listitem>
                  <simpara>
                    <classname><xref linkend="Class-EqnProperty"/></classname>
                  </simpara>
                </listitem>
              </itemizedlist>
            </para>
          </listitem>
          <listitem>
            <simpara>
              <classname><xref linkend="Class-AuxProperty"/></classname>
            </simpara>
          </listitem>
        </itemizedlist>
      </refsect3>                 <!-- Derived classes -->

      <refsect3>
        <title>C++ Source Files</title>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>
              <filename>SRC/engine/property.C</filename>: C++ code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/property.h</filename>: C++ header
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/property.swg</filename>: SWIG source
              code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/property.spy</filename>: Python code
              included in the SWIG output
            </simpara>
          </listitem>
        </itemizedlist>
      </refsect3>                 <!-- C++ Source files -->
    </refsect2>                   <!-- C++ Property Synopsis -->

    <refsect2 id="Class-PyPropertyMethods">
      <title>Python Synopsis</title>
      <para>
        New <classname>Property</classname> subclasses written in
        Python should be derived from <xref
        linkend="Class-PyFluxProperty"/>, <xref
        linkend="Class-PyEqnProperty"/>, or <xref
        linkend="Class-PyAuxProperty"/>.  <xref
        linkend="Class-PyFluxProperty"/> and <xref
        linkend="Class-PyEqnProperty"/> share a C++ base class,
        <classname>PyPropertyMethods</classname>, that contains the
        Python C API calls for the methods in
        <classname>Property</classname>.  This synopsis lists the
        methods that may be redefined in a Python derived class when
        creating a new &property;.<footnote><simpara>The methods are
        listed here as if they belong to a Python class called
        <classname>PyPropertyMethods</classname>.  Don't be deceived.
        There is no Python version of this class.  This listing just
        shows the Python form of the C++ methods that can be
        overridden by defining methods in a Python
        subclass.</simpara></footnote>
      </para>
      <programlisting class="monospaced">
from ooflib.SWIG.engine import pypropertywrapper </programlisting>
      <classsynopsis language="python">
        <ooclass>
          <classname>PyPropertyMethods</classname>
        </ooclass>
        <methodsynopsis>
          <methodname><link linkend="Class-Property-cross_reference">cross_reference</link></methodname>
          <methodparam><parameter>material</parameter></methodparam>
        </methodsynopsis>
        <methodsynopsis>
          <methodname><link
                          linkend="Class-Property-constant_in_space">constant_in_space</link></methodname>
          <void/>
        </methodsynopsis>
        <methodsynopsis>
          <methodname><link
                          linkend="Class-Property-precompute">precompute</link></methodname>
          <void/>
        </methodsynopsis>
        <methodsynopsis>
          <methodname><link
                          linkend="Class-Property-clear_mesh_data">clear_mesh_data</link></methodname>
          <methodparam><parameter>mesh</parameter></methodparam>
        </methodsynopsis>
        <methodsynopsis>
          <methodname><link
                          linkend="Class-Property-begin_element">begin_element</link></methodname>
          <methodparam>
            <parameter>subproblem</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
        </methodsynopsis>
        <methodsynopsis>
          <methodname><link
                          linkend="Class-Property-end_element">end_element</link></methodname>
          <methodparam>
            <parameter>subproblem</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
        </methodsynopsis>
        <methodsynopsis>
          <methodname><link
                          linkend="Class-Property-postprocess">post_process</link></methodname>
          <methodparam>
            <parameter>subproblem</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
        </methodsynopsis>

        <methodsynopsis>
          <type>bool</type>
          <methodname><link
                          linkend="Class-Property-is_symmetric">is_symmetric_K</link></methodname>
          <methodparam>
            <parameter>subproblem</parameter>
          </methodparam>
        </methodsynopsis>
        <methodsynopsis>
          <type>bool</type>
          <methodname><link
                          linkend="Class-Property-is_symmetric">is_symmetric_C</link></methodname>
          <methodparam>
            <parameter>subproblem</parameter>
          </methodparam>
        </methodsynopsis>
        <methodsynopsis>
          <type>bool</type>
          <methodname><link
                          linkend="Class-Property-is_symmetric">is_symmetric_M</link></methodname>
          <methodparam>
            <parameter>subproblem</parameter>
          </methodparam>
        </methodsynopsis>

        <methodsynopsis>
          <type>OutputVal</type>
          <methodname><link
                          linkend="Class-Property-output">output</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>p_output</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
        </methodsynopsis>
      </classsynopsis>          <!-- Python Property synopsis-->

      <para>
        In addition, the following utility functions are available:
      </para>
      <programlisting>
def <link linkend="Class-Property-set_mesh_data">set_mesh_data</link>(mesh, data)
def <link linkend="Class-Property-get_mesh_data">get_mesh_data</link>(mesh) </programlisting>

      <refsect3>
        <title>Python Derived Classes</title>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>
              <classname><xref linkend="Class-PyFluxProperty"/></classname>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <classname><xref linkend="Class-PyEqnProperty"/></classname>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <classname><xref linkend="Class-PyAuxProperty"/></classname>
            </simpara>
          </listitem>
        </itemizedlist>
      </refsect3>                 <!-- Derived classes -->
      
      <refsect3>
        <title>Source Files</title>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.C</filename>: C++
              code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.h</filename>: C++
              header
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.swg</filename>:
              SWIG wrapper code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.spy</filename>:
              Python code included in the SWIG output
            </simpara>
          </listitem>
        </itemizedlist>
      </refsect3>               <!-- Python source files -->
    </refsect2>                 <!-- Python Synopsis-->
  </refsynopsisdiv>             <!-- Property Synopsis -->

  <refsection>
    <title>Overview</title>
    <para>
	  &Property; classes can be constructed either in C++ or Python.
	  Python classes are somewhat simpler to program and build, but
	  C++ classes are significantly more computationally efficient.
    </para>
    <para>
      In C++, new <classname>Property</classname> classes should be
      derived from one of three C++ subclasses:
      <itemizedlist>
        <listitem>
          <simpara>
            <classname><xref
            linkend="Class-FluxProperty"/></classname> for classes that
            contribute directly to a &Flux; computation, such as an elastic
            modulus.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <classname><xref linkend="Class-EqnProperty"/></classname>
            for classes that make a direct contribution to an
            &Equation;, such as an applied force.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <classname><xref linkend="Class-AuxProperty"/></classname>
            for classes that do neither.
          </simpara>
        </listitem>
      </itemizedlist>
      These base classes contain trivial implementations of almost all
      methods, so that in the derived classes it is safe to omit any
      functions which are irrelevant to a particular physical
      property.  The exception is
      <function>integration_order()</function>, which must be provided
      in all <classname><xref
      linkend="Class-FluxProperty"/></classname> and <classname><xref
      linkend="Class-EqnProperty"/></classname> subclasses.
    </para>
    <para>
      In Python, new <classname>Property</classname> classes should be
      derived from one of
      <itemizedlist spacing="compact">
        <listitem>
          <simpara>
            <classname><xref linkend="Class-PyFluxProperty"/></classname>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <classname><xref
            linkend="Class-PyEqnProperty"/></classname>, or
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <classname><xref
            linkend="Class-PyAuxProperty"/></classname>.
          </simpara>
        </listitem>
      </itemizedlist>
      These Python classes are derived via SWIG from C++ classes with
      the same names.  The C++ classes store a pointer to a Python
      <classname>Property</classname> object, and use the Python C API
      to call that object's Python methods (the ones defined in the
      extension class).  A Python subclass does not need to define all
      of the virtual functions.  If a Python method doesn't exist, the
      default C++ method will be called.<footnote>
      <para>
        The Python classes <classname><xref
        linkend="Class-PyFluxProperty"/></classname>, <classname><xref
        linkend="Class-PyEqnProperty"/></classname> and
        <classname><xref linkend="Class-PyAuxProperty"/></classname>
        are also derived from the C++ classes <classname><xref
        linkend="Class-FluxProperty"/></classname>, <classname><xref
        linkend="Class-EqnProperty"/></classname> and <classname><xref
        linkend="Class-AuxProperty"/></classname> via SWIG, but they
        do not actually give access to any of the C++ class's methods
        other than the constructors and destructors.  All calls to
        Python <classname>Property</classname> methods are done via
        Python API calls in
        <filename>SRC/engine/pypropertywrapper.C</filename>.
        </para></footnote>
    </para>
    <para>
      It is possible to mix C++ and Python
      <classname>Properties</classname> in the same <link
      linkend="Class-Material"><classname>Material</classname></link>,
      most of the time. Difficulties arise when one
      <classname>Property</classname> needs to call methods or fetch
      data from another one.  <classname>Properties</classname> can
      locate other <classname>Properties</classname> by calling <link
      linkend="Class-Material-fetchProperty"><methodname>Material::fetchProperty()</methodname></link>
      in their <link
      linkend="Class-Property-cross_reference"><methodname>cross_reference</methodname></link>
      methods, but in C++ <methodname>fetchProperty()</methodname>
      will return a generic <code>Property*</code> pointer which
      cannot provide access to the methods of a Python
      <classname>Property</classname>, except for methods defined in
      the base classes.  On the other hand, in Python
      <methodname>fetchProperty()</methodname> returns a derived class
      object (even an object defined in C++, as long as it is swigged)
      so a Python <classname>Property</classname> can access all of
      the swigged methods of C++ <classname>Property</classname>.
    </para>
    <para>
      This page only discusses those base class functions that are
      used when deriving new subclasses.  See <classname><xref
      linkend="Class-PhysicalProperty"/></classname>, <classname><xref
      linkend="Class-FluxProperty"/></classname> and <classname><xref
      linkend="Class-EqnProperty"/></classname> for additional methods
      that can be redefined.
    </para>
    <para>
	  In order for C++ and Python <classname>Properties</classname> to
	  work properly and to appear in the GUI, every subclass must have
	  an associated <link
	  linkend="Class-PropertyRegistration"><classname>PropertyRegistration</classname></link>
	  object.  <link
	  linkend="Class-PropertyRegistration"><classname>PropertyRegistrations</classname></link>
	  must always be created in Python, even for
	  <classname>Property</classname> subclasses created in C++.
    </para>
  </refsection>                 <!-- Overview -->

  <refsection id="Class-Property-Constructors">
    <title>Constructors</title>
      
    <refsection id="Class-Property-Cconstructor">
	  <title>C++</title>
	  <para>
	    All non-abstract C++ <classname>Property</classname>
	    subclasses must have a constructor of the form

	  <literallayout class="monospaced">
SubProperty::SubProperty(const std::string&amp; name, PyObject *registration, ...) </literallayout>

        and they must invoke the base class constructor like this:

	    <literallayout class="monospaced">
FluxProperty(const std::string&amp; name, PyObject *registration) <lineannotation>// or EqnProperty or AuxiliaryProperty</lineannotation></literallayout>

	    The derived class should treat <varname>name</varname> and
	    <varname>registration</varname> as opaque variables, used only
	    by the base class.  They just need to be passed on through.
	    The <varname>...</varname> in the subclass constructor refers
	    to the <classname>Property</classname>'s <link linkend="Class-Parameter">parameters</link>, which
	    <emphasis>must</emphasis> appear in the constructor argument
	    list in the same order that they appear in the corresponding
	    <link
	    linkend="Class-PropertyRegistration"><classname>PropertyRegistration</classname></link>.
	  </para>
	  <para>
	    C++ <classname>Property</classname> classes should
	    <emphasis>not</emphasis> have a copy constructor.  The base
	    class copy constructor is private, to prohibit unauthorized
	    duplication, by any means, electronic or otherwise.
	  </para>
    </refsection><!-- C++ constructor -->
    <refsection id="Class-Property-pyconstructor">
	  <title>Python</title>
	  <para>
	    The Python constructor for a <classname><xref
	    linkend="Class-PyFluxProperty"/></classname>,
	    <classname><xref linkend="Class-PyEqnProperty"/></classname>,
        or <classname><xref linkend="Class-PyAuxProperty"/></classname>
	    subclass must look like this:

  	    <programlisting>
def __init__(self, name, registration, ...):
    PyFluxProperty.__init__(self, name, registration) <lineannotation># or PyEqnProperty or PyAuxProperty</lineannotation> </programlisting>

	    As in the <link linkend="Class-Property-Cconstructor">C++
	    constructor</link>, the <varname>name</varname> and
	    <varname>registration</varname> parameters should be passed
	    through to the base class unchanged.
	  </para>
	  <para>
	    The <varname>...</varname> in the constructor arguments refers
	    to any parameters that the <classname>Property</classname>
	    might have.  These must have the same names and be in the same
	    order as the parameters in the associated <link
	    linkend="Class-PropertyRegistration"><classname>PropertyRegistration</classname></link>.
        If the <classname>Property</classname> has no parameters, the
        derived class constructor does not need to be defined.
	  </para>
    </refsection>               <!-- Python constructor -->
  </refsection>                 <!-- constructors -->
  <refsection>
    <title>Virtual Methods</title>
    <para>
	  The following methods can be redefined in new C++ and Python
	  <classname>Properties</classname>.  Most are optional, and can
	  be omitted if the default behavior is satisfactory.  Unless
	  otherwise noted, the default behavior is to do
	  nothing. Additional methods are documented in the descriptions
	  of the subclasses.
    </para>
    <para>
	  All of the functions can be accessed from either C++ or Python.
	  If there are non-obvious differences between the C++ and Python
	  invocations, they are noted below.  Minor and standard
	  punctuation differences are <emphasis>not</emphasis> noted.
	  Function prototypes are specified in the C++ format, because it
	  is more informative.
    </para>
    <refsection id="Class-Property-cross_reference">
	  <title><code>void cross_reference(Material* material)</code></title>
	  <para>
	    <methodname>cross_reference</methodname> is called whenever a
	    new &property; is added to a &material;.  It gives each
	    &property; a chance to locate other &properties; in the same
	    &material; from which it may need information.  For example,
	    many &properties; of an anisotropic material will need to know
	    the &material;'s <link
	    linkend="MenuItem-OOF.Property.Parametrize.Orientation"><classname>Orientation</classname></link>
	    &property;.  The argument to
	    <methodname>cross_reference</methodname> is the <link
	    linkend="Class-Material"><classname>Material</classname></link>
	    object to which the <classname>Property</classname> belongs.
	  </para>
	  <para>
	    <link
	    linkend="Class-Material-fetchProperty"><code>Material::fetchProperty</code></link>
	    should be used to look for other
	    <classname>Properties</classname>.  It will raise an exception
	    if the sought-for <classname>Property</classname> does not
	    exist.  This exception should <emphasis>not</emphasis> be
	    caught by the <classname>Property</classname> &mdash; it's
	    handled in the <classname>Material</classname>.
	  </para>
	  <para>
	    For example, an
        <link
            linkend="Property-Couplings-ThermalExpansion-Anisotropic-Cubic">
        anisotropic thermal expansion</link>
        <classname>Property</classname> needs to access its
        <classname><link
        linkend="Class-Material">Material</link></classname>'s
        <literal>Elasticity</literal> and
        <literal>Orientation</literal>.  It stores pointers to them in
        the class:
	    <programlisting>
class ThermalExpansion : public Property {
protected:
  Elasticity *elasticity;
  ...
};

class AnisotropicThermalExpansion : public ThermalExpansion {
private:
  OrientationProp *orientation;
  ...
};    </programlisting>

        and obtains their values by defining
        <methodname>cross_reference()</methodname> like this:
      
	  <programlisting>
void AnisotropicThermalExpansion::cross_reference(Material *mat) {
  elasticity = dynamic_cast&lt;Elasticity*>(mat->fetchProperty("Elasticity"));
  orientation = dynamic_cast&lt;OrientationProp*>(mat->fetchProperty("Orientation"));
} </programlisting>
      </para>
      <para>
        In Python, it would look like this:
        <programlisting>
from ooflib.SWIG.engine import pypropertywrapper

class ThermalExpansion(pypropertywrapper.PyFluxProperty):
    def cross_reference(self, material):
        self.elasticity = material.fetchProperty("Elasticity")

class AnisotropicThermalExpansion(ThermalExpansion):
    def cross_reference(self, material):
        self.orientation = material.fetchProperty("Orientation") </programlisting>
      </para>
    </refsection>               <!-- cross_reference -->

    <refsection id="Class-Property-constant_in_space">
      <title><code>bool constant_in_space() const</code></title>
      <para>
        <function>constant_in_space()</function> should return
        <literal>false</literal> if the <classname>Property</classname>
        explicitly depends on position.  The default implementation
        returns <literal>true</literal>.
      </para>
      <para>
        <function>constant_in_space()</function> can be used by other
        <classname>Properties</classname> to decide whether or not
        it's possible for them to precompute something.  For example,
        an anisotropic elasticity <classname>Property</classname> can
        precompute its rotated stiffness modulus only if its
        orientation has no spatial variation.
      </para>
    </refsection>               <!-- constant_in_space -->

    <refsection id="Class-Property-precompute">
	  <title><code>void precompute(FEMesh* mesh)</code></title>
	  <para>
	    <function>precompute()</function> is called when a &mesh; is
	    being solved.  It's called before any other
	    <classname>Property</classname> methods, other than
	    <function>cross_reference()</function>.  It should compute any
	    quantities that the <classname>Property</classname> needs that
	    depend only upon <classname>Property</classname> data. It can
	    use <classname>Property</classname> data from other
	    <classname>Properties</classname>, having located those other
	    <classname>Properties</classname> during the
	    <function>cross_reference()</function> step, but it should not
	    assume that <function>precompute()</function> has been called
	    for those <classname>Properties</classname> yet.
	  </para>
	  <para>
	    For example, if a <classname>Property</classname> has an
	    anisotropic modulus, the <classname>Property</classname>'s
	    <methodname>precompute()</methodname> method should rotate the
	    modulus to lab coordinates using the &material;'s <link
	    linkend="MenuItem-OOF.Property.Parametrize.Orientation"><classname>Orientation</classname></link>
        (but only if the <classname>Orientation</classname> is <link
        linkend="Class-Property-constant_in_space">constant in space</link>.
	  </para>
    </refsection>                 <!-- precompute -->
 
    <refsection id="Class-Property-clear_mesh_data">
      <title><code>void clear_mesh_data(FEMesh* mesh, void* data) const</code></title>
      <para>
        <methodname>clear_mesh_data()</methodname> is called when data
        stored by <link
        linkend="Class-Property-set_mesh_data"><methodname>set_mesh_data()</methodname></link>
        is about to be overwritten, or if the <link
        linkend="Class-FEMesh"><classname>FEMesh</classname></link> is
        about to be deleted.  In the example given in <link
        linkend="Class-Property-set_mesh_data"><methodname>set_mesh_data()</methodname></link>
        above, <methodname>clear_mesh_data()</methodname> would simply
        delete the allocated pointer:
        <programlisting>
void MyProperty::clear_mesh_data(FEMesh* mesh, void* data) const {
    delete static_cast&lt;MyMeshData*&gt;(data);
} </programlisting>
      </para>
    </refsection>
    
    <refsection id="Class-Property-begin_element">
	  <title><code>void begin_element(const CSubProblem*, const Element*)</code></title>
	  <para>
	    When building the finite element stiffness matrix
        and other numerical components,
        &oof2; loops over the elements of the mesh
	    and computes each element's contribution by calling its
        <classname>Properties</classname>' computational methods, <foreignphrase>e.g,</foreignphrase> <link
	    linkend="Class-FluxProperty-flux_matrix"><methodname>FluxProperty::flux_matrix()</methodname></link>,
        or 
        <link linkend="Class-EqnProperty-force_value"><methodname>EqnProperty::force_value()</methodname></link>.
        Before calling these functions, however, it first
	    calls <methodname>begin_element()</methodname>, passing the
	    current <link
	    linkend="Class-Element"><classname>Element</classname></link>
	    as an argument.  This allows the
	    <classname>Property</classname> to precompute any
	    <classname>Element</classname> dependent properties.
	  </para>
      <para>
        The base class implementation of
        <function>begin_element()</function> does nothing.
      </para>
    </refsection>               <!-- begin_element -->
    
    <refsection id="Class-Property-end_element">
	  <title><code>void end_element(const CSubProblem*, const Element*)</code></title>
	  <para>
	    <methodname>end_element</methodname> is just like
	    <methodname><link
	    linkend="Class-Property-begin_element">begin_element</link></methodname>,
	    except that it's called <emphasis>after</emphasis> &oof2; is
	    done computing an <link
	    linkend="Class-Element"><classname>Element</classname></link>'s
	    contribution.  <methodname>end_element()</methodname> can be
	    used to clean up any temporary objects allocated by
	    <methodname><link
	    linkend="Class-Property-begin_element">begin_element()</link></methodname>.
	  </para>
      <para>
        The base class implementation of
        <methodname>end_element()</methodname> does nothing.
      </para>
    </refsection>                 <!-- end_element -->

    <refsection id="Class-Property-post_process">
	  <title><code>void post_process(CSubProblem*, const Element*) const</code></title>
	  <para>
	    After solving the finite element equations,
	    <methodname>post_process</methodname> is called once on each
	    <classname><link
	    linkend="Class-Element">Element</link></classname> in a <link
	    linkend="Class-CSubProblem"><classname>CSubProblem</classname></link>.
	    It can be used for any sort of post-processing, such as
	    adjusting material parameters, or generating output files.
	  </para>
	  <para>
	    Do not confuse <methodname>post_process()</methodname> with
	    <link
	    linkend="Class-Property-end_element"><methodname>end_element()</methodname></link>.
	    <methodname>end_element</methodname> is called during finite
	    element matrix construction, before the equations are solved.
	  </para>
    </refsection>                 <!-- post_process -->

    <refsection id="Class-Property-is_symmetric">
	  <title><code>bool is_symmetric_[KCM](const CSubProblem* mesh) const</code></title>
	  <para>
	    <methodname>is_symmetric_X</methodname> indicates whether or
	    not the finite element matrix constructed from the
	    <classname>Property</classname> can be made symmetric by using
	    the <link
	    linkend="Section-Coding-Conjugates">relationships</link>
	    established by <link
	    linkend="Function-conjugatePair"><function>ConjugatePair</function></link>
	    calls.  There are three functions:
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>
              <methodname>is_symmetric_K()</methodname> for the
              stiffness matrix (coefficient of the &flux; gradient),
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <methodname>is_symmetric_C()</methodname> for the damping
              matrix (coefficient of the first time derivative), and
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <methodname>is_symmetric_M()</methodname> for the mass
              matrix (coefficient of the second time derivative).
            </simpara>
          </listitem>
        </itemizedlist>
	  </para>
	  <para>
	    In most cases <function>is_symmetric</function> will simply
	    return <literal>true</literal>, if the matrix can be
	    symmetrized, or <literal>false</literal>, if it can't.  Some
	    cases are more complicated, however.  For example,
        <link linkend="Property-Couplings-ThermalExpansion-Isotropic">
        thermal expansion</link> makes the matrix asymmetric if the
        temperature field is an active field, because the
        <classname>Property</classname> couples the
        temperature (with no derivatives) to the
        <emphasis>gradient</emphasis> of the displacement.  Therefore,
        in the <classname>ThermalExpansion</classname> class,
        <methodname>is_symmetric_K</methodname> is defined like this:
	    <programlisting>
bool ThermalExpansion::is_symmetric_K(const CSubProblem* subproblem) const {
  Equation *forcebalance = Equation::getEquation("Force_Balance");
  return !(forcebalance->is_active(subproblem) &amp;&amp;
	   temperature->is_defined(subproblem) &amp;&amp;
	   temperature->is_active(subproblem));
} </programlisting>
	  </para>
      <para>
        The base class implementations of all three of these functions
        return <constant>true</constant>.
      </para>
    </refsection>               <!-- is_symmetric -->
    
    <refsection id="Class-Property-output">
	  <title><code>void output(FEMesh* mesh, const Element* element,
      const PropertyOutput* output, const MasterPosition&amp; pos,
      OutputVal *data)</code></title>
	  <para>
	    A <classname>Property</classname>'s
	    <methodname>output</methodname> function is called when
	    quantities that depend on the <classname>Property</classname>
	    are being computed, usually (but not necessarily) after a
	    solution has been obtained on a mesh.  Many different kinds of
	    <classname>PropertyOutputs</classname> can be defined (see
	    <xref linkend="Section-Coding-Output"/>).  Each
	    <classname>Property</classname> class's <link
	    linkend="Class-PropertyRegistration"><classname>PropertyRegistration</classname></link>
	    indicates which kinds of <classname>PropertyOutput</classname>
	    the <classname>Property</classname> can compute.  The
	    <methodname>output</methodname> function must determine which
	    <classname>PropertyOutput</classname> is being computed, get
	    the output's parameter values if necessary, compute its value
	    at a given point in the mesh, and store the value in the given
	    <link
	    linkend="Class-OutputVal"><classname>OutputVal</classname></link>
	    object.
	  </para>
	  <para>
	    The arguments to <methodname>Property::output</methodname>
	    in C++ are:
	    <variablelist>
	      <varlistentry>
	        <term><code>const <link linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
	        <listitem>
		      <para>
		        The mesh on which the output is being computed. The
		        <methodname>output</methodname> function will probably
		        not need to use this variable directly, but must pass
		        it through to other functions.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code>const <link
		    linkend="Class-Element">Element</link>* element</code></term>
	        <listitem>
		      <para>
		        The element of the mesh containing the point at which
		        output values are desired.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code>const <link
		    linkend="Class-PropertyOutput">PropertyOutput</link>* output</code></term>
	        <listitem>
		      <para>
		        The <classname>PropertyOutput</classname> object being
		        computed.  The object is created by the &oof2; menu
		        system and, depending on the type of output, may
		        contain Python arguments specifying exactly what's to
		        be computed.  For example, a strain output will
		        specify whether it's computing the total, elastic,
		        thermal or other variety of strain. See the example
		        <link
		        linkend="Class-Property-output-example">below</link>.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code>const <link linkend="Class-MasterCoord">MasterPosition</link>&amp; pos</code></term>
	        <listitem>
		      <para>
		        The position in the element's <link
		        linkend="Class-MasterCoord">master coordinate
		        space</link> at which the output is to be computed.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code><link
	        linkend="Class-OutputVal">OutputVal</link>*
	        data</code></term>
	        <listitem>
		      <para>
		        The object in which the computed data should be
		        stored.  In C++, the object must be first cast to an
		        appropriate derived type.  The new value should be
		        <emphasis>added</emphasis> to <varname>data</varname>,
		        to ensure that values computed by other
		        <classname>Properties</classname> are retained.
		      </para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </para>
	  <para>
	    In Python, the arguments are the same, except that there's no
	    <varname>data</varname> argument.  Instead, the function
	    <emphasis>returns</emphasis> an <link
	    linkend="Class-OutputVal"><classname>OutputVal</classname></link>
	    (of the appropriate type) containing the
	    <classname>Property</classname>'s contribution to the output
	    quantity.
	  </para>
	  <para>
        <anchor id="Class-Property-output-example"/>
	    Here is an example of a fairly complicated
	    <methodname>output</methodname> function, from
	    <filename>SRC/engine/properties/thermalexpansion/thermalexpansion.C</filename>
	    in the &oof2; source code.  It computes one of two types of
	    output, <literal>Strain</literal> and
	    <literal>Energy</literal>, each of which has two variants.  It
	    can also return the material parameters.
	  </para>
	  <programlisting>
void ThermalExpansion::output(FEMesh *mesh,
                              const Element *element,
                              const PropertyOutput *output,
                              const MasterPosition &amp;pos,
                              OutputVal *data)
  const 
{
  const std::string &amp;outputname = output->name(); <co id="output-name"/>
  if(outputname == "Strain") {
    <lineannotation>// The parameter is a Python StrainType instance.  Extract its name.</lineannotation>
    std::string stype = output->getRegisteredParamName("type"); <co id="output-paramname"/>
    SymmMatrix3 *sdata = dynamic_cast&lt;SymmMatrix3*>(data); <co id="output-cast"/>
    <lineannotation>// Compute Temperature at position pos.</lineannotation>
    double t = temperature->value(mesh, element, pos);  <co id="output-T"/>

    <lineannotation>// Compute alpha*T and add it to the output.</lineannotation>
    if(stype == "Thermal") <co id="output-stype"/>
      *sdata += expansiontensor(mesh, element, pos)*(t-T0);  <co id="output-tzero"/>
    else if(stype == "Elastic")
      *sdata -= expansiontensor(mesh, element, pos)*(t-T0);
  } <lineannotation>// end outputname == "Strain"</lineannotation>

  if(outputname == "Energy") { <co id="output-energy-name"/>
    <lineannotation>// The parameter is a Python Enum instance.  Extract its name.</lineannotation>
    std::string etype = output->getEnumParam("etype"); <co id="output-paramenum"/>
    if(etype == "Total" || etype == "Elastic") { <co id="output-etype"/>
      ScalarOutputVal *edata = dynamic_cast&lt;ScalarOutputVal*>(data); <co id="output-edata"/>
      SymmMatrix3 thermalstrain;
      const Cijkl modulus = elasticity->cijkl(mesh, element, pos); <co id="output-modulus"/>
      double t = temperature->value(mesh, element, pos);
      thermalstrain = expansiontensor(mesh, element, pos)*(t-T0);
      SymmMatrix3 thermalstress(modulus*thermalstrain);
      SymmMatrix3 strain;
      findGeometricStrain(mesh, element, pos, strain); <co id="output-geomstrain"/>
      double e = 0;
      for(SpaceIndex i=0; i&lt;3; i++) { <co id="output-esum"/>
        e += thermalstress(i,i)*(-strain(i,i) + 0.5*thermalstrain(i,i));
        SpaceIndex j = (i+1)%3;
        e += 2*thermalstress(i,j)*(-strain(i,j) + 0.5*thermalstrain(i,j));
      }
      *edata += e;
    }
  } <lineannotation>// end outputname == "Energy"</lineannotation>

  if(outputname == "Material Constants:Couplings:Thermal Expansion T0") {  <co id="output-t0"/>
    ScalarOutputVal *sdata = dynamic_cast&lt;ScalarOutputVal*&gt;(data); <co id="output-t0-cast"/>
    *sdata = T0;
  }
} </programlisting>

      <calloutlist>
	    <callout arearefs="output-name output-energy-name">
	      <para>
	        The name of the output indicates what type of quantity is
	        to be computed.  A <classname>Property</classname> can
	        make contributions to more than one type of <xref
	        linkend="Class-PropertyOutput"/>, so it is important to
	        check the name. All of the names handled by this routine
	        must be listed in the <varname>name</varname> parameter of
	        this <classname>Property</classname>'s <xref
	        linkend="Class-PropertyOutputRegistration"/>.
	      </para>
	    </callout>
	    <callout arearefs="output-paramname">
	      <para>
            The <literal>Strain</literal> output has a parameter named
            <literal>type</literal>, and this call to
            <methodname>PropertyOutput::getRegisteredParamName()</methodname>
            retrieves its value.  Parameters for <link
            linkend="Class-PropertyOutput"><classname>PropertyOutputs</classname></link>
            are defined in their <link
            linkend="Class-PropertyOutputRegistration"><classname>PropertyOutputRegistrations</classname></link>.
            The <link
            linkend="Class-PropertyOutput"><classname>PropertyOutput</classname></link>
            class provides a number of functions for retrieving
            parameters of different kinds (integer, float, string,
            <foreignphrase>etc.</foreignphrase>).  In this case,
            <varname>type</varname> is a <link
            linkend="Class-RegisteredParameter"><classname>RegisteredParameter</classname></link>,
            so we use
            <methodname>getRegisteredParamName()</methodname>.
	      </para>
	    </callout>
	    <callout arearefs="output-cast">
	      <para>
	        Because we know that this is a <literal>Strain</literal>
	        output whose value is a 3&times;3 symmetric matrix, we can
	        cast the <varname>data</varname> pointer from its base
	        class, <link
	        linkend="Class-OutputVal"><classname>OutputVal</classname></link>,
	        to its derived class, <link
	        linkend="Class-SymmMatrix3"><classname>SymmMatrix3</classname></link>.
	      </para>
	    </callout>
	    <callout arearefs="output-T">
	      <para>
	        <classname>ThermalExpansion</classname>'s contribution to
	        the strain depends on the value of the Temperature
	        &field;.  This line uses <link
	        linkend="Class-Field-value"><code>Field::value()</code></link>
	        to get the Temperature's value at the given point the
	        <varname>mesh</varname>. The variable
	        <varname>temperature</varname> was set by the
	        <classname>ThermalExpansion</classname> constructor, like
	        this:

	        <programlisting>
temperature = dynamic_cast&lt;ScalarField*>(Field::getField("Temperature")); </programlisting>
	      </para>
	    </callout>
	    <callout arearefs="output-stype">
	      <para>
	        These lines make the thermal expansion contribution to the
	        strain, with the appropriate sign (depending on the type
	        of strain being computed).
          </para>
        </callout>
        <callout arearefs="output-tzero">
          <para>
            <varname>T0</varname> is a floating point number stored in
            the <classname>ThermalExpansion</classname> class.  It is
            set by the <classname>ThermalExpansion</classname>
            constructor.  The constructor is called with a
            <varname>T0</varname> argument because its <xref
            linkend="Class-PropertyRegistration"/> includes it in its
            list of parameters:
            <programlisting>
PropertyRegistration(
  name="Couplings:ThermalExpansion:Isotropic",
  params = [
       <emphasis role="bold">parameter.FloatParameter("T0", 0.0, tip="Reference temperature")</emphasis>,
       parameter.FloatParameter("alpha", 1.0, tip="Expansion coefficient")],
  ...) </programlisting>
          </para>
          <para>
	        <varname>expansiontensor()</varname> is a virtual function
	        in the <classname>ThermalExpansion</classname> class that
	        returns a <link
	        linkend="Class-SymmMatrix3"><classname>SymmMatrix3</classname></link>
	        object.  The various isotropic and anistropic
	        <classname>ThermalExpansion</classname> subclasses compute
	        the matrix from their parameters.  For example, the above
	        <xref linkend="Class-PropertyRegistration"/> for isotropic
	        thermal expansion includes a scalar
	        <varname>alpha</varname> parameter, but the registrations
	        for anisotopic properties have tensor parameters.
          </para>
          <para>
	        <varname>*sdata</varname> is the <xref
	        linkend="Class-OutputVal"/> object, cast into a
	        <classname>SymmMatrix3</classname>.  The expansion tensor
	        times temperature is also a
	        <classname>SymmMatrix3</classname> and can be added
	        directly to <varname>*sdata</varname>.
	      </para>
        </callout>
	    <callout arearefs="output-paramenum">
	      <para>
	        The <varname>etype</varname> parameter for the
	        <literal>Energy</literal> <link
	        linkend="Class-PropertyOutput"><classname>PropertyOutput</classname></link>
	        is an <link
	        linkend="Class-EnumParameter"><classname>EnumParameter</classname></link>
	        instance, representing the <link
	        linkend="Enum-EnergyType"><classname>EnergyType</classname></link>
	        &oof2; <link
	        linkend="Section-Enums"><classname>Enum</classname></link>.
	        The function <link
	        linkend="Class-PropertyOutput-getEnumParam"><methodname>PropertyOutput::getEnumParam</methodname></link>
	        retrieves the value of the parameter, and returns its
	        name.
	      </para>
	    </callout>
	    <callout arearefs="output-etype">
	      <para>
	        There are many different types of
	        <literal>Energy</literal> output, but this
	        <classname>Property</classname> only contributes to these
	        two.
	      </para>
	    </callout>
	    <callout arearefs="output-edata">
	      <para>
	        Energy is a scalar, so the
	        <classname>OutputVal</classname> that was passed in is
	        really a <link
	        linkend="Class-ScalarOutputVal"><classname>ScalarOutputVal</classname></link>.
	        It must be cast to the derived class in order to be used.
	      </para>
	    </callout>
	    <callout arearefs="output-modulus">
	      <para>
	        This retrieves the elastic modulus
	        <varname>Cijkl</varname> from the
	        <classname>Material</classname>'s
	        <classname>Elasticity</classname> property.  The variable
	        <varname>elasticity</varname> is a data member of the
	        <classname>ThermalExpansion</classname> class. It was set
	        by this <classname>Property</classname>'s
	        <methodname>cross_reference()</methodname> function, like
	        this:
	      <programlisting>
void ThermalExpansion::cross_reference(Material *mat) {
  elasticity = dynamic_cast&lt;Elasticity*>(mat->fetchProperty("Elasticity"));
} </programlisting>
	      </para>
	    </callout>
	    <callout arearefs="output-geomstrain">
	      <para>
	        <function>findGeometricStrain</function> is defined in
	        <filename>SRC/engine/cstrain.C</filename> and declared in
	        <filename>SRC/engine/cstrain.h</filename>.  It computes
            <!-- TODO: Use latex -->
          <emphasis>
            &epsi;<subscript>ij</subscript> =
            (&part;u<subscript>i</subscript>/&part;x<subscript>j</subscript>
            +
            &part;u<subscript>j</subscript>/&part;x<subscript>i</subscript>)
          </emphasis>
	      where
          <emphasis>u</emphasis>
	      is the displacement field.
	      </para>
	    </callout>
	    <callout arearefs="output-esum">
	      <para>
	        This loop computes the contribution of thermal expansion
	        to the elastic energy.  <link
	        linkend="Class-SpaceIndex"><classname>SpaceIndex</classname></link>
	        is a glorified integer that can represent a dimension of
	        space.
	      </para>
	    </callout>
        <callout arearefs="output-t0">
          <para>
            Material parameters can be output too.  Only
            <varname>T0</varname> is handled here in the base
            class. The thermal expansion modulus is handled in the
            derived isotropic and anistropic classes.
          </para>
        </callout>
        <callout arearefs="output-t0-cast">
          <para>
            <varname>T0</varname> is a scalar, so
            <varname>data</varname> needs to be cast to a
            <classname><xref
            linkend="Class-ScalarOutputVal"/></classname> pointer.
          </para>
        </callout>
	  </calloutlist>
      <para>
        As an example in Python, here is
        <methodname>output</methodname> from
        <filename>SRC/engine/properties/elasticity/pyelasticity.py</filename>,
        which defines an elasticity <classname>Property</classname> in
        Python (for illustrative purposes only):
        <programlisting>
def output(self, mesh, element, output, pos):
    if output.name() == "Energy":
        etype = output.getEnumParam("etype")
        if etype in ("Total", "Elastic"):
            mod = self.modulus()
            # strain is a SymmMatrix3.  modulus is a cijkl.Cijkl
            strain = cstrain.getGeometricStrain(mesh, element, pos, False)
            stress = mod*strain # another SymmMatrix3.
            <emphasis role="bold">return outputval.ScalarOutputVal(0.5*stress.contract(strain))</emphasis> </programlisting>

        Note that a new <xref linkend="Class-OutputVal"/> is created
        and returned, containing the <classname>Property</classname>'s
        contribution to the output quantity.  Because energy is a
        scalar, the <classname>OutputVal</classname> is a <xref
        linkend="Class-ScalarOutputVal"/>.
      </para>
    </refsection>                 <!-- output -->
  
  </refsection>                   <!-- Virtual Methods -->
  <refsection>
    <title>Non-virtual Methods</title>
    <para>
      The following <classname>Property</classname> base class methods
      are utilities that may be useful when writing new
      <classname>Property</classname> subclasses.
    </para>
    <refsection id="Class-Property-set_mesh_data">
      <title><code>void set_mesh_data(const FEMesh* mesh, void *data) const</code></title>
      <para>
        <methodname>set_mesh_data()</methodname> allows a
        <classname>Property</classname> to store arbitrary data in a
        <link
        linkend="Class-FEMesh"><classname>FEMesh</classname></link>.
        It is meant to be called from within <link
        linkend="Class-Property-precompute"><methodname>precompute()</methodname></link>
        to cache mesh-dependent data that will be needed later.
        Mesh-dependent data cannot be stored directly in a
        <classname>Property</classname> because
        <classname>Properties</classname> can be shared between
        <classname><xref linkend="Class-FEMesh"/>es</classname>.  The
        data will be accessible only to the &Property; that stored it.
      </para>
      <para>
        For example, a <classname>Property</classname> called
        <classname>MyProperty</classname> could store its data in a
        class called <classname>MyMeshData</classname> and cache it in
        the mesh like this:
        <programlisting>
void MyProperty::precompute(FEMesh *mesh) {
    MyMeshData* data = new MyMeshData(mesh);  <lineannotation>// some expensive computation is hidden here</lineannotation>
    <emphasis role="bold">set_mesh_data</emphasis>(mesh, data);
} </programlisting>
      </para>
      <para>
        The Python implementation of
        <methodname>set_mesh_data</methodname> is completely
        independent of the C++ implementation.  C++
        <classname>Properties</classname> store data in C++, and
        Python <classname>Properties</classname> store data in Python.
      </para>
      <para>
        Before data stored by <function>set_mesh_data</function> is
        overwritten or deleted, &oof2; will call <link
        linkend="Class-Property-clear_mesh_data"><function>clear_mesh_data</function></link>.
        A <classname>Property</classname> subclass should define
        <function>clear_mesh_data</function> if it needs to do any
        cleaning up before the data is deleted.
      </para>
    </refsection>               <!-- set_mesh_data -->

   <refsection id="Class-Property-get_mesh_data">
      <title><code>void* get_mesh_data(const FEMesh* mesh) const</code></title>
      <para>
        <methodname>get_mesh_data()</methodname> retrieves the data
        stored by <link
        linkend="Class-Property-set_mesh_data"><methodname>set_mesh_data()</methodname></link>.
        For example, if <classname>MyProperty</classname> in the
        example above is a <link
        linkend="Class-FluxProperty"><classname>FluxProperty</classname></link>,
        its <methodname>flux_matrix</methodname> method could retrieve
        the data like this:
        <programlisting>
void MyProperty::flux_matrix(const FEMesh* mesh, ...) const {
    MyMeshData* data = static_cast&lt;MyMeshData*&gt;(<emphasis role="bold">get_mesh_data</emphasis>(mesh));
    ...
} </programlisting>
      </para>
    </refsection>               <!-- get_mesh_data -->
    
  </refsection>
</refentry>    <!-- Property -->


<!-- Keep this comment at the end of the file
  Local variables:
  sgml-omittag:t
  sgml-shorttag:t 
  sgml-namecase-general:nil
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("../man_oof2.xml" "book" "chapter")
  sgml-exposed-tags:nil
  sgml-local-ecat-files:nil
  End:
-->
