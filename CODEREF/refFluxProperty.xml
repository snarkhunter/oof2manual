<!--
  This software was produced by NIST, an agency of the
  U.S. government, and by statute is not subject to copyright in the
  United States.  Recipients of this software assume all
  responsibilities associated with its operation, modification and
  maintenance. However, to facilitate maintenance we ask that before
  distributing modified versions of this software, you first contact
  the authors at oof_manager@nist.gov.
-->

<refentry id="Class-FluxProperty">
  <refnamediv>
    <refname>FluxProperty</refname>
    <refpurpose>A &Property; that contributes to a &Flux;</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <refsect2>
	  <title>C++ Synopsis</title>
      <programlisting>
#include "engine/property.h" </programlisting>

      <classsynopsis language="cpp">
        <ooclass>
          <classname>FluxProperty</classname>
        </ooclass>
        <ooclass>
          <modifier>public</modifier>
          <classname><xref linkend="Class-PhysicalProperty"/></classname>
        </ooclass>
  	    <methodsynopsis>
	      <modifier>virtual</modifier>
          <void/>
          <methodname><link
	                      linkend="Class-FluxProperty-begin_point">begin_point</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FEMesh*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><classname><xref linkend="Class-Element"/></classname>*</type>
		    <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>Flux*</type>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>MasterPosition&amp;</type>
		    <parameter>masterpos</parameter>
	      </methodparam>
	    </methodsynopsis>       <!-- begin_point -->
        
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link linkend="Class-FluxProperty-end_point">end_point</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type>FEMesh*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><classname><xref linkend="Class-Element"/></classname>*</type>
		    <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>Flux*</type>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>MasterPosition&amp;</type>
		    <parameter>masterpos</parameter>
	      </methodparam>
        </methodsynopsis>       <!-- end_point -->

	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link linkend="Class-FluxProperty-flux_matrix">flux_matrix</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
	        <type>FEMesh*</type>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
	        <type><classname><xref linkend="Class-Element"/></classname>*</type>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>ElementFuncNodeIterator&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>             
	      <methodparam>
            <modifier>const</modifier>
		    <type>Flux*</type>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type>MasterPosition&amp;</type>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>         <!-- flux_matrix -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link
                          linkend="Class-FluxProperty-flux_offset">flux_offset</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
			<type><xref linkend="Class-Flux"/>*</type>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>pt</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>            
        </methodsynopsis>     <!-- flux_offset -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link linkend="Class-FluxProperty-flux_value">flux_value</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
			<type><xref linkend="Class-Flux"/>*</type>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>pt</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>     <!-- flux_value -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link linkend="Class-FluxProperty-static_flux_value">static_flux_value</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
			<type><xref linkend="Class-Flux"/>*</type>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>pt</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>     <!-- static_flux_value -->
      </classsynopsis>
      
      <refsect3>
        <title>Source Files</title>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>
              <filename>SRC/engine/property.C</filename>: C++ code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/property.h</filename>: C++ header
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/property.swg</filename>: SWIG source
              code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/property.swg</filename>: Python code
              included in the SWIG output
            </simpara>
          </listitem>
        </itemizedlist>
      </refsect3>               <!-- Source files -->
    </refsect2>                 <!-- C++ FluxProperty Synopsis-->
    
    <refsect2 id="Class-PyFluxProperty" xreflabel="PyFluxProperty">
      <title>Python Synopsis</title>
      <para>
        <classname>PyFluxProperty</classname> is a swigged C++ class
        that is derived (in C++) from
        <classname>FluxProperty</classname>.  It is used as a base
        class for <classname>FluxProperties</classname> that are
        defined in Python.  When the methods listed below are called
        from C++, they use the Python C API to invoke methods in the
        Python derived class.
      </para>
      <programlisting>
from ooflib.SWIG.engine import pypropertywrapper </programlisting>
      <classsynopsis language="python">
        <ooclass>
          <classname>PyFluxProperty</classname>
        </ooclass>
        <ooclass>
          <classname>FluxProperty</classname>
        </ooclass>
        <methodsynopsis>
          <methodname><link linkend="Class-FluxProperty-begin_point">begin_point</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
        </methodsynopsis>       <!-- begin_point -->
        <methodsynopsis>
          <methodname><link linkend="Class-FluxProperty-end_point">end_point</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
        </methodsynopsis>       <!-- end_point -->

	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-flux_matrix">flux_matrix</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>node</parameter>
	      </methodparam>             
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- flux_matrix -->        

	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-flux_value">flux_value</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- flux_value -->        
	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-flux_offset">flux_offset</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- flux_offset -->        

	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-static_flux_value">static_flux_value</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- static_flux_value -->        

      </classsynopsis>
      <refsect3>
        <title>Source Files</title>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.C</filename>: C++
              code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.h</filename>: C++
              header
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.swg</filename>:
              SWIG source code
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <filename>SRC/engine/pypropertywrapper.spy</filename>:
              Python code inserted into the SWIG output.
            </simpara>
          </listitem>
        </itemizedlist>
      </refsect3>               <!-- Python source files -->
    </refsect2>                 <!-- Python Synopsis-->
    
  </refsynopsisdiv>

  <refsection>
    <title>Overview</title>
    <para>
      A <classname>FluxProperty</classname> is &Property; that
      contributes to a &flux;.  For example, <link
      linkend="PropertyType-Elasticity"><literal>Elasticity</literal></link>
      contributes to <xref linkend="Flux-Stress"/>, and <link
      linkend="PropertyType-ThermalConductivity"><literal>ThermalConductivity</literal></link>
      contributes to <xref linkend="Flux-Heat_Flux"/>.
    </para>
    <para>
      A <classname>FluxProperty</classname> can either compute the
      &Flux; directly:
      
      <equation id="Eqn-flux1">
        <alt role="tex">
          \[
          \mathrm{flux}({\bf x}) = \sigma({\bf x}, \varphi, \nabla\phi)
          + {\bf C} \cdot \frac{\partial\varphi}{\partial t}
          \]
        </alt>
      </equation>
      
      or compute its linearization:
      
      <equation id="Eqn-flux2">
        <alt role="tex">
          \[
          \mathrm{flux}({\bf x}) = {\bf K}({\bf x}, \varphi, \nabla\varphi)
          \cdot
          \nabla\varphi
          + \sigma_0({\bf x}, \varphi, \nabla\phi)
          + {\bf C} \cdot \frac{\partial\varphi}{\partial t}
          \]
        </alt>
      </equation>

      or both.  Here &varphi; is a &Field; or &Fields;, and &boldx; is
      a position.  In <xref linkend="Eqn-flux1"/> &sigma; is the part
      of the &flux; that does not depend on the time derivative of the
      &Fields;.  In <xref linkend="Eqn-flux2"/> &Kmatrix; is the
      matrix of coefficients when the flux is expressed as a local
      linear function of
      
      <inlineequation>
        <alt role="tex">
          \(\nabla\varphi\)
        </alt>
      </inlineequation>
        
      and
      
      <inlineequation>
        <alt role="tex">
          \(\sigma_0\)
        </alt>
      </inlineequation>

      is the offset (intercept).
    </para>
    <para>
      Both <xref linkend="Eqn-flux1"/> and <xref linkend="Eqn-flux2"/>
      allow the &flux; to include a term proportional to the time
      derivative of the &field;.  &Cmatrix; is a matrix that
      multiplies the &field; derivatives.
    </para>
    <para>
      In <xref linkend="Eqn-flux1"/>, &sigma; is computed by <link
      linkend="Class-FluxProperty-static_flux_value"><function>static_flux_value()</function></link>.
      If there is a &Cmatrix; matrix, <link
      linkend="Class-FluxProperty-flux_value"><function>flux_value()</function></link>
      must be defined as well.
    </para>
    <para>
      In <xref linkend="Eqn-flux2"/>, &Kmatrix; and &Cmatrix; are
      computed by <link
      linkend="Class-FluxProperty-flux_matrix"><function>flux_matrix()</function></link>
      and

      <inlineequation>
        <alt role="tex">
          \(\sigma_0\)
        </alt>
      </inlineequation>

      is computed by <link
      linkend="Class-FluxProperty-flux_offset"><function>flux_offset()</function></link>.
    </para>
    <para>
      Because &oof2; needs to know the matrix of coefficients,
      &Kmatrix;, in order to solve a set of equations, and needs to
      know the actual value of the &flux; in order to compute outputs,
      it actually needs all of the functions mentioned above.
      However, the default base class implementation of
      <function>static_flux_value()</function> computes the flux from
      <function>flux_matrix()</function> and
      <function>flux_offset()</function>.  The default base class
      implementation of <function>flux_matrix()</function> computes
      the matrix by numerically differentiating
      <function>static_flux_value()</function>.  If there are no
      &Cmatrix; contributions or &flux; offset, it is sufficient for a
      subclass to define either
      <function>static_flux_value()</function> or
      <function>flux_matrix()</function>. The computation is more
      efficient if both are defined, and if neither is defined the
      &flux; will be zero.
    </para>
  </refsection>               <!-- FluxProperty Overview -->
  
  <refsection>
    <title>Constructor</title>
    <para>
      The C++ and Python constructors are the same as the <link
      linkend="Class-Property-Constructors">base class
      constructors</link>.
    </para>
  </refsection>

  <refsection>
    <title>Methods</title>

    <refsection id="Class-FluxProperty-begin_point">
	  <title><code>void begin_point(const FEMesh*, const Element*, const Flux*, const MasterPosition&amp;)</code></title>
	  <para>
        When building the finite element matrices and vectors, &oof2;
        loops over the Gauss points within each &elem;.  At each Gauss
        point it calls all of the <classname>FluxProperty</classname>
        methods that have been redefined in the derived classes,
        starting with <function>begin_point()</function>.  If the
        other methods share some expensive compuatations, the
        computations can be performed in
        <function>begin_point()</function> and their results cached.
	  </para>
      <para>
        The default implementation of
        <function>begin_point()</function> does nothing.
      </para>
    </refsection>               <!-- begin_point -->
  
    <refsection id="Class-FluxProperty-end_point">
	  <title><code>void end_point(const FEMesh*, const Element*, const Flux*, const MasterPosition&amp;)</code></title>
	  <para>
	    <function>end_point</function> is just like <link
	    linkend="Class-Property-begin_point"><function>begin_point</function></link>,
	    except that it's called <emphasis>after</emphasis> &oof2; is
	    done computing the contribution at a point.  The
	    <function>end_point()</function> method can be used to clean
	    up any temporary objects allocated by <methodname><link
	    linkend="Class-Property-begin_point">begin_point</link></methodname>.
	  </para>
      <para>
        The default implementation of <function>end_point()</function>
        does nothing.
      </para>
    </refsection><!-- end_point -->
    
    
    <refsection id="Class-FluxProperty-flux_matrix">
	  <title><code>void flux_matrix(const FEMesh* mesh, const Element* element, const ElementFuncNodeIterator&amp; node, ...)</code></title>
	  <para>
	    &oof2; <classname>FluxProperties</classname> that represent
	    terms in a constitutive equation must define the function
	    <methodname>Property::flux_matrix()</methodname>.
	    <methodname>flux_matrix()</methodname> computes a matrix that,
	    when multiplied by a vector of degrees of freedom, produces a
	    vector containing the components of a &flux;.  Explaining this
	    properly requires a brief review of the finite element
	    machinery.
	  </para>
	  <para>
        <anchor id="fluxmatrix_discussion"/>
	    Let

        <inlineequation>
	      <alt role="tex">\(\varphi_n({\bf x})\)</alt>
	    </inlineequation>

	    be the <emphasis>n</emphasis><superscript>th</superscript>
	    component of a field &varphi; at position &boldx;.  If the
	    field values are known at nodes
        
        <inlineequation>
	      <alt role="tex">
            \(\nu\)
          </alt>
	    </inlineequation>

	    at positions

	    <inlineequation>
          <alt role="tex">
            \(x_\nu\)
          </alt>
	    </inlineequation>,
        
        then the finite element shape functions

	    <inlineequation>
	      <alt role="tex">
            \(N_\nu({\bf x})\)
          </alt>
	    </inlineequation>
          
	    can be used to approximate the field at any point:
        
	    <equation id="Eqn-Property-expansion">
	      <alt role="tex">
            \[\varphi_n({\bf x}) = \sum_\nu N_\nu({\bf x}) \varphi_{n\nu}\]
          </alt>
	    </equation>

	    where
          
	    <inlineequation>
	      <alt role="tex">
            \(N_\nu({\bf x})\)
          </alt>
	    </inlineequation>
          
	    is the shape function that is 1 at node

	    <inlineequation>
	      <alt role="tex">
            \(\nu\)
          </alt>
	    </inlineequation>
          
	    and 0 at all other nodes, and

	    <equation>
	      <alt role="tex">
            \(\varphi_{n\nu}\equiv \varphi_n({\bf x_\nu})\)
          </alt>
        </equation>

        (the <emphasis>n</emphasis><superscript>th</superscript>
        component of the field at node

        <inlineequation>
          <alt role="tex">
            \(\nu\)
          </alt>
        </inlineequation>).
          
        Similarly, the derivative of the field is

        <equation id="Eqn-Property-deriv">
          <alt role="tex">
            \[
            \frac{\partial\phi_n}{\partial{\bf x}} =
            \sum_\nu \frac{\partial N_\nu}{\partial{\bf x}} \varphi_{n\nu}
            \]
          </alt>
        </equation>
 	  </para>
	  <para>
 	    A constitutive relation connects a &field;, &varphi;, or field
        gradient,
        <inlineequation>
          <alt role="tex">
            \(\nabla\varphi\)
          </alt>
        </inlineequation>,

        and a &flux;, &sigma;, through a modulus.  For now, let's
        assume that it can be represented as a linear operator,
        <inlineequation>
          <alt role="tex">
            \(\mathcal{K}\)
          </alt>
        </inlineequation>

        <equation>
          <alt role="tex">
            \[
            \sigma = \mathcal{K}({\bf x}) \cdot \nabla\varphi
            \]
          </alt>
        </equation>

        If

        <inlineequation>
          <alt role="tex">
            \([\varphi]\)
          </alt>
        </inlineequation>

         is a vector containing all of the components of &varphi; at
         all of the nodes, and

         <inlineequation>
           <alt role="tex">
             \([\sigma({\bf x})]\)
           </alt>
         </inlineequation>

         is a vector containing all the components of the flux at
         point &boldx;, then
        
	    <equation id="Eqn-Property-flux">
	      <alt role="tex">
	        \[
            [\sigma({\bf x})] = \mathcal{K}({\bf x})\cdot [\varphi]
            \]
	      </alt>
	    </equation>

      </para>
      
      <para>
	    Inserting <xref linkend="Eqn-Property-expansion"/> into <xref
	    linkend="Eqn-Property-flux"/>

        <equation>
          <alt role="tex">
            \[
            [\sigma({\bf x})]_i =
            \sum_{n\nu} \left(
              \mathcal{K}_{i,n\nu} \frac{\partial N_\nu({\bf x})}{\partial{\bf x}_n}
              \right)
            \varphi_{n\nu}
            \]
          </alt>
        </equation>
        
        shows that the vector of flux values is related to the vector
        of field values by a matrix &Kmatrix;  we call the
        <emphasis>flux matrix</emphasis>:

        <equation id="Eqn-flux-matrix">
          <alt role="tex">
            \[
            {\bf K}_{i,n\nu} = \mathcal{K}_{i,n\nu}\frac{\partial
            N_\nu({\bf x})}{\partial{\bf x}_n}
            \]
          </alt>
        </equation>

        The columns of &Kmatrix; correspond to
	    degrees of freedom 

        <inlineequation>
	      <alt role="tex">\(\varphi_{n\nu}\)</alt>
        </inlineequation>

        and its rows to components of the flux &sigma;. 
	  </para>

	  <para>
	    For example, for <link
	    linkend="Property-Thermal-Conductivity-Anisotropic-Cubic">thermal
	    conductivity</link> the heat flux is a vector

        <inlineequation>
          <alt role="tex">
            \( J({\bf x}) \)
          </alt>
        </inlineequation>

	    <equation>
	      <alt role="tex">
	        \begin{align*}
            J_i
            &amp;= -\kappa_{ij} \nabla_jT \\
            &amp;= -\kappa_{ij} \frac{\partial}{\partial{\bf x}_j}
              (T_\nu N_\nu({\bf x})) \\
            &amp;= -\left(\kappa_{ij}
              \frac{\partial N_\nu({\bf x})}{\partial {\bf x}_j}\,
               \right) T_\nu \\
            \end{align*} 
	      </alt>
        </equation>

	    from which we get

	    <equation id="Eqn-Property-K">
	      <alt role="tex">
            \[
	        K_{i\nu} = -\kappa_{ij}
               \frac{\partial N_\nu({\bf x})}{\partial {\bf x}_j}
	        \]
	      </alt>
	    </equation>

        Note that there is no <inlineequation><alt
        role="tex">\(n\)</alt></inlineequation> index because
        Temperature is a scalar.
	  </para>
	  <para>
	    Actually, <xref linkend="Eqn-Property-K"/> isn't quite
	    correct, because we ignored the <link
	    linkend="Section-Concepts-Mesh-3D">out-of-plane</link>
	    components.  The out-of-plane part of the temperature field
	    is 
          
	    <inlineequation>
	      <alt role="tex">
            \(
	        \partial T/\partial z
	        \)
          </alt>
	    </inlineequation>.

        The part of the flux <inlineequation><alt
        role="tex">\(J\)</alt></inlineequation> due to the
        out-of-plane temperature gradient is

	    <equation>
	        <alt role="tex">
              \[
              J_i = -\kappa_{iz} \frac{\partial T}{\partial z}
	          \]
            </alt>
	    </equation>
	    Since

        <inlineequation>
            <alt role="tex">
              \(\partial T/\partial z\)
            </alt>
        </inlineequation>

        is a &Field; (an out-of-plane field, in the &oof2; sense &mdash;
        it's computed at nodes just like in-plane fields are), it can
        be expanded in terms of shape functions and the field values
        at nodes, as in <xref linkend="Eqn-Property-expansion"/>.
        From this we see that the extra terms in &Kmatrix; are:
          
	    <equation id="Eqn-Property-Kp">
	      <alt role="tex">
            \[
	        K'_{i\nu} = -\kappa_{iz}N_\nu(r)
	        \]
          </alt>
	    </equation>

	  </para>
	  <para>
	    On each call, <function>flux_matrix()</function> must make
	    contributions to &Kmatrix; for all of the components of a
	    given flux, all of the components of the relevant fields
	    &varphi; and their out-of-plane parts), and one given node

	    <inlineequation>
          <alt role="tex">
            \(\nu\)
          </alt>
         </inlineequation>).
	  </para>
	  <para>
	    It is important to note that it is <emphasis>not</emphasis>
	    necessary for the <function>flux_matrix()</function>
	    routine or its author to know anything about the following:
	    <itemizedlist spacing="compact">
	      <listitem>
	        <para>
		      The topology or number of nodes in the element.
	        </para>
	      </listitem>
	      <listitem>
	        <para>
		      How nodal degrees of freedom are mapped into columns
		      of the flux matrix.
	        </para>
	      </listitem>
	      <listitem>
	        <para>
		      How flux components are mapped into rows of the flux matrix.
	        </para>
	      </listitem>
	      <listitem>
	        <para>
		      What equations are being solved.
	        </para>
	      </listitem>
	    </itemizedlist>
	  </para>
	    <para>
	      The arguments to <function>flux_matrix()</function> are:
	      <variablelist>
	        <varlistentry>
	          <term><code>const <link linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
	          <listitem>
		        <para>
		          The finite element mesh that's being solved.
		          <function>flux_matrix()</function> probably doesn't
		          have to use the <varname>mesh</varname> object
		          directly, but it does have to pass it through to
		          other functions.
		        </para>
	          </listitem>
	        </varlistentry>
	        <varlistentry>
	          <term><code>const <link linkend="Class-Element">Element</link>* element</code></term>
	          <listitem>
		        <para>
		          The finite <link
		          linkend="Class-Element">element</link> under
		          consideration.  This shouldn't be explicitly needed
		          except in cases in which the material parameters
		          depend on physical space coordinates or in which
		          history-dependent fields are stored in the element.
		        </para>
	          </listitem>
	        </varlistentry>
	        <varlistentry>
	          <term><code>const <link
	          linkend="Class-ElementFuncNodeIterator">ElementFuncNodeIterator</link>&amp; node</code></term>
	          <listitem>
		        <para>
		          This is the node

                  <inlineequation>
                    <alt role="tex">
                      \(\nu\)
                    </alt>
		          </inlineequation>

		          referred to in the discussion <link
		          linkend="fluxmatrix_discussion">above</link>.  It's
		          passed in in the form of an iterator, which can
		          iterate over all of the nodes of the element,
		          although it should be thought of here simply as a
		          way of accessing the node's indices and shape
		          functions.<footnote><simpara> It's not possible to
		          use a <link
		          linkend="Class-Node"><classname>Node</classname></link>
		          instead of an <link
		          linkend="Class-ElementFuncNodeIterator"><classname>ElementFuncNodeIterator</classname></link>
		          here.  <classname>Nodes</classname> are unable to
		          evaluate shape functions because they don't know
		          which <link
		          linkend="Class-Element"><classname>Element</classname></link>
		          is being computed.
		          <classname>ElementFuncNodeIterators</classname> know
		          which <classname>Element</classname> they're looping
		          over.</simpara></footnote>
                  The node's shape function and its
		          derivatives can be obtained from <link
		          linkend="Class-ElementShapeFuncIterator-shapefunction"><methodname>ElementFuncNodeIterator::shapefunction</methodname></link>
		          and <link
		          linkend="Class-ElementShapeFuncIterator-dshapefunction"><methodname>ElementFuncNodeIterator::dshapefunction</methodname></link>.
		        </para>
	          </listitem>
	        </varlistentry>
	        <varlistentry>
	          <term><code>const <link linkend="Class-Flux">Flux</link>*
	          flux</code></term>
	          <listitem>
		        <para>
		          The &flux; &sigma; referred to in the discussion <link
		          linkend="fluxmatrix_discussion">above</link>.
		          Properties that contribute to more than one &flux;
		          need to check this variable to know which flux
		          they're computing now.
		        </para>
	          </listitem>
	        </varlistentry>
	        <varlistentry>
	          <term><code>const <link
	          linkend="Class-MasterCoord">MasterPosition</link>&amp; position</code></term>
	          <listitem>
		        <para>
		          The flux matrix is evaluated at a physical
		          coordinate &boldx; (often a Gauss integration point,
		          but not always).  <varname>position</varname> is the
		          point in the <link
		          linkend="Class-Element"><classname>Element</classname></link>'s
		          master coordinate space<footnote
		          id="footnote-masterspace"> <simpara> Elements are
		          first defined in a master coordinate space, where
		          geometry is easy, and then mapped to their actual
		          positions in physical space.  The master
		          quadrilateral is a square of side 2 centered on the
		          origin.  The master triangle is a right isosceles
		          triangle with vertices (0,0), (1,0), and (0,1).  A
		          master space coordinate can be converted to a
		          physical point by <link
		          linkend="Class-Element-from_master"><methodname>Element::from_master</methodname></link>.</simpara></footnote>
		          corresponding to &boldx;.
		        </para>
	          </listitem>
	        </varlistentry>
        
	        <varlistentry>
	          <term>
                <code><link linkend="Class-FluxData">SmallSystem</link>*
	            fluxdata</code>
              </term>
	          <listitem>
		        <para>
		          The <classname>SmallSystem</classname> class stores
		          the portion of the the actual flux matrix &Kmatrix;
		          and other flux data that is currently being
		          computed.  (This data can't be stored directly in
		          the &Flux; object because one &Flux; is shared among
		          many &FEMesh;es.
		          The <link
		          linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>
		          object is local to this computation.)  The actual
		          flux matrix &Kmatrix; can be accessed through the
		          methods <link
		          linkend="Class-SmallSystem-stifffness_matrix_element"><methodname>SmallSystem::stiffness_matrix_element()</methodname></link>
		          <foreignphrase>et al</foreignphrase>.  This
		          function handles the mapping from node, field, and
		          flux component indices to actual row and column
		          indices.
                </para>
	          </listitem>
	        </varlistentry>
	      </variablelist>
	    </para>
	    <para>
	      Here is the <methodname>fluxmatrix</methodname> routine for
	      the <classname>HeatConductivity</classname> class, from
	      <filename>SRC/engine/property/heatconductivity/heatconductivity.C</filename>
	      in the &oof2; source code:
	    </para>

        <programlisting>
void HeatConductivity::flux_matrix(const FEMesh  *mesh,
				   const Element *el,
				   const ElementFuncNodeIterator &amp;nu,
				   const Flux *flux,
				   const MasterPosition &amp;pt,
				   double time,
				   SmallSystem *fluxdata) const
{
  if (*flux != *heat_flux) { <co id="flux_matrix-test"/>
    throw ErrProgrammingError("Unexpected flux", __FILE__, __LINE__); <co id="flux_matrix-error"/>
  }

  double sf   = nu.shapefunction( pt ); <co id="flux_matrix-shapefun"/>
  double dsf0 = nu.dshapefunction( 0, pt ); <co id="flux_matrix-dshapefun"/>
  double dsf1 = nu.dshapefunction( 1, pt ); <coref linkend="flux_matrix-dshapefun"/>

  const SymmMatrix3 cond(conductivitytensor(mesh, el, pt)); <co id="flux_matrix-modulus"/>

  for(IndexP i : *flux->components(ALL_INDICES)) { <co id="flux_matrix-loop"/>
     <co id="flux_matrix-fieldcomps"/>
    // in-plane temperature gradient contributions
    fluxdata->stiffness_matrix_element(i, temperature, nu) -= <co id="flux_matrix-temperature"/> <co id="flux_matrix-mat"/>
        cond(i.integer(), 0) * dsf0 +  <co id="flux_matrix-K"/>
        cond(i.integer(), 1) * dsf1;   <coref linkend="flux_matrix-K"/>

    // out-of-plane temperature gradient contribution
    if(!temperature->in_plane(mesh)) <co id="flux_matrix-oopcheck"/>
      <coref linkend="flux_matrix-fieldcomps"/>
      fluxdata->stiffness_matrix_element(i, temperature->out_of_plane(), nu) <co id="flux_matrix-oop"/>
              -= cond(i.integer(), 2) * sf; <co id="flux_matrix-Kp"/>
  }
} 
        </programlisting>
        <calloutlist>
          <callout arearefs="flux_matrix-test">
            <para>
              We don't really need to do this.  It's a sanity check to
              make sure that we got the &flux; we wanted.
              <varname>heat_flux</varname> was set in the
              <classname>HeatConductivity</classname> constructor by
              calling <code>Flux::getFlux("Heat_Flux")</code> and
              dynamically casting the result to a
              <classname>VectorFlux*</classname>.  If a Property makes
              contributions to more than one
              <classname>Flux</classname>, then a statement like this
              is used to determine which flux it is being asked to
              compute.
            </para>
          </callout>
          <callout arearefs="flux_matrix-error">
            <para>
              <link
              linkend="Class-ErrProgrammingError"><classname>ErrProgrammingError</classname></link>
              is declared in
              <filename>SRC/common/ooferror.h</filename>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-shapefun">
            <para>
              Here is where the shape functions are evaluated.  This
              is <inlineequation><alt
              role="tex">\(N_\nu\)</alt></inlineequation>.  Values are
              precomputed and cached at the Gauss integration points,
              so the evaluation here is fast.
            </para>
          </callout>
          <callout arearefs="flux_matrix-dshapefun">
            <para>
              These are the derivatives of the shape functions.  The
	          first argument is the component of the
	          gradient. <literal>0</literal> is <emphasis>x</emphasis>
	          and <literal>1</literal> is <emphasis>y</emphasis>.
	          These values are also cached at Gauss points.
            </para>
          </callout>
          <callout arearefs="flux_matrix-modulus">
            <para>
	          <function>conductivity_tensor()</function> is a virtual function
	          defined in the <classname>HeatConductivity</classname>
	          subclasses.  It takes <classname>FEMesh*</classname>,
	          <classname>Element*</classname>, and
	          <classname>MasterPosition&amp;</classname> arguments so
	          that a subclass can define a position-dependent modulus,
	          or something even more bizarre.
            </para>
          </callout>
          <callout arearefs="flux_matrix-loop">
            <para>
              Note> that this loop is over all components of the
              &Flux;.  When solving a <link
              linkend="Section-Concepts-Mesh-plane-flux">plane-flux</link>
              problem, the out-of-plane coefficients in &Kmatrix; are
              used to generate the constraint equations. Looping over
              the components of a &Field; or &Flux; is discussed in
              <xref linkend="Section-Coding-Indices"/>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-fieldcomps">
            <para>
              If the field weren't a scalar, there would be a loop
              over its components here.
            </para>
          </callout>
          <callout arearefs="flux_matrix-temperature">
            <para>
              <varname>temperature</varname> is a variable stored in
              the <classname>HeatConductivity</classname> class and
              initialized by calling <code><link
              linkend="Function-getField">Field::getField</link>("Displacement")</code>
              in the <classname>HeatConductivity</classname>
              constructor.
            </para>
          </callout>
          <callout arearefs="flux_matrix-mat">
            <para>
              <link linkend="Class-SmallSystem-stiffness_matrix_element">
	          <methodname>SmallSystem::stiffness_matrix_element()</methodname>
              </link> retrieves a C++ reference to the matrix element
	          that couples flux component <varname>i</varname> to the
	          <varname>temperature</varname> field at node
	          <varname>nu</varname>.
              Note that we use <code>-=</code>
	          instead of <code>=</code> because a previous call to
	          <methodname>fluxmatrix</methodname> may already have
	          addressed this matrix element.
            </para>
          </callout>
          <callout arearefs="flux_matrix-K">
            <para>
              This is <xref linkend="Eqn-Property-K"/>, summing over
              <inlineequation><alt
              role="tex">\(j\)</alt></inlineequation>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-oopcheck">
            <para>
              This checks to see if the temperature field has an
              <link
              linkend="Section-Concepts-Mesh-3D">out-of-plane</link>
              part.  If it does, its contribution to the stress is
              computed.
            </para>
          </callout>
          <callout arearefs="flux_matrix-oop">
            <para>
	          This retrieves a reference to the matrix element
	          coupling the <link
	          linkend="Section-Concepts-Mesh-3D">out-of-plane</link>
	          component of the temperature to flux component
	          <inlineequation><alt
	          role="tex">\(i\)</alt></inlineequation>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-Kp">
            <para>
              This is <xref linkend="Eqn-Property-Kp"/>.
            </para>
          </callout>
        </calloutlist>
	  </refsection><!-- fluxmatrix -->


  <!-- fluxrhs moved here from refProperty.xml. TODO Needs to be
       updated -->
  
      <refsection id="Class-Property-fluxrhs">
	<title><code>void Property::fluxrhs(...) const</code></title>
	<para>
	  &oof2; <classname>Properties</classname> that represent
	  external (generalized) forces or otherwise contribute to the
	  right hand side of a <link
	  linkend="Section-Concepts-Mesh-Equation-Divergence">divergence
	  equation</link> must define
	  <methodname>Property::fluxrhs</methodname>.
	  <methodname>fluxrhs</methodname> is similar to <link
	  linkend="Class-Property-fluxmatrix"><methodname>Property::fluxmatrix</methodname></link>
	  in its role and its arguments, but is generally simpler to
	  implement.  Each <methodname>fluxrhs</methodname>
	  implementation must compute a quantity at a given point
	  within an element, but does not have to concern itself with
	  nodes and shapefunctions.
	</para>
	<para>
	  There are two kinds of contributions to the right hand side
	  of the divergence equation.  <emphasis>Body
	  forces</emphasis> contribute directly to the right hand side
	  of the divergence equation <xref linkend="Eqn-Divergence"/>,
	  but <emphasis>offsets</emphasis> contribute a
	  field-independent value to the flux on the left hand side of
	  <xref linkend="Eqn-Divergence"/>.
	  (Field-<emphasis>dependent</emphasis> contributions are made
	  by <link
	  linkend="Class-Property-fluxmatrix"><methodname>Property::fluxmatrix</methodname></link>.)
	</para>
	<para>
	  For an example, consider linear thermal expansion.
	  The flux (stress) is
	  <equation>
	    <alt role="tex">
	      \[
	      \sigma_{ij} = C_{ijkl}
	      \left(\epsilon_{kl} - \alpha_{kl}(T-T_0)\right)
	      \]
	    </alt>
	  </equation>
	  <inlineequation>
	    <alt role="tex">\(T_0\)</alt>
	  </inlineequation>
	  is the temperature at which the stress-free strain vanishes,
	  and makes a field independent <emphasis>offset</emphasis>,
	  <inlineequation>
	    <alt role="tex">\(C_{ijkl}\alpha_{kl}T_0\)</alt>
	  </inlineequation>,
	  to the flux.  On the other hand, gravitational forces do not
	  contribute to the flux, but appear as body forces:
	  <equation>
	    <alt role="tex">
	      \[\nabla\cdot\sigma = -g\hat{\mathrm{\bf y}}\]
	    </alt>
	  </equation>
	</para>
	<para>
	  The arguments to <methodname>Property::fluxrhs</methodname> are:
	  <variablelist>
	    <varlistentry>
	      <term><code>const <link linkend="Class-FEMesh">FEMesh</link> *mesh</code></term>
	      <listitem>
		<para>
		  The finite element mesh that's being solved.
		  <methodname>fluxrhs</methodname> probably doesn't
		  have to use the <varname>mesh</varname> object
		  directly, but it might need to pass it through to
		  other functions.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><code>const <link linkend="Class-Element">Element</link> *element</code></term>
	      <listitem>
		<para>
		  The finite <link
		  linkend="Class-Element">element</link> under
		  consideration.  This shouldn't be explicitly needed
		  except in cases in which the material parameters
		  depend on physical space coordinates or in which
		  history-dependent fields are stored in the element.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><code>const <link linkend="Class-Flux">Flux</link>
		*flux</code></term>
	      <listitem>
		<para>
		  The &flux; under consideration.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><code><link linkend="Class-FluxData">FluxData</link> *fluxdata</code></term>
	      <listitem>
		<para>
		  The <varname>fluxdata</varname> object stores the
		  results computed by
		  <methodname>fluxrhs</methodname>.  It's the same
		  object that was passed to <link
		  linkend="Class-Property-fluxmatrix"><methodname>fluxmatrix</methodname></link>. <link
		  linkend="Class-FluxData-offset_element"><methodname>FluxData::offset_element</methodname></link>
		  accumulates offsets, and <link
		  linkend="Class-FluxData-rhs_element"><methodname>FluxData::rhs_element</methodname></link>
		  accumulates body forces.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><code>const <link
	      linkend="Class-MasterCoord">MasterPosition</link>
	      &amp;x</code></term>
	      <listitem>
		<para>
		  Each call to <methodname>fluxrhs</methodname>
		  evaluates the rhs or flux offset at a given point
		  within the given <link
		  linkend="Class-Element"><classname>Element</classname></link>. <varname>x</varname>
		  is the master space<footnoteref
		  linkend="footnote-masterspace"/> coordinate of the
		  point.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Here is the <methodname>fluxrhs</methodname> function from
	  the <classname>ForceDensity</classname> class, from
	  <filename>SRC/engine/property/forcedensity/forcedensity.C</filename>
	  in the &oof2; source code.  It provides an example of a
	  <emphasis>body force</emphasis>:
	</para>
	<programlisting>
void ForceDensity::fluxrhs(const FEMesh *mesh, const Element *element,
			      const Flux *flux, FluxData *fluxdata,
			      const MasterPosition &amp;x) const 
{
  if(*flux != *stress_flux) { <co id="fluxrhs-test"/>
    throw ErrProgrammingError("Unexpected flux", __FILE__, __LINE__); <co id="fluxrhs-error"/>
  }
  
  fluxdata->rhs_element(0) -= gx; <co id="fluxrhs-rhs_element"/>
  fluxdata->rhs_element(1) -= gy;
} </programlisting>
	<calloutlist>
	  <callout arearefs="fluxrhs-test">
	    <para>
	      As in <link
	      linkend="Class-Property-fluxmatrix"><methodname>fluxmatrix</methodname></link>,
	      above, this is a sanity check.
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-error">
	    <para>
	      <classname>ErrProgrammingError</classname> is declared
	      in <filename>SRC/common/ooferror.h</filename>.
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-rhs_element">
	    <para>
	      <code>FluxData::rhs_element(i)</code> returns a
	      reference to the
	      <varname>i</varname><superscript>th</superscript>
	      component of the divergence of the flux.  Some other
	      <classname>Property</classname> may already have made a
	      contribution to it, so here its value is changed with
	      <code>-=</code> instead of <code>=</code>.  All of the
	      components of the divergence should be addressed.
	      <note>
		<para>
		  As far as <classname>FluxData</classname> is
		  concerned, the divergence of a symmetric 3&times;3
		  tensor flux, such as stress, has only 2 components!
		  This is because the out-of-plane forces are
		  irrelevant.<footnote>
		    <para>
		      If the flux is in-plane, then
		      <inlineequation>
			<alt role="tex">\(\sigma_{iz}=0\)</alt>
		      </inlineequation>
		      and the out-of-plane force must be zero too.  If
		      the flux is not in-plane, then
		      <inlineequation>
			<alt role="tex">\(\sigma_{iz}\)</alt>
		      </inlineequation>
		      will be found during the solution process, and
		      the out-of-plane forces can be computed.  In
		      both cases it's meaningless to specify the
		      forces ahead of time.
		    </para>
		  </footnote>
		  The function <link
		  linkend="Class-Flux-divergence_dim">Flux::divergence_dim</link>
		  can be used to find the number of components of the
		  divergence of a flux.
		</para>
	      </note>
	    </para>
	  </callout>
	</calloutlist>
	<para>
	  Here is the <methodname>fluxrhs</methodname> method from the
	  <classname>ThermalExpansion</classname> property, which is
	  an example of a flux <emphasis>offset</emphasis>.  It
	  computes the field-independent term
	  <equation id="Eqn-thermalexpfluxrhs">
	    <alt role="tex">\(C_{ijkl}\alpha_{kl}T_0\)</alt>
	  </equation>
	  The original version can be found in
	  <filename>SRC/engine/property/thermalexpansion/thermalexpansion.C</filename>
	  in the &oof2; source code.
	</para>
	<programlisting>
void ThermalExpansion::fluxrhs(const FEMesh *mesh, const Element *element,
				   const Flux *flux, FluxData *fluxdata,
				   const MasterPosition &amp;x) const {
  
  if(*flux!=*stress_flux) {
    throw ErrProgrammingError("Unexpected flux." __FILE__, __LINE__);
  }
  const Cijkl modulus = elasticity->cijkl(mesh, element, x); <co id="fluxrhs-mod"/>

  for(SymTensorIterator ij; !ij.end(); ++ij) { <co id="fluxrhs-ij"/>
    double &amp;offset_el = fluxdata->offset_element(mesh, ij); <co id="fluxrhs-offset"/>
    for(SymTensorIterator kl; !kl.end(); ++kl) { <co id="fluxrhs-kl"/>
      if(kl.diagonal()) { <co id="fluxrhs-sum"/>
	offset_el += modulus(ij,kl)*expansiontensor[kl]*tzero_;
      }
      else {
	offset_el += 2.0*modulus(ij,kl)*expansiontensor[kl]*tzero_;
      }
    }
  }
} </programlisting>
	<calloutlist>
	  <callout arearefs="fluxrhs-mod">
	    <para>
	      This retrieves the elastic modulus
	      <inlineequation>
		<alt role="tex">\(C_{ijkl}\)</alt>
	      </inlineequation>
	      from the <classname>Material</classname>'s
	      <classname>Elasticity</classname> property.  The
	      variable <varname>elasticity</varname> was set by
	      this <classname>Property</classname>'s
	      <methodname>cross_reference</methodname> function, like
	      this:
	      <programlisting>
void ThermalExpansion::cross_reference(Material *mat) {
  elasticity = dynamic_cast&lt;Elasticity*>(mat->fetchProperty("Elasticity"));
} </programlisting>
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-ij">
	    <para>
	      This is the loop over components of the flux, just like
	      item <xref linkend="fluxmatrix:stressloop"/> in the
	      <methodname>fluxmatrix</methodname> example.
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-offset">
	    <para>
	      <code>FluxData::offset_element(i)</code> returns a
	      reference to a component of the flux offset.  The
	      variable <varname>i</varname> must be the appropriate
	      kind of <link
	      linkend="Class-FieldIndex"><classname>FieldIndex</classname></link>
	      or <link
	      linkend="Class-FieldIterator"><classname>FieldIterator</classname></link>
	      object.
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-kl">
	    <para>
	      This is the loop over the indices
	      <inlineequation>
		<alt role="tex">\(kl\)</alt>
	      </inlineequation>
	      in Eq. <xref linkend="Eqn-thermalexpfluxrhs"/>. 
	    </para>
	  </callout>
	  <callout arearefs="fluxrhs-sum">
	    <para>
	      The next few lines compute terms in the sum,
	      accumulating them in the <classname>FluxData</classname>
	      object.  <methodname>expansiontensor</methodname> is a
	      <link
		linkend="Class-SymmMatrix3"><classname>SymmMatrix3</classname></link>
	      object stored in the
	      <classname>ThermalExpansion</classname>
	      object, containing the matrix
	      <inlineequation>
		<alt role="tex">\(\alpha_{kl}\)</alt>
	      </inlineequation>.
	      The loop <xref linkend="fluxrhs-kl"/> addresses
	      only the independent symmetric tensor entries
	      <inlineequation>
		<alt role="tex">\(kl\)</alt>
	      </inlineequation>, but the sum in <xref
		linkend="Eqn-thermalexpfluxrhs"/> includes the other
	      half of the tensor as well.  Therefore, we need to
	      include a factor of 2 for the off-diagonal
	      terms. <varname>tzero_</varname> is <inlineequation>
		<alt role="tex">\(T_0\)</alt>
	      </inlineequation>, which is set when the
	      <classname>ThermalExpansion</classname> object is constructed.
	    </para>
	  </callout>
	</calloutlist>
  </refsection><!-- fluxrhs -->
  
  </refsection>               <!-- FluxProperty Methods-->
  
</refentry>                    <!-- FluxProperty -->



  <!-- Keep this comment at the end of the file
  Local variables:
  sgml-omittag:t
  sgml-shorttag:t 
  sgml-namecase-general:nil
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("man_oof2.xml" "book" "part" "reference")
  sgml-exposed-tags:nil
  sgml-local-ecat-files:nil
  End:
-->
