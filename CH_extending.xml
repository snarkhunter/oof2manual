<!--
  This software was produced by NIST, an agency of the
  U.S. government, and by statute is not subject to copyright in the
  United States.  Recipients of this software assume all
  responsibilities associated with its operation, modification and
  maintenance. However, to facilitate maintenance we ask that before
  distributing modified versions of this software, you first contact
  the authors at oof_manager@nist.gov.
-->

<chapter id="Chapter-Extending">
  <title>Extending &oof2;</title>
  <para>
    &oof2; is meant to be easily extended to include new physics.
    Users with a bit of programming experience can add new &fields;,
    &fluxes;, &equations;, and especially &material; &properties;.
    Adding new &fields; and &fluxes; is easy, but is not of much use
    unless new &properties; are added that use the &fields; and
    &fluxes;.  Adding &properties; is more complicated, but the
    individual steps are more-or-less straightforward.  Adding
    &equations; is easy if the new equations fit the form of the
    existing <classname>Equation</classname> classes.  Writing new
    <classname>Equation</classname> classes can be tricky, but should
    not be commonly required.
  </para>
  <para>
    <xref linkend="Chapter-Extending"/> describes the
    <emphasis>structure</emphasis> of extensions to &oof2;.  <xref
    linkend="Chapter-Coding"/> describes the actual
    <emphasis>contents</emphasis> of extension modules.  Both assume
    that the reader is familiar with the C++ and Python programming
    languages.
  </para>
  <section id="Section-Extending-Mechanics">
    <title>The Mechanics of Extending &oof2;</title>
    <para>
      This section describes how &oof2; extensions are constructed
      from source files.  It <emphasis>doesn't</emphasis> describe how
      to write the source files.  The contents of the source files are
      discussed in other sections.
    </para>
    <para>
      There are two ways of building &oof2; extensions.  Users
      building &oof2; from the source distribution can include code
      for an extension in the <filename>SRC/EXTENSIONS</filename>
      directory in the main &oof2; directory.  Extensions placed there
      will be built when &oof2; is built and can be loaded
      automatically when &oof2; starts.  These extensions are called
      <emphasis>internal</emphasis> extensions.
    </para>
    <para>
      &oof2; can also load extensions built independently of the
      installation process.  Such extensions are called <link
      linkend="Section-Extending-External"><emphasis>external</emphasis></link>
      extensions.  Adding external extensions is the only option for
      users who do not have permission to edit files in the main
      &oof2; directory tree, however it requires either that &oof2;
      was built with the <varname>OOF2_DEV_INSTALL</varname> option in
      cmake or that the &oof2; source directory is accessible.
      External extensions must always be explicitly loaded into &oof2;
      at run time, but there is no other difference in the behavior of
      internal and external extensions.
    </para>
    <para>
      &oof2; extension code can consist of three types of files:
      Python code, C++ code, and <ulink url="http://www.swig.org"
      role="external"><application>swig</application></ulink> wrapper
      files.  The Python files are imported directly into &oof2;, the
      C++ code is compiled into a shared library, and the swig wrapper
      files are converted into more C++ and Python files that
      constitute a <link linkend="Extending-confusion">Python
      extension module</link>. This module links to the extension's
      shared library, and is imported by the extension's Python code.
      The structural organization of an &oof2; extension is shown in
      <xref linkend="Figure-orgchart"/>.
    </para>
    <figure id="Figure-orgchart">
      <title>Components of an &oof2; Extension</title>
      <mediaobject>
	    <imageobject>
	      <imagedata fileref="FIGURES/extending/orgchart.png"
	                 contentwidth="707px" format="PNG"/>
	    </imageobject>
	    <caption>
	      <para>
	        The anatomy of an &oof2; extension.  The red boxes
	        indicate the components of an extension, and the labels on
	        the right indicate their sources.  The dotted line
	        delimits one of the <link
	        linkend="Extending-confusion">Python extension
	        modules</link> within the &oof2; extension.  Arrows
	        indicate linkages: the Python modules at the top import
	        Python wrapper modules, which import wrapper libraries,
	        which link to shared libraries built from the extension's
	        C++ code.  The core &oof2; modules and libraries can be
	        invoked from any part of the extension code, but, as
            indicated by the  double headed arrow, only the
	        core &oof2; Python module can import an extension.
	      </para>
	    </caption>
      </mediaobject>
    </figure>
    <note id="Extending-swig-suffix">
      <para>
        For historical reasons, &oof2; uses <quote>.swg</quote>
        instead of the more standard <quote>.i</quote> as the suffix
        for swig source files.  In our defense <quote>.swg</quote> is
        more descriptive.  The <xref
        linkend="swig_sources"/> function used in the
        following sections assumes that the suffix is
        <quote>.swg</quote>.
      </para>
    </note>
    <note id="Extending-confusion">
      <para>
	    It's necessary to make a distinction between an &oof2;
	    extension and a Python extension module.  An &oof2; extension
	    is vaguely defined as a bunch of code that adds some
	    functionality to &oof2;.  Everything in the yellow, blue, and
	    pink boxes in <xref linkend="Figure-orgchart"/> is one &oof2;
	    extension.  A Python extension module, on the other hand, is
	    specifically defined as a C++ library and some Python code
	    that allows Python to call functions from the library.  One
	    &oof2; extension can contain many Python extension modules.
      </para>
    </note>
    <para>
      In all cases, the procedure for creating an &oof2; extension is
      the same:
      <orderedlist numeration="arabic">
	    <listitem id="Extending-stepone">
	      <para>
	        Write the C++, python, and swig source code.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        Write the CMake input file(s),
	        <filename>CMakeLists.txt</filename>.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        Build and install the extension using CMake.  For external
	        extensions, this is similar to building &oof2;. For internal
	        extensions, it's identical.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        Run &oof2;, load the extension, and find out what's wrong.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
	        Go to <xref linkend="Extending-stepone"/>, as necessary.
	      </para>
	    </listitem>
      </orderedlist>
    </para>
  </section> <!-- mechanics of extending oof2 -->

  <!--============================================================-->
  
  <section id="Section-Extending-External">
    <title>External Extensions</title>
    <para>
      This section describes how to create external &oof2;
      extensions. External extensions are defined outside of the
      &oof2; source directory hierarchy and are not built or installed
      when &oof2; is built and installed.  Therefore they are a bit
      more difficult to work with, but they don't require write-access
      to the &oof2; source code.
    </para>
    <para>
      This section describes three way of building extensions.
      There's no fundamental reason that external &oof2; extensions
      must be built using the procedures and naming conventions
      described here.  Other techniques certainly exist, and users who
      are proficient with <ulink url="https://www.swig.org"
      role="external">swig</ulink> and <ulink url="https://cmake.org"
      role="external">CMake</ulink>, or can do without them, should
      feel free to do it their own way.  The methods described here
      should be easy for most users and should suffice in almost all
      cases, though.
    </para>
      

    <!--============================================================-->

    <section id="Section-Trivial-Extension">
      <title>Building a Trivial Extension with Python</title>
      <para>
        If an extension consists only of Python files, you can load
        them with <xref linkend="MenuItem-OOF.File.Load.Script"/>.
        The extension mechanism described here is not needed.  Or you
        can arrange the files into a subdirectory with an
        <filename>__init__.py</filename> file, put the subdirectory
        into the Python path (see <xref
        linkend="Section-pythonpath-extensions"/>) and import the
        extension with <xref
        linkend="MenuItem-OOF.File.Load.Module"/>.
      </para>
    </section>
    
    <!--============================================================-->

    <section id="Section-Single-Extension">
      <title>Building a Single Simple Extension with C++ and Python</title>

      <para>
        <xref linkend="Figure-extensiondirs1"/> shows the directory
        layout for a simple extension, with the source files on the
        left and the installed executable files on the right.  The
        extension developer must provide all of the source files.
        This section describes how to construct
        <filename>CMakeLists.txt</filename>.  The other files are
        described in <xref linkend="Chapter-Coding"/>.
      </para>
      <para>
        The top level source directory,
        <filename>extension_source</filename> can be located anywhere.
        The installation directory, however, must be in the Python
        path.  Its name can be anything convenient and does
        <emphasis>not</emphasis> have to be the name of the extension.
        The installation directory can contain other code &emdash; it
        does not have to be devoted only to &oof2;.
        
      </para>
      <figure id="Figure-extensiondirs1">
        <title>Simple Extension Directory Layout</title>
        <mediaobject>
          <imageobject>
          <imagedata fileref="FIGURES/extending/directorylayouts.png"
                     format="PNG" contentwidth="628px"/>
        </imageobject>
        <caption>
          <para>
            The directory structure for a simple &oof2; extension,
            with the source directory on the left and the installation
            directory on the right.  Directory names are in bold type.
            Files with names in red are created by the
            developer. <quote>Other files</quote> could include Python
            scripts that are imported into
            <filename>oofextension.py</filename> or additional C++
            files that contribute to
            <filename>_oofextension.so</filename>.  <emphasis
            role="bold"><filename>INSTALL</filename></emphasis> is a
            directory in the Python path.
          </para>
        </caption>
        </mediaobject>
      </figure>
      
      <para>
        The <filename>CMakeLists.txt</filename> file contains
        instructions for CMake.  Copy the text from <xref
        linkend="cmake0"/> into a file named
        <filename>CMakeLists.txt</filename> in the source
        directory. Edit the file as needed. Please note the numbered
        comments at the end of the <xref linkend="cmake0"/>.  At the
        very least
        <orderedlist>
          <listitem>
            <para>
              Change all instances of <emphasis
              role="bold"><code>PREFIX</code></emphasis> to the &oof2;
              installation location,
              <foreignphrase>i.e</foreignphrase>, the value of
              <varname>CMAKE_INSTALL_PREFIX</varname> used to build
              &oof2;.  For example, if the top &oof2; executable
              script is <filename>/usr/local/bin/oof2</filename>, then
              <emphasis role="bold"><code>PREFIX</code></emphasis> is
              <filename>/usr/local</filename>.
            </para>
          </listitem>
          <listitem>
            <para>
              Change all instances of <emphasis
              role="bold"><code>oofextension</code></emphasis> to the
              name of your extension files. If your files are
              <filename>abcde.h</filename>,
              <filename>abcde.C</filename>,
              <filename>abcde.swg</filename>, etc, then replace
              <emphasis role="bold"><code>oofextension</code></emphasis>
              with <code>abcde</code>.
            </para>
          </listitem>
        </orderedlist>
        
        <example id="cmake0">
          <title>CMakeLists.txt for a simple extension</title>
          <programlisting>
cmake_minimum_required(VERSION 3.18) # <co id="cmake0-minversion"/>

project(projectname VERSION 0.0.0) # <co id="cmake0-project"/>

set(OOF2_PYTHON3_VERSION 3.11 CACHE STRING "Use this version of Python") # <co id="cmake0-oofversions"/>
set(OOF2_SWIG_VERSION 4.1 CACHE STRING "Use this version of swig")

include("<emphasis role="bold">PREFIX</emphasis>/share/oof2/tools/oofbuildtools.cmake") # <co id="cmake0-prefix"/>

find_library(OOF2COMMON oof2common <emphasis role="bold">PREFIX</emphasis>/lib) # <co id="cmake0-libraries"/>
find_library(OOF2ENGINE oof2engine <emphasis role="bold">PREFIX</emphasis>/lib)
mark_as_advanced(OOF2COMMON OOF2ENGINE) # <co id="cmake0-advanced"/>

swig_sources( # <co id="cmake0-swig_sources"/>
  SWIGFILES
  <emphasis role="bold">oofextension</emphasis>
  LIBRARIES
  ${OOF2COMMON} ${OOF2ENGINE} 
  INCLUDE_DIRECTORIES
  <emphasis role="bold">PREFIX</emphasis>/include/oof2 ${Python3_INCLUDE_DIRS}
  SOURCES
  <emphasis role="bold">oofextension</emphasis>.C
  SWIGDEST
  ${CMAKE_INSTALL_PREFIX}
) </programlisting>
          
        <calloutlist>
          <callout arearefs="cmake0-minversion">
            <para>
              &oof2; uses some features from CMake 3.18.  Older
              versions might be usable for extensions.
            </para>
          </callout>
          <callout arearefs="cmake0-project">
            <para>
              <varname>projectname</varname> just needs to be a
              unique name.  It's not used anywhere in this simple
              example.  Likewise, the version number is for your
              information.  &oof2; will not use it.
            </para>
          </callout>
          <callout arearefs="cmake0-oofversions">
            <para>
              These version numbers should match the versions that
              were used when &oof2; was built.
            </para>
          </callout>
          <callout arearefs="cmake0-prefix">
            <para>
              This line loads settings and functions used when
              building &oof2;.
            </para>
          </callout>
          <callout arearefs="cmake0-libraries">
            <para>
              If you need to link to other &oof2; libraries, or
              any other libraries at all, add new lines for them
              here, and include the libraries in the
              <varname>LIBRARIES</varname> list when you call
              <varname>swig_sources</varname>.
            </para>
          </callout>
          <callout arearefs="cmake0-advanced">
            <para>
              This line is optional. It prevents
              <varname>OOF2COMMON</varname> and
              <varname>OOF2ENGINE</varname> from appearing in the
              ccmake GUI, since you probably don't want to set
              them there.
            </para>
          </callout>
          <callout arearefs="cmake0-swig_sources">
            <para>
              <code>swig_sources</code> is a function defined in
              <filename>oofbuildtools.cmake</filename>.  It runs swig
              to generate the C++ and Python wrapper code, compiles
              the C++ code, and links and installs the results.  See
              <xref linkend="swig_sources"/> for the
              details.
            </para>
          </callout>
        </calloutlist>
        </example>
      </para>

      <para>
        To compile and install an extension built this way, see the
        instructions in <xref linkend="Section-Installing-External"/>.
        To use it within &oof2;, see <xref
        linkend="Section-Running-External"/>.
      </para>
    </section> <!--Building a Single Extension-->

    <!--============================================================-->
    
    <section id="Section-Complex-Extension">
      <title>Building a Set of Extensions</title>
      <para>
        This section describes how to build a set of extensions that
        use multiple C++ and swig source files, which are distributed
        across multiple directories.  The files are installed into a
        <ulink
        url="https://docs.python.org/3/tutorial/modules.html%23packages"
        role="external">package</ulink> named
        <quote>oofextensions</quote>, which resides in a directory
        that is part of the Python path.  The file layout is
        illustrated in <xref linkend="Figure-extensiondirs2"/>.  Each
        extension has its own subdirectory.
        <figure id="Figure-extensiondirs2">
          <title>Less Simple Extension Directory Layout</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="FIGURES/extending/directorylayouts2.png"
                         contentwidth="676" format="PNG"/>
            </imageobject>
            <caption>
              <para>
                The directory structure for a compound &oof2;
                extension, with the source directory on the left and
                the installation directory on the right.  Directory
                names are in bold type.  Files in red are created by
                the developer. <emphasis
                role="bold"><filename>INSTALL</filename></emphasis> is
                a directory in the Python path.
              </para>
            </caption>
          </mediaobject>
        </figure>
      </para>
      <para>
        This isn't much more complicated than the previous example.
        The differences are that every source directory and
        subdirectory needs its own <filename>CMakeLists.txt</filename>
        file, and there needs to be an
        <filename>__init__.py</filename> file to tell Python that the
        files contained in the installation directory are part of a
        package.
      </para>
      
      <section id="Section-Extending-Multi-Top">
        <title>The top level directory</title>
        <para>
          The top directory in the extensions' hierarchy needs to
          contain two files, <filename>CMakeLists.txt</filename> and
          <filename>__init__.py</filename>, along with the
          subdirectories for each extension.
        </para>
        <formalpara>
          <title>CMakeLists.txt</title>
          <para>
            The top level <filename>CMakeLists.txt</filename> file (in
            the <filename>extension_source</filename> directory in
            <xref linkend="Figure-extensiondirs2"/>) is just like the
            beginning of the file in <xref linkend="cmake0"/>.  Copy
            the lines from <xref linkend="cmake1"/> to a file called
            <filename>CMakeLists.txt</filename> in your source
            directory and make the indicated changes.  Everything in
            bold type in the example should be changed.
          </para>
        </formalpara>
        <example id="cmake1">
          <title>Top level CMakeLists.txt for a set of extensions</title>
          <programlisting>
cmake_minimum_required(VERSION 3.18)

project(<emphasis role="bold">oofextensions</emphasis> VERSION <emphasis role="bold">0.0.0</emphasis>) # <co id="cmake1-project"/>

set(OOF2_PYTHON3_VERSION 3.11 CACHE STRING "Use this version of Python") # <co id="cmake1-pyversion"/>
set(OOF2_SWIG_VERSION 4.1 CACHE STRING "Use this version of swig")

include("<emphasis role="bold">PREFIX</emphasis>/share/oof2/tools/oofbuildtools.cmake") # <co id="cmake1-prefix"/>

find_library(OOF2COMMON oof2common /Users/langer/lib)
find_library(OOF2ENGINE oof2engine /Users/langer/lib)
mark_as_advanced(OOF2COMMON OOF2ENGINE)

install( # <co id="cmake1-install"/>
  FILES
  ${PROJECT_SOURCE_DIR}/__init__.py
  DESTINATION ${CMAKE_INSTALL_PREFIX}/${CMAKE_PROJECT_NAME})

add_subdirectory("<emphasis role="bold">extension1</emphasis>") # <co id="cmake1-subdir"/>
add_subdirectory("<emphasis role="bold">extension2</emphasis>") </programlisting>
        </example>
        <calloutlist>
          <callout arearefs="cmake1-project">
            <para>
              In this example, the project name is used as the name of
              the installed Python package.  See <xref
              linkend="cmake1-install"/>.  Change <emphasis
              role="bold"><code>oofextensions</code></emphasis> to
              the name you want to import in &oof2;.
            </para>
          </callout>
          <callout arearefs="cmake1-pyversion">
            <para>
              These version numbers should match the versions that
              were used when &oof2; was built.
            </para>
          </callout>
          <callout arearefs="cmake1-prefix">
            <para>
              Change <emphasis
              role="bold"><code>PREFIX</code></emphasis> to the &oof2;
              installation prefix.  If &oof2; is installed as
              <filename>/usr/local/bin/oof2</filename>, replace
              <emphasis role="bold"><code>PREFIX</code></emphasis>
              with <filename>/usr/local</filename>.
            </para>
          </callout>
          <callout arearefs="cmake1-install">
            <para>
              This installs the top level
              <filename>__init__.py</filename> in a subdirectory given
              by the project name, set in <xref
              linkend="cmake1-project"/>.  If you want to install
              elsewhere, change or delete
              <code>/${CMAKE_PROJECT_NAME}</code> here and in the
              subdirectories' <link
              linkend="cmake1a"><filename>CMakeLists.txt</filename></link>
              files.
            </para>
          </callout>
          <callout arearefs="cmake1-subdir">
            <para>
              All subdirectories containing extensions should be
              listed here.
            </para>
          </callout>
        </calloutlist>
        <formalpara>
          <title>__init__.py</title>
          <para>
            The <filename>__init__.py</filename> file in the
            installation directory is copied directly from the source
            directory.  It tells Python to treat the directory as a
            package and optionally tells it to import the modules for
            the subdirectories.  For example, using the file names
            from <xref linkend="Figure-extensiondirs2"/>, if
            <filename>__init__.py</filename> contains the single line
            <literallayout class="monospaced">
            from . import extension1, extension2 </literallayout>
            then both extensions will be loaded if you type
            <literallayout class="monospaced">
              import oofextensions </literallayout>
            in the &oof2;
            <link linkend="Section-Windows-Console">Console
            Window</link>.  However, if
            <filename>__init__.py</filename> is empty, the
            extensions will each have to be loaded explicitly,
            <foreignphrase>e.g,</foreignphrase> by typing
            <literallayout class="monospaced">
            import oofextensions.extension1
            import oofextensions.extension2</literallayout>
            in the Console Window.
          </para>
        </formalpara>
        <para>
          A third possibility is for
          <filename>__init__.py</filename> to contain the line
          <literallayout class="monospaced">
          __all__ = ["extension1", "extension2"] </literallayout>
          which will allow both extensions to be loaded with
          <literallayout class="monospaced">
          from oofextensions import * </literallayout>
        </para>
      </section>                <!--top directory-->
      <section id="Section-Extending-Subdirectories">
        <title>The subdirectories</title>
        <para>
          Each of the subdirectories in <xref
          linkend="Figure-extensiondirs2"/> must contain its own
          <filename>CMakeLists.txt</filename> file, along with the
          source code files (which will be discussed in <xref
          linkend="Chapter-Coding"/>).  To create the
          <filename>CMakeLists.txt</filename> files, copy the text
          from <xref linkend="cmake1a"/> to each subdirectory, with
          the following changes:
          <orderedlist>
            <listitem>
              <simpara>
                Change <emphasis
                role="bold"><code>extension1</code></emphasis> to the
                name of the swig file (without its extension) in the
                subdirectory.
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                Change <emphasis
                role="bold"><code>PREFIX</code></emphasis> to the
                &oof2; installation prefix, as in
                <filename>CMakeLists.txt</filename> in the parent
                directory.
              </simpara>
            </listitem>
          </orderedlist>
        </para>
        <example id="cmake1a">
          <title>CMakeLists.txt in subdirectories</title>
          <programlisting>
swig_sources(
  SWIGFILES
  <emphasis role="bold">extension1</emphasis> # <co id="cmake1a-swigname"/>
  LIBRARIES
  ${OOF2COMMON} ${OOF2ENGINE} 
  INCLUDE_DIRECTORIES
  <emphasis role="bold">PREFIX</emphasis>/include/oof2 ${Python3_INCLUDE_DIRS} # <co id="cmake1a-prefix"/>
  SOURCES
  <emphasis role="bold">extension1.C</emphasis> # <co id="cmake1a-cname"/>
  SWIGDEST
  ${CMAKE_INSTALL_PREFIX}/${CMAKE_PROJECT_NAME} # <co id="cmake1a-destdir"/>
  ) </programlisting>
        </example>
        <calloutlist>
          <callout arearefs="cmake1a-swigname">
            <para>
              This is the name of the swig source file, minus its
              suffix.
            </para>
          </callout>
          <callout arearefs="cmake1a-prefix">
            <para>
              Replace <emphasis
              role="bold"><code>PREFIX</code></emphasis> with the
              &oof2; installation prefix.
            </para>
          </callout>
          <callout arearefs="cmake1a-cname">
            <para>
              All C++ files that need to be compiled must be listed
              here.  Files generated by swig should not be included.
            </para>
          </callout>
          <callout arearefs="cmake1a-destdir">
            <para>
              This is where the files will be installed.
              <code>CMAKE_INSTALL_PREFIX</code> is a directory
              in the Python path and is set when the extension is
              configured (see <xref
              linkend="Section-Installing-External"/>).
              <code>CMAKE_PROJECT_NAME</code> is the name used in the
              <code>project(...)</code> line in the top level
              <filename>CMakeLists.txt</filename>, and is used here
              only because this example is using the project name as
              the Python package name.
            </para>
          </callout>
        </calloutlist>
      </section>              <!--subdirectories-->

      <section id="Section-Extending-SharedLibs">
        <title>Adding New Shared Libraries</title>
        <para>
          When adding multiple extensions that share code between
          themselves, the common code should be put into a shared
          library, and <emphasis>not</emphasis> included in the
          <code>swig_sources</code> call for the extension modules
          themselves.  To build the shared library, add the following
          code to the <filename>CMakeLists.txt</filename> file in one
          of the extension directories:<footnote><simpara>You can put
          the code in a new directory if you prefer.  Just make sure
          that <filename>CMakeLists.txt</filename> in the extension's
          top directory includes the new directory via a
          <code>add_subdirectory</code> call.:</simpara></footnote>
        </para>
        <example>
          <title id="cmake1b"> </title>
          <programlisting>
add_library(libname SHARED) # <co id="libname"/>

target_sources(
  libname # <co id="libname2"/>
  PRIVATE
  extensioncode.C extensioncode.h  # <co id="cxxfiles"/>
)

install(
  TARGETS
  libname # <co id="libname3"/>
  DESTINATION ${CMAKE_INSTALL_LIBDIR}) </programlisting>
        </example>
        <calloutlist>
          <callout arearefs="libname">
            <para>
              Substitute the name of the shared library for
              <varname>libname</varname>.  Omit the <quote>lib</quote>
              prefix and any suffixes.
            </para>
          </callout>
          <callout arearefs="libname2">
            <para>
              The name on this line should be the name from <xref
              linkend="libname"/>.
            </para>
          </callout>
          <callout arearefs="cxxfiles">
            <para>
              List all of the C++ source files here.
            </para>
          </callout>
          <callout arearefs="libname3">
            <para>
              Again, replace <varname>libname</varname> with the name
              of the library.
            </para>
          </callout>
        </calloutlist>
        <para>
          In addition, add <varname>libname</varname> to the
          <code>LIBRARIES</code> list in the <code>swig_sources</code>
          calls, for all extensions that use the library:
          <programlisting>
swig_sources(
  SWIGFILES
  ...
  LIBRARIES
  ${OOF2COMMON} ${OOF2ENGINE} libname
  ...
  ) </programlisting>
        </para>
      </section>                <!--Adding new shared libraries-->
      
    </section>                <!--Building a More Complex Extension-->

    <section id="Section-Installing-Templates">
      <title>Building Extensions from Templates</title>
      <para>
        Extensions defining new versions of some &oof2; &properties;
        can be easily created from templates.  The templates are
        installed in <filename>PREFIX/share/oof2/templates</filename>,
        where <filename>PREFIX</filename> is the &oof2; installation
        prefix (the value of <varname>CMAKE_INSTALL_PREFIX</varname>
        used when &oof2; was built).  The templates defined for a
        variety of nonlinear and nonconstant material &properties;
        allow the user to specify the form of the nonlinearity or
        nonconstancy without worrying about the other technical
        details of writing an extension.
      </para>
      <para>
        The steps required to use the templates are:
        <orderedlist>
          <listitem>
            <para>
              Build and install &oof2; with the
              <varname>OOF2_DEV_INSTALL</varname> option.
            </para>
          </listitem>
          <listitem>
            <para>
              Run <xref linkend="oof2-extension-setup"/> to create an
              editable copy of the template files.  It lets you choose
              what type of &property; to create and sets simple things
              like the directory name, module name, and class name.
              It will create a directory containing a
              <filename>CMakeLists.txt</filename> file and a
              subdirectory containing source files.  See <xref
              linkend="oof2-extension-setup"/> for the details.
            </para>
          </listitem>
          <listitem>
            <para>
              This is the hard part. Edit the source files created by
              <xref linkend="oof2-extension-setup"/>, in the
              <filename>source</filename> subdirectory, adding the
              code that makes your &property; unique.  Comments in the
              source files describe what you need to do.  <xref
              linkend="Chapter-Coding"/> will help as well.
            </para>
          </listitem>
          <listitem>
            <para>
              Run ccmake in the build directory to build and install
              the extension, as described in <xref
              linkend="Section-Installing-External"/>.
            </para>
          </listitem>
          <listitem>
            <para>
              Run &oof2; and load the extension, as described in <xref
              linkend="Section-Running-External"/>.
            </para>
          </listitem>
        </orderedlist>
      </para>
    </section>               <!--Building Extensions from Templates-->
    
  </section>                    <!--External Extensions-->

  <!--============================================================-->
  
  <section id="Section-Installing-External">
    <title>Compiling and Installing External Extensions</title>
    <orderedlist>
      <listitem>
        <para>
          Create <filename>CMakeLists.txt</filename> and the source
          files, as described in the previous sections.
        </para>
      </listitem>
      <listitem>
        <para>
          Create a <filename>build</filename> directory.  It can be
          inside the source directory, but it does not have to be.  It
          also does not have to be called <filename>build</filename>.
        </para>
      </listitem>
      <listitem>
        <para>
          In a terminal window, cd to the build directory and type

                    <literallayout class="monospaced">
    ccmake &lt;path&gt; </literallayout>

          to start ccmake, replacing <code>&lt;path&gt;</code> with
          the path to the top source directory containing
          <filename>CMakeLists.txt</filename>.<footnote><para> For
          example, if <filename>build</filename> is a subdirectory of
          the source directory, type <quote><code>cmake
          ..</code></quote>.</para></footnote>
        </para>
      </listitem>
      <listitem>
        <para>
          Inside ccmake,
          <orderedlist>
            <listitem>
              <simpara>
                Type 'c' to generate the initial configuration.
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                Change<footnote>
                <para>
                  The &oof2; <ulink
                  url="https://www.ctcms.nist.gov/oof/oof2/README.html">README</ulink>
                  file has some basic instructions on how to use
                  ccmake.  For more detail, see the <ulink
                  url="https://cmake.org/cmake/help/latest/guide/user-interaction/index.html%23guide:User%20Interaction%20Guide"
                  role="external">CMake User Interaction
                  Guide</ulink>.
                </para> </footnote>

                <varname>CMAKE_INSTALL_PREFIX</varname> to the
                location where the extension is to be installed.  This
                should be the directory marked <emphasis
                role="bold"><code>INSTALL</code></emphasis> in <xref
                linkend="Figure-extensiondirs1"/> and <xref
                linkend="Figure-extensiondirs2"/>.
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                Type 'c' to update the configuration.
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                Type 'g' to generate the <filename>Makefile</filename>
                and exit ccmake.
              </simpara>
            </listitem>
          </orderedlist>
        </para>
      </listitem>
      <listitem>
        <para>
          Type <code>make</code> to run swig and compile the C++
          files.
        </para>
      </listitem>
      <listitem>
        <para>
          Type <code>make install</code> to install the Python module
          and compiled libraries.  If you're installing into a system
          directory, type <code>sudo make install</code> instead.
        </para>
      </listitem>
    </orderedlist>
  </section>         <!--Compiling and Installing External Extensions-->

  <!--============================================================-->

  <section id="Section-Running-External">
    <title>Running OOF2 with External Extensions</title>
    <para>
      It is first necessary to tell Python how to find the
      extension, and then to tell &oof2; to load it.
    </para>
    <section id="Section-pythonpath-extensions">
      <title>Setting PYTHONPATH for Extensions</title>
      <para>
        For an extension to be used by &oof2; it must be located in
        a directory that is in Python's path &emdash; the list of
        directories that Python searches when it imports a module.
        You can check the path by running
        
        <literallayout class="monospaced">
    python -c "import sys; print(sys.path)" </literallayout>
        
        in a terminal window.
      </para>
      <para>
        If the directory containing the extension is not listed, there
        are a number of ways to add it.  In all of these examples,
        replace the word <quote>directory</quote> with the file system
        path to the directory containing the extension module.
      </para>
      <orderedlist>
        <listitem>
          <para>
            Set the <varname>PYTHONPATH</varname> environment
            variable. The way that is done depends on which version of
            the Unix shell you're using. In bash, for example, you
            would type
            
              <literallayout class="monospaced">
    export PYTHONPATH=$PYTHONPATH:directory </literallayout>
            
            to append the directory to an existing path.  This will
            apply to all future &oof2; sessions and any other Python
            programs started in the current terminal window.  To make
            this change apply to all future terminal windows, put the
            export line in your shell's start-up file
            (<filename>~/.profile</filename> in bash).
          </para>
        </listitem>
        <listitem>
          <para>
            Start &oof2; with the <link
            linkend="CommandLineArg-pathdir"><userinput>--pathdir=directory</userinput></link>
            option, which will add "directory" to the path just for
            that session of &oof2; and won't affect any other Python
            programs.  Equivalently, in bash and maybe other shells,
            you can start &oof2; like this:
            
            <literallayout class="monospaced">
    PYTHONPATH=directory oof2 </literallayout>
          </para>
        </listitem>
        <listitem>
          <para>
            To make the change for all future &oof2; sessions, but
            not affect any other Python programs, insert the line

            <literallayout class="monospaced">
    sys.path.append("directory") </literallayout>

            in the <link
            linkend="Section-oof2rc"><filename>.oof2rc</filename></link>
            file in your home directory.
          </para>
        </listitem>
      </orderedlist>
    </section>
    <section id="Section-loading-extensions">
      <title>Loading External Extensions</title>
      <para>
        There are a few different ways of loading external extension
        modules.  They all rely on having the extension's installation
        directory in the Python path, as explained in <xref
        linkend="Section-pythonpath-extensions"/>.  The main
        differences between the methods are
        <itemizedlist>
          <listitem>
            <para>
              Whether they load the module when &oof2; starts or later
              on in the session.
            </para>
          </listitem>
          <listitem>
            <para>
              Whether the loading is done by an &oof2; <link
              linkend="MenuItem-OOF">menu command</link> or directly
              by Python.  If it's loaded by a command, the command
              will be <link
              linkend="MenuItem-OOF.File.Save.Python_Log">saved</link>
              in the session log, and the module will be reloaded if
              the log is <link
              linkend="MenuItem-OOF.File.Load.Script">reloaded</link>.
            </para>
          </listitem>
          <listitem>
            <para>
              Whether they apply to all future &oof2; sessions or
              just the current one.
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        The list below contains all the options.  In each example,
        replace <quote>oofextension</quote> with the name of your
        extension:
      </para>
      <orderedlist>
        <listitem>
          <para>
            Run the command <xref
            linkend="MenuItem-OOF.File.Load.Module"/> from the
            <command>File</command> menu in the main &oof2; window,
            and type the module name in the dialog box.  This will
            load the module using a scriptable command in the current
            &oof2; session.
          </para>
        </listitem>
        <listitem>
          <para>
            Put the line 

              <literallayout class="monospaced">
    OOF.File.Load.Module(module="oofextension") </literallayout>

            in the <link
            linkend="Section-oof2rc"><filename>.oof2rc</filename></link>
            in your home directory.  This will load the module using a
            scriptable menu command in all future &oof2; sessions.
          </para>
        </listitem>
        <listitem>
          <para>
            Start &oof2; with the <link
            linkend="CommandLineArg-import"><userinput>--import</userinput></link>
            option, like this:
             <literallayout class="monospaced">
    oof2 --import=oofextension </literallayout>

            This loads the module at start-up time without using a
            menu command, and works only on the current session.
            Modules loaded with <userinput>--import</userinput> are
            loaded <emphasis>before</emphasis> the
            <filename>.oof2rc</filename> file is read, so this method
            won't work if the path to the module is set in
            <filename>.oof2rc</filename>.  If you need to adjust the
            path at run time, you can use
            <userinput>--pathdir</userinput> in conjunction with
            <userinput>--import</userinput>:

              <literallayout class="monospaced">
    oof2 --pathdir=directory --import=oofextension </literallayout>
          </para>
        </listitem>
        <listitem>
          <para>
            Type the line

            <literallayout class="monospaced">
    import oofextension </literallayout>

            in the <link linkend="Section-Windows-Console">Console
            Window</link> during an &oof2; session. This loads the
            module for the current session without using a menu
            command.
          </para>
        </listitem>
        <listitem>
          <para>
            Put the line

              <literallayout class="monospaced">
    import oofextension </literallayout>

            in the <link
            linkend="Section-oof2rc"><filename>.oof2rc</filename></link>
            in your home directory.  This will load the module without
            using a menu command in all future &oof2; sessions.
          </para>
        </listitem>
      </orderedlist>
      <para>
        It is permissable to import a module more than once and by
        more than one method.  Only the first import will have an
        effect, though.
      </para>
    </section> <!--Running OOF2 with External Extensions-->

  </section> <!--Running OOF2 with External Extensions-->

  <section id="Section-Extending-Internal">
    <title>Internal Extensions</title>
    <para>
      Internal extensions are easier to build and use than <link
      linkend="Section-Extending-External">external</link> extensions
      because they use the &oof2; installation machinery.  However
      they have two disadvantages:
      <orderedlist>
        <listitem>
          <para>
            They require the developer to have permission to write
            files in the &oof2; source code directories.
          </para>
        </listitem>
        <listitem>
          <para>
            The directory containing internal extensions will be
            rewritten when a new version &oof2; is installed, so any
            changes there will be lost.
          </para>
        </listitem>
      </orderedlist>
    </para>
    <para>
      All of the source code for an internal extension should be put
      in a subdirectory of <filename>SRC/EXTENSIONS</filename> in the
      main &oof2; source directory.  If an
      <code>add_subdirectory(extensionname)</code> line is added to
      <filename>SRC/EXTENSIONS/CMakeLists.txt</filename>, then the
      code in the subdirectory <filename>extensionname</filename> will
      be compiled and installed when &oof2; is built.  If a
      subdirectory of this directory contains an
      <filename>__init__.py</filename> file, the directory will be
      imported automatically if &oof2; is started with the <link
      linkend="CommandLineArg-autoload"><userinput>--autoload</userinput></link>
      option.
    </para>
    
    <section id="Section-Internal-Extension-Directory">
      <title>Internal Extension Files</title>
      <para>
        The files required for an internal extension depend on whether
        the extension contains C++ code or is purely Python.
      </para>
      <section id="Section-Pure-Python-Internal-Extension">
        <title>Pure Python Internal Extensions</title>
        <para>
          If the extension contains only Python files, all of the
          files in its entire
          subdirectory, including any nested subdirectories, will be
          installed when &oof2; is installed.  No
          <filename>CMakeLists.txt</filename> file is required in the
          extension's directory, and
          the extension does not have to be listed in any other &oof2;
          <filename>CMakeLists.txt</filename> file.
        </para>
        <para>
          The extension's directory must contain an
          <filename>__init__.py</filename>, which should import the
          extension's other Python files, if those files need to be
          imported when the extension is loaded.  Files defining new
          &fields; or &properties; generally should be loaded at start
          up time.
        </para>
      </section>
      
      <section>
        <title>C++ Internal Extensions</title>
        <para>
          To build an extension called <quote>oofextension</quote>, do
          the following:
          <orderedlist>
            <listitem>
              <para>
                Create a subdirectory called
                <filename>oofextension</filename>
                in <filename>SRC/EXTENSIONS</filename>/
              </para>
            </listitem>
            <listitem>
              <para>
                Edit
                <filename>SRC/EXTENSIONS/CMakeLists.txt</filename> and
                add the line
                <literallayout>
                add_subdirectory(oofextension) </literallayout>
              </para>
            </listitem>
            <listitem>
              <para>
                Inside
                <filename>SRC/EXTENSIONS/oofextension</filename>,
                write the C++ code for the extension, following the
                guidance in <xref linkend="Chapter-Coding"/>.  The C++
                files do not have to be named
                <filename>oofextension.C</filename>, but they can be.
                Write swig files to create the Python interface to
                those parts of the extension that have to be
                accessible from Python. 
              </para>
            </listitem>
            <listitem>
              <para>
                Create a <filename>CMakeLists.txt</filename> in the
                extension's directory.  It should look like <xref
                linkend="cmake2"/>.  If there are subdirectories
                containing C++ code within
                <filename>oofextension</filename>, create
                <filename>CMakeLists.txt</filename> files there too.
              </para>
            </listitem>

          </orderedlist>

          <example id="cmake2">
            <title>CMakeLists.txt for an internal extension</title>
            <programlisting>
oof_swig_sources( # <co id="cmake2-oofswigsources"/>
  SWIGFILES oofextension # <co id="cmake2-swigfiles"/>
  SOURCES oofextension.C # <co id="cmake2-sources"/>
  LIBRARIES oof2common oof2engine # <co id="cmake2-libs"/>
  )

add_subdirectory(subdirectoryname) # <co id="cmake2-subdir"/>
            </programlisting>
            <calloutlist>
              <callout arearefs="cmake2-oofswigsources">
                <para>
                  <code>oof_swig_sources</code> is a wrapper for <xref
                  linkend="swig_sources"/>, and works the same way.
                  It sets <varname>SWIGDEST</varname> and the C++
                  include path appropriately. 
                </para>
              </callout>
              <callout arearefs="cmake2-swigfiles">
                <para>
                  This is the name of the swig file, without its
                  suffix. CMake will look for
                  <filename>oofextension.swg</filename>.   The name of
                  the file does not have to be the same as the name of
                  the extension, but it can be.  More than one swig file
                  can be listed, but only if <code>SOURCES</code> is
                  not used.
                </para>
              </callout>
              <callout arearefs="cmake2-sources">
                <para>
                  Additional C++ source files that need to be compiled
                  are listed here.  There can be more than one.  The
                  C++ file generated by swig should
                  <emphasis>not</emphasis> be listed.  Don't use this
                  if more than one swig file is included in
                  <code>SWIGFILES</code>.
                </para>
              </callout>
              <callout arearefs="cmake2-libs">
                <para>
                  The &oof2; libraries that this extension uses are
                  listed here. <filename>oof2common</filename> should
                  always be included. An extension that adds
                  &properties; or anything related to &skels; or
                  &meshes; should include
                  <filename>oof2engine</filename>, and an extension
                  working with images should include
                  <filename>oof2image</filename>.
                </para>
                <para>
                  Note that when building external extensions,
                  <filename>oof2common</filename>, etc. are not
                  defined, but can be accessed through CMake variables
                  <code>${OOF2COMMON}</code>, etc.
                </para>
              </callout>
              <callout arearefs="cmake2-subdir">
                <para>
                  If there are subdirectories, add a line like this
                  for each, and put a
                  <filename>CMakeLists.txt</filename> file in each
                  one.
                </para>
              </callout>
            </calloutlist>
          </example>
          
        </para>
      </section>                <!-- C++ internal extensions -->
    </section>                    <!-- Internal Extension Files-->
    

  <section id="Section-Extensions-Load-Internal">
    <title>Loading Internal Extensions</title>
    <para>
      Internal extensions are loaded automatically if the <link
      linkend="CommandLineArg-autoload"><userinput>--autoload</userinput></link>
      option is used when starting &oof2;.
    </para>
    <para>
      An individual extension can be loaded manually by typing
      <literallayout class="monospaced">
        import ooflib.EXTENSIONS.extensionname </literallayout> in the
        &oof2; <link linkend="Section-Windows-Console">Console
        Window</link>, or by putting that line a script and loading
        the script.
      </para>
    </section>                  <!-- Loading Internal Extensions -->
  </section>                    <!--Internal Extensions-->

</chapter>

  <!--============================================================-->

  
  
<!-- Keep this comment at the end of the file
  Local variables:
  sgml-omittag:t
  sgml-shorttag:t 
  sgml-namecase-general:nil
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("man_oof2.xml" "book" "chapter")
  sgml-exposed-tags:nil
  sgml-local-ecat-files:nil
  End:
-->
