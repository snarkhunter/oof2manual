<!-- 
  $RCSfile: refMisc.xml,v $
  $Revision: 1.3 $
  $Author: langer $
  $Date: 2011-05-06 16:00:08 $

  This software was produced by NIST, an agency of the
  U.S. government, and by statute is not subject to copyright in the
  United States.  Recipients of this software assume all
  responsibilities associated with its operation, modification and
  maintenance. However, to facilitate maintenance we ask that before
  distributing modified versions of this software, you first contact
  the authors at oof_manager@nist.gov.
-->

    <refentry id="Function-acquirePyLock">
      <refnamediv>
	<refname>acquirePyLock</refname>
	<refpurpose>ensure thread-safe Python API calls</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<programlisting>
#include "common/threadstate.h" </programlisting>
	<funcsynopsis>
	  <funcprototype>
	    <funcdef>
	      <type>void</type>
	      <function>acquirePyLock</function>
	    </funcdef>
	    <void/>
	  </funcprototype>
	</funcsynopsis>
	<funcsynopsis>
	  <funcprototype>
	    <funcdef>
	      <type>void</type>
	      <function>releasePyLock</function>
	    </funcdef>
	    <void/>
	  </funcprototype>
	</funcsynopsis>	
  	<programlisting>
#include "common/ooferror.h" </programlisting>
	<funcsynopsis>
	  <funcprototype>
	    <funcdef>
	      <type>void</type>
	      <function>pythonErrorRelay</function>
	    </funcdef>
	    <void/>
	  </funcprototype>
	</funcsynopsis>
      </refsynopsisdiv>
      <refsection>
	<title>Description</title>
	<para>
	  The three functions described here are used whenever &oof2;
	  C++ code calls Python API functions that might invoke the
	  Python interpreter.  It's often difficult to tell when the
	  interpreter will be invoked, so it's a good idea to treat
	  <emphasis>all</emphasis> Python API calls in this way.  See
	  <ulink url="http://docs.python.org/ext/thinIce.html"
	  role="external"/> for a relevant discussion (although in a
	  different context).
	</para>
	<para>
	  Because the Python interpreter is not thread safe, whenever
	  a C++ function in &oof2; needs to call the Python API, it
	  must first acquire the Python global interpreter lock by
	  calling <function>acquirePyLock()</function>.  When it's
	  through with the Python API calls, it must release the lock
	  by calling <function>releasePyLock()</function>. 
	</para>
	<para>
	  A function that neglects to call
	  <function>acquirePyLock()</function> risks crashing the
	  Python interpreter.  A function that neglects to call
	  <function>releasePyLock</function> will probably deadlock
	  the program when the C++ routine finishes.  If running
	  &oof2; with the <link
	  linkend="CommandLineArg-unthreaded"><userinput>--unthreaded</userinput></link>
	  option solves a crashing or deadlocking problem, then check
	  the code for missing calls to
	  <function>acquirePyLock</function> and
	  <function>releasePyLock</function>.
	</para>
	<para>
	  It is important to ensure that
	  <function>releasePyLock</function> is called even if an
	  exception is thrown during the Python API calls.  Python API
	  calls should always occur within a <code>try
	  ... catch</code> block, like this:
	  <programlisting>
#include "common/threadstate.h"

   acquirePyLock();
   try {
      // Call Python API
   }
   catch (...) {
      releasePyLock();
      throw;
   }
   releasePyLock(); </programlisting>
	</para>
	<para>
	  It's possible that calls to the Python API will raise a
	  Python exception but <emphasis>not</emphasis> throw a C++
	  exception.  Generally, if a Python API function returns
	  <varname>NULL</varname>, an exception has been raised.  The
	  &oof2; function <function>pythonErrorRelay</function>
	  ensures that Python exceptions are re-raised in Python when
	  the C++ function exits.  It should be used like this:

	  <programlisting>
#include "common/ooferror.h"
#include "common/threadstate.h"

   acquirePyLock();
   try {
      PyObject *func, *args; // assume these have been set
      PyObject *result = PyEval_Call_Object(func, args); // for example 
      if(result == NULL) 
         pythonErrorRelay();
      // do something with result
   }
   catch (...) {
      releasePyLock();
      throw;
   }
   releasePyLock(); </programlisting>	  

	  <function>pythonErrorRelay</function> raises a C++ exception
	  that will be converted back into a Python exception when
	  control returns to Python.  The mechanism even works if the
	  Python exception was caused by a C++ exception that occurred
	  during a second call back into C++, as long as the original
	  C++ exception was derived from the &oof2; <link
	  linkend="Class-ErrError"><classname>ErrError</classname></link>
	  class.
	</para>
      </refsection>
    </refentry><!-- acquirePyLock -->

    <refentry id="Class-ErrError">
      <refnamediv>
	<refname>ErrError</refname>
	<refpurpose>Classes and functions for handling exceptions</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<title>Synopses</title>
	<refsect2>
	  <title>C++ Synopsis</title>
	  <programlisting>
#include "common/ooferror.h" </programlisting>
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname>ErrError</classname>
	    </ooclass>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>std::string</type>
	      <methodname>pythonequiv</methodname>
	      <void/>
	    </methodsynopsis>
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <type>std::string</type>
	      <methodname>message</methodname>
	      <void/>
	    </methodsynopsis>
	  </classsynopsis><!-- ErrError -->
	  <classsynopsis language="cpp">
	    <ooclass>
	      <modifier>template &lt;class E&gt;</modifier>
	      <classname>ErrErrorBase</classname>
	    </ooclass>
	    <ooclass>
	      <modifier>public</modifier>
	      <classname>ErrError</classname>
	    </ooclass>
	  </classsynopsis><!-- ErrErrorBase -->
	  <para>
	    The following subclasses are all derived from the
	    <classname>ErrErrorBase</classname> template, but the base
	    class has been omitted here for clarity.
	  </para>
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname><link linkend="Class-ErrProgrammingError">ErrProgrammingError</link></classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodname>ErrProgrammingError</methodname>
	      <methodparam>
		<type>const std::string&amp;</type>
		<parameter>filename</parameter>
	      </methodparam>
	      <methodparam>
		<type>int</type>
		<parameter>line</parameter>
	      </methodparam>
	    </constructorsynopsis>
	    <constructorsynopsis>
	      <methodname>ErrProgrammingError</methodname>
	      <methodparam>
		<type>const std::string&amp;</type>
		<parameter>message</parameter>
	      </methodparam>
	      <methodparam>
		<type>const std::string&amp;</type>
		<parameter>filename</parameter>
	      </methodparam>
	      <methodparam>
		<type>int</type>
		<parameter>line</parameter>
	      </methodparam>
	    </constructorsynopsis>
	  </classsynopsis><!-- ErrProgrammingError -->
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname><link linkend="Class-ErrIndexError">ErrIndexError</link></classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodname>ErrIndexError</methodname>
	      <methodparam>
		<type>const std::string&amp;</type>
		<parameter>message</parameter>
	      </methodparam>
	    </constructorsynopsis>
	  </classsynopsis><!-- ErrIndexError -->
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname><link linkend="Class-ErrUserError">ErrUserError</link></classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodname>ErrUserError</methodname>
	      <methodparam>
		<type>const std::string&amp;</type>
		<parameter>message</parameter>
	      </methodparam>
	    </constructorsynopsis>
	  </classsynopsis><!-- ErrUserError -->
	  <classsynopsis language="cpp">
	    <ooclass>
	      <classname><link linkend="Class-ErrSetupError">ErrSetupError</link></classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodname>ErrSetupError</methodname>
	      <methodparam>
		<type>const std::string&amp;</type>
		<parameter>message</parameter>
	      </methodparam>
	    </constructorsynopsis>
	  </classsynopsis><!-- ErrSetupError -->
	</refsect2><!-- C++ Synopsis -->
	<refsect2>
	  <title>Python Synopsis</title>
	  <programlisting>
from oof2.SWIG.common.ooferror import ErrProgrammingError
from oof2.SWIG.common.ooferror import ErrIndexError
from oof2.SWIG.common.ooferror import ErrUserError
from oof2.SWIG.common.ooferror import ErrSetupError </programlisting>
	  <classsynopsis language="python">
	    <ooclass>
	      <classname><link linkend="Class-ErrProgrammingError">ErrProgrammingError</link></classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodparam>
		<parameter>message</parameter>
	      </methodparam>
	      <methodparam>
		<parameter>filename</parameter>
	      </methodparam>
	      <methodparam>
		<parameter>line</parameter>
	      </methodparam>
	    </constructorsynopsis>
	  </classsynopsis><!-- ErrProgrammingError -->
	  <classsynopsis language="python">
	    <ooclass>
	      <classname><link linkend="Class-ErrPyProgrammingError">ErrPyProgrammingError</link></classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodparam>
		<parameter>message</parameter>
	      </methodparam>
	    </constructorsynopsis>
	  </classsynopsis><!-- ErrPyProgrammingError -->
	  <classsynopsis language="python">
	    <ooclass>
	      <classname><link linkend="Class-ErrIndexError">ErrIndexError</link></classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodparam>
		<parameter>message</parameter>
	      </methodparam>
	    </constructorsynopsis>
	  </classsynopsis><!-- ErrIndexError -->
	  <classsynopsis language="python">
	    <ooclass>
	      <classname><link linkend="Class-ErrUserError">ErrUserError</link></classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodparam>
		<parameter>message</parameter>
	      </methodparam>
	    </constructorsynopsis>
	  </classsynopsis><!-- ErrUserError -->
	  <classsynopsis language="python">
	    <ooclass>
	      <classname><link linkend="Class-ErrSetupError">ErrSetupError</link></classname>
	    </ooclass>
	    <constructorsynopsis>
	      <methodparam>
		<parameter>message</parameter>
	      </methodparam>
	    </constructorsynopsis>
	  </classsynopsis><!-- ErrSetupError -->
	  <programlisting>
<link linkend="Function-registerErrorClass">registerErrorClass</link>(exc_class)
</programlisting>
	</refsect2><!-- Python Synopsis -->
	<refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/common/ooferror.h</filename></simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/common/ooferror.C</filename></simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/common/ooferror.swg</filename></simpara>
	    </listitem>
	    <listitem>
	      <simpara><filename>SRC/common/ooferror.spy</filename></simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2>
      </refsynopsisdiv>
      <refsection>
	<title>Discussion</title>
	<para>
	  &oof2; predefines a number of useful exception classes for
	  handling errors, and includes a mechanism for adding new
	  classes.  The mechanism is non-trivial because exceptions
	  have to be able to pass back and forth between C++ and
	  Python.
	</para>
	<refsection>
	  <title>Predefined Exception Classes</title>
	  <para>
	    The following classes are all declared in
	    <filename>common/ooferror.h</filename>.  The Python
	    versions can be imported from
	    <code>oof2.SWIG.common.ooferror</code>.
	  </para>
	  <refsection id="Class-ErrProgrammingError">
	    <title><code>class ErrProgrammingError</code></title>
	    <para>
	      This exception indicates that an internal consistency
	      check failed.  Its constructor arguments are a message,
	      the name of the source file and the line number of the
	      code that raised the exception.  In C++, it's easily
	      called like this:
	      <programlisting>
throw ErrProgrammingError("Your message here", __FILE__, __LINE__);</programlisting>

	      In Python, it's easier to use <link
	      linkend="Class-ErrPyProgrammingError"><classname>ErrPyProgrammingError</classname></link>
	      instead.
	    </para>
	    <para>
	      Programming errors are usually fatal to the program.
	    </para>
	  </refsection><!-- ErrProgrammingError -->
	  <refsection id="Class-ErrPyProgrammingError">
	    <title><code>class ErrPyProgrammingError</code></title>
	    <para>
	      <classname>ErrPyProgrammingError</classname> is a Python
	      class derived from <link
	      linkend="Class-ErrProgrammingError"><classname>ErrProgrammingError</classname></link>.
	      It automatically sets the filename and line number
	      parameters by examining the Python traceback stack.  It
	      should be raised whenever an internal inconsistency is
	      detected in Python code.
	    </para>
	    <para>
	      Python programming errors are usually fatal to the
	      program.
	    </para>
	  </refsection><!-- ErrPyProgrammingError -->
	  <refsection id="Class-ErrIndexError">
	    <title><code>class ErrIndexError</code></title>
	    <para>
	      <classname>ErrIndexError</classname> indicates that an
	      array index is out of range.
	    </para> 
	  </refsection><!-- ErrIndexError -->
	  <refsection id="Class-ErrUserError">
	    <title><code>class ErrUserError</code></title>
	    <para>
	      <classname>ErrUserError</classname> indicates that the
	      user did something wrong.  The GUI should (and does)
	      prevent most user errors, but they can still occur if
	      the user loads a malformed script.  User errors should
	      not be fatal (either to the user or to the program).
	    </para>
	  </refsection><!-- ErrUserError -->
	  <refsection id="Class-ErrSetupError">
	    <title><code>class ErrSetupError</code></title>
	    <para>
	      An <classname>ErrSetupError</classname> is a particular
	      variety of <link linkend="Class-ErrUserError">user
	      error</link> indicating that the finite element system
	      being solved hasn't been defined properly.
	    </para>
	  </refsection>
	</refsection><!-- Predefined Exception Classes -->
	<refsection>
	  <title>Adding New Exception Classes</title>
	  <para>
	    In order for exceptions to propagate properly from C++ to
	    Python and back, all &oof2; exception classes must be
	    derived from <classname>ErrErrorBase</classname> in the
	    following way:
	    <programlisting>
class MyError : public ErrErrorBase&lt;MyError&gt; {
public:
  MyError();
  virtual std::string pythonequiv() const;
  virtual std::string message() const;
}; </programlisting>
	  </para>
	  <para>
	    Note that the template parameter is the name of the subclass!
	  </para>
	  <para>
	    The function <methodname>pythonequiv()</methodname> must
	    return a string that, when evaluated by the Python
	    interpreter, will create the equivalent exception in
	    Python. The <classname>MyError</classname> example above
	    would define it like this:
	    <programlisting>
std::string MyError::pythonequiv() const {
  return "NewError()";
} </programlisting>
	  </para>
	  <para>
	    The function <methodname>message</methodname> should
	    return a string indicating what caused the exception.
	  </para>
	  <para><anchor id="Function-registerErrorClass"/>
	    All new exception subclasses must be swigged, and the
	    Python function <function>registerErrorClass</function>
	    must be called with the swigged class as its argument.
	    (Exception classes declared in
	    <filename>SRC/common/ooferror.h</filename> and swigged in
	    <filename>SRC/common/ooferror.swg</filename> are exempt
	    from this requirement.)  For example, the
	    <classname>MyError</classname> class above would have a
	    swig file <filename>myerror.swg</filename> like this:
	    <programlisting>
%module myerror
%include "common/typemaps.swg"
%extern "common/ooferror.swg"
%{
#include "myerror.h"
%}

class MyError : public ErrError {
public:
  MyError();
  %addmethods {
    string __repr__() {
      return self->message();
    }
  }
};

%pragma(python) include="myerror.spy" </programlisting>

	    and <filename>myerror.spy</filename> would contain:
	    <programlisting>
from oof2.SWIG.common import ooferror
ooferror.registerErrorClass(MyError) </programlisting>
	  </para>
	  <para>
	    See <xref linkend="Section-Extending-swig"/> for more on
	    writing <application>swig</application> input files.
	  </para>
	  <para>
	    For more examples of &oof2; exception classes, see
	    <filename>SRC/engine/ooferror*</filename>.  (The
	    exceptions defined there have very specific internal uses
	    and shouldn't be used in &oof2; extensions, so they aren't
	    discussed here.)  Note that it's not possible to derive
	    new exceptions directly from <link
	    linkend="Class-ErrUserError"><classname>ErrUserError</classname></link>
	    or <link
	    linkend="Class-ErrProgrammingError"><classname>ErrProgrammingError</classname></link>
	    because the template parameter would be wrong.  New
	    exceptions must be derived from the intermediate classes
	    <classname>ErrUserErrorBase</classname> or
	    <classname>ErrProgrammingErrorBase</classname>, or
	    directly from <classname>ErrErrorBase</classname>.
	  </para>
	</refsection><!-- Adding New Exception Classes -->
      </refsection>
    </refentry>

    <refentry id="Function.advertise">
      <refnamediv>
	<refname>advertise</refname>
	<refpurpose>
	  announce the creation of &fields;, &fluxes;, and &equations;
	</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<title>Synopsis</title>
	<refsect2>
	  <title>Python</title>

	<programlisting>
from oof2.SWIG.engine.problem import advertise
advertise(obj) </programlisting>

	</refsect2>
	<refsect2>
	  <title>Source Files</title>
	  <itemizedlist spacing="compact">
	    <listitem>
	      <simpara><filename>SRC/engine/problem.py</filename></simpara>
	    </listitem>
	  </itemizedlist>
	</refsect2>
      </refsynopsisdiv>
      <refsection>
	<title>Description</title>
	<para>
	  <function>advertise</function> takes an already constructed
	  &field;, &flux;, or &equation; object and makes it available
	  for use in the graphical and text interfaces.
	</para>
      </refsection>
      <refsection>
	<title>Parameters</title>
	<variablelist>
	  <varlistentry>
	    <term><varname>obj</varname></term>
	    <listitem>
	      <para>
		A &field;, &flux;, or &equation; object.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </refsection>
    </refentry><!-- Function.advertise -->

    <refentry id="Function-conjugatePair">
      <refnamediv>
	<refname>conjugatePair</refname>
	<refpurpose>Establish conjugacy relations</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
	<title>Synopsis</title>
	<programlisting>
from oof2.SWIG.engine.conjugate import conjugatePair

conjugatePair(name, equation, eqncomp, field, fieldcomp) </programlisting>
      </refsynopsisdiv>
      <refsection>
	<title>Description</title>
	<para>
	  <function>conjugatePair</function> establishes conjugacy
	  relationships between &fields; and &equations;, allowing
	  symmetric finite element stiffness matrices to be
	  constructed.  See <xref
	  linkend="Section-Coding-Conjugates"/> for the detailed
	  discussion.
	</para>
	<para>
	  <function>conjugatePair</function> is only available in
	  Python.
	</para>
      </refsection>
      <refsection>
	<title>Parameters</title>
	<variablelist>
	  <varlistentry>
	    <term><varname>name</varname></term>
	    <listitem>
	      <para>
		<varname>name</varname> is the <link
		linkend="para-propertyType"><classname>PropertyType</classname></link>
		of the &property; that this conjugacy relation applies
		to.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><varname>equation</varname></term>
	    <listitem>
	      <para>
		<varname>equation</varname> is the <link
		linkend="Class-Equation"><classname>Equation</classname></link>
		object to which the conjugacy relationship applies.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><varname>eqncomp</varname></term>
	    <listitem>
	      <para>
		<varname>eqncomp</varname> is either a single <link
		linkend="Class-FieldIndex"><classname>FieldIndex</classname></link>
		object or a list of <link
		linkend="Class-FieldIndex"><classname>FieldIndex</classname></link>
		objects, indicating which components of
		<varname>equation</varname> the relation applies to.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><varname>field</varname></term>
	    <listitem>
	      <para>
		<varname>field</varname> is the <link
		linkend="Class-Field"><classname>Field</classname></link>
		object to which the conjugacy relationship applies.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><varname>fieldcomp</varname></term>
	    <listitem>
	      <para>
		<varname>fieldcomp</varname> is either a single <link
		linkend="Class-FieldIndex"><classname>FieldIndex</classname></link>
		object or a list of <link
		linkend="Class-FieldIndex"><classname>FieldIndex</classname></link>
		objects, indicating which components of
		<varname>field</varname> the relation applies to.
		<varname>fieldcomp</varname> must have the same
		structure as <varname>eqncomp</varname> &mdash; if
		<varname>eqncomp</varname> is a list,
		<varname>fieldcomp</varname> must be a list of the
		same length.  Each <classname>Field</classname>
		component in <varname>fieldcomp</varname> is conjugate
		to the <classname>Equation</classname> component in
		the same location in <varname>eqncomp</varname>.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </refsection>
    </refentry><!-- conjugatePair -->

  <refentry id="Function-xmlmenudump.loadFile">
    <refnamediv>
      <refname>loadFile</refname>
      <refpurpose>Specify an external file of documentation</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <title>Python Synopsis</title>
      <programlisting>
from oof2.common.IO.xmlmenudump import loadFile

loadFile(filename, func=None) </programlisting> 
    </refsynopsisdiv>
    <refsection>
      <title>Discussion</title>
      <para>
	Many &oof2; objects contain their own documentation.  The
	<link linkend="Chapter-Reference">reference section</link> of
	the &oof2; manual is generated automatically from the
	<varname>discussion</varname> data in menu items, <link
	linkend="Class-PropertyRegistration"><classname>PropertyRegistrations</classname></link>,
	<foreignphrase>etc</foreignphrase>.  Short
	<varname>discussions</varname> can be simple character
	strings, but longer discussions are more conveniently stored
	in separate files.  In those cases,
	<varname>discussion</varname> should be set to the return
	value of <code>loadFile(filename)</code>, where
	<varname>filename</varname> is the file containing the
	discussion.  The file must contain text that is suitable for
	inclusion in a <ulink url="http://www.docbook.org"
	role="external">DocBook</ulink>
	<literal>&lt;refentry&gt;</literal> element.<footnote>
	  <para>
	    The simplest such text would be a single paragraph
	    surrounded by <literal>&lt;para&gt;</literal> and
	    <literal>&lt;/para&gt;</literal> tags.
	  </para>
	</footnote>
      </para>
      <para>
	The <varname>func</varname> argument, if specified, should be
	a function that is called to preprocess the contents of the
	file before it's included in the manual.  The arguments to
	<varname>func</varname> are <varname>text</varname> (the
	contents of the file) and <varname>obj</varname> (the menu
	item or <classname>PropertyRegistration</classname> or other
	object being documented).
      </para>
      <para>
	The file specified by <function>loadFile</function> isn't
	actually read until the manual is built (using the command
	<xref linkend="MenuItem-OOF.Help.API_Listing"/>.)  That means
	that if you have no intention of building your own version of
	the manual, you can specify anything you want for the
	filename.  Of course, in that case you can also omit the
	<varname>discussions</varname> entirely as well.
      </para>
      <para>
	The given filename is assumed to be relative to the
	<filename>OOF2/MAN_OOF2</filename> directory.  Because of its
	size, this directory isn't included in the standard &oof2;
	distributions, so it will be difficult for extension authors
	to generate their own customized version of the manual.
	Please contact the &oof2; authors if you need a copy.
      </para>
    </refsection>
  </refentry>


<!-- Keep this comment at the end of the file
  Local variables:
  sgml-omittag:t
  sgml-shorttag:t 
  sgml-namecase-general:nil
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("../man_oof2.xml" "book" "chapter")
  sgml-exposed-tags:nil
  sgml-local-ecat-files:nil
  End:
-->
