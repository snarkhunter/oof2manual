<!-- 
  This software was produced by NIST, an agency of the
  U.S. government, and by statute is not subject to copyright in the
  United States.  Recipients of this software assume all
  responsibilities associated with its operation, modification and
  maintenance. However, to facilitate maintenance we ask that before
  distributing modified versions of this software, you first contact
  the authors at oof_manager@nist.gov.
-->

<!--
    TODO: Be consistent about whether args have names in the
    variablelist sections and have links in the the synopsis sections.

    TODO: Be consistent about typography in the section titles for
    class methods, across all coding reference files.
-->

<refentry id="Class-FluxProperty">
  <refnamediv>
    <refname>FluxProperty</refname>
    <refpurpose>A &Property; that contributes to a &Flux;</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Synopses</title>
    <refsect2>
	  <title>C++ Synopsis</title>
      <programlisting>
#include "engine/property.h" </programlisting>

      <classsynopsis language="cpp">
        <ooclass>
          <classname>FluxProperty</classname>
        </ooclass>
        <ooclass>
          <modifier>public</modifier>
          <classname><xref linkend="Class-PhysicalProperty"/></classname>
        </ooclass>
        
  	    <methodsynopsis>
	      <modifier>virtual</modifier>
          <type>void*</type>
          <methodname><link
	                      linkend="Class-FluxProperty-begin_point">begin_point</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-FEMesh"/>*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-Element"/></type>
		    <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-Flux"/>*</type>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-MasterPosition"/>&amp;</type>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <modifier>const</modifier>
	    </methodsynopsis>       <!-- begin_point -->
        
	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link linkend="Class-FluxProperty-end_point">end_point</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-FEMesh"/>*</type>
		    <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-Element"/>*</type>
		    <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-Flux"/>*</type>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-MasterPosition"/>&amp;</type>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type>void*</type>
            <parameter>data</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>       <!-- end_point -->

	    <methodsynopsis>
	      <modifier>virtual</modifier>
	      <void/>
	      <methodname><link linkend="Class-FluxProperty-flux_matrix">flux_matrix</link></methodname>
	      <methodparam>
            <modifier>const</modifier>
	        <type><xref linkend="Class-FEMesh"/>*</type>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
	        <type><xref linkend="Class-Element"/>*</type>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-ElementFuncNodeIterator"/>&amp;</type>
		    <parameter>node</parameter>
	      </methodparam>             
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-Flux"/>*</type>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
            <modifier>const</modifier>
		    <type><xref linkend="Class-MasterPosition"/>&amp;</type>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type>void*</type>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
	      <modifier>const</modifier>
	    </methodsynopsis>         <!-- flux_matrix -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link
                          linkend="Class-FluxProperty-flux_offset">flux_offset</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
			<type><xref linkend="Class-Flux"/>*</type>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type>void*</type>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>            
        </methodsynopsis>     <!-- flux_offset -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link linkend="Class-FluxProperty-flux_value">flux_value</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
			<type><xref linkend="Class-Flux"/>*</type>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type>void*</type>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>     <!-- flux_value -->

        <methodsynopsis>
          <modifier>virtual</modifier>
          <void/>
          <methodname><link linkend="Class-FluxProperty-static_flux_value">static_flux_value</link></methodname>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-FEMesh"/>*</type>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-Element"/>*</type>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
			<type><xref linkend="Class-Flux"/>*</type>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <modifier>const</modifier>
            <type><xref linkend="Class-MasterPosition"/>&amp;</type>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <type>double</type>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <type>void*</type>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <type><xref linkend="Class-SmallSystem"/>*</type>
            <parameter>linsys</parameter>
          </methodparam>
          <modifier>const</modifier>
        </methodsynopsis>     <!-- static_flux_value -->
      </classsynopsis>
    </refsect2>                 <!-- C++ FluxProperty Synopsis-->
    
    <refsect2 id="Class-PyFluxProperty" xreflabel="PyFluxProperty">
      <title>Python Synopsis</title>
      <para>
        <classname>PyFluxProperty</classname> is a swigged C++ class
        that is derived (in C++) from
        <classname>FluxProperty</classname>.  It is used as a base
        class for <classname>FluxProperties</classname> that are
        defined in Python.  When the methods listed below are called
        from C++, they use the Python C API to invoke methods in the
        Python derived class.
      </para>
      <programlisting>
from ooflib.SWIG.engine import pypropertywrapper </programlisting>
      <classsynopsis language="python">
        <ooclass>
          <classname>PyFluxProperty</classname>
        </ooclass>
        <ooclass>
          <classname>FluxProperty</classname>
        </ooclass>
        <methodsynopsis>
          <methodname><link linkend="Class-FluxProperty-begin_point">begin_point</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
        </methodsynopsis>       <!-- begin_point -->
        <methodsynopsis>
          <methodname><link linkend="Class-FluxProperty-end_point">end_point</link></methodname>
          <methodparam>
            <parameter>mesh</parameter>
          </methodparam>
          <methodparam>
            <parameter>element</parameter>
          </methodparam>
          <methodparam>
            <parameter>flux</parameter>
          </methodparam>
          <methodparam>
            <parameter>position</parameter>
          </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>data</parameter>
          </methodparam>
        </methodsynopsis>       <!-- end_point -->

	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-flux_matrix">flux_matrix</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>node</parameter>
	      </methodparam>             
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- flux_matrix -->        

	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-flux_offset">flux_offset</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- flux_offset -->        

	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-flux_value">flux_value</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- flux_value -->        

	    <methodsynopsis>
	      <methodname><link linkend="Class-FluxProperty-static_flux_value">static_flux_value</link></methodname>
	      <methodparam>
	        <parameter>mesh</parameter>
	      </methodparam>
	      <methodparam>
	        <parameter>element</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>flux</parameter>
	      </methodparam>
	      <methodparam>
		    <parameter>position</parameter>
	      </methodparam>
          <methodparam>
            <parameter>time</parameter>
          </methodparam>
          <methodparam>
            <parameter>data</parameter>
          </methodparam>
          <methodparam>
            <parameter>linsys</parameter>
          </methodparam>
	    </methodsynopsis>       <!-- static_flux_value -->        

      </classsynopsis>
    </refsect2>                 <!-- Python Synopsis-->

    <refsect2>
      <title>Source Files</title>
      <itemizedlist spacing="compact">
        <listitem>
          <simpara>
            <filename>SRC/engine/property.C</filename>: C++ code
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/property.h</filename>: C++ header
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/property.swg</filename>: SWIG source
            code
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/property.swg</filename>: Python code
            included in the SWIG output
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/pypropertywrapper.C</filename>: C++
            code for <classname>Properties</classname> implemented in
            Python
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/pypropertywrapper.h</filename>: C++
            header
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/pypropertywrapper.swg</filename>:
            SWIG source code
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <filename>SRC/engine/pypropertywrapper.spy</filename>:
            Python code inserted into the SWIG output.
          </simpara>
        </listitem>
      </itemizedlist>
    </refsect2> 
    
  </refsynopsisdiv>

  <refsection>
    <title>Overview</title>
    <para>
      A <classname>FluxProperty</classname> is &Property; that
      contributes to a &flux;.  For example, <link
      linkend="PropertyType-Elasticity"><literal>Elasticity</literal></link>
      contributes to <xref linkend="Flux-Stress"/>, and <link
      linkend="PropertyType-ThermalConductivity"><literal>ThermalConductivity</literal></link>
      contributes to <xref linkend="Flux-Heat_Flux"/>.  The principal
      job of the <classname>FluxProperty</classname> is to compute the
      coefficients of the &fields; and their time derivatives in a
      linear expansion of a &flux;, &sigma; in terms of a &Field; or
      &Fields;, &varphi;, and its spatial and time derivatives:
      <equation id="Eqn-flux1">
        <alt role="tex">
          \[
          \sigma =
          \sigma^0({\bf x})
          + {\cal A} ({\bf x}) \varphi
          + {\cal K} ({\bf x}) \nabla\varphi
          + {\cal D} ({\bf x}) \frac{\partial\varphi}{\partial t}
          + {\cal C} ({\bf x}) \frac{\partial\nabla\varphi}{\partial t}
          \]
        </alt>
      </equation>
      &sigma0; is an field-independent offset, to first order. The
      coefficients are written as functions of position, &boldx;, but
      &sigma0;, &Acal; and &Kcal; may be nonlinear functions of the
      &Fields; and their derivatives.  A future version of &oof2; may
      allow nonlinearities in &Ccal; and &Dcal; as well.
    </para>
    <para>
      A new subclass of <classname>FluxProperty</classname> must
      redefine at least one of the following four virtual methods:
      <itemizedlist>
        <listitem>
          <para>
            <link
            linkend="Class-FluxProperty-flux_matrix"><methodname>FluxProperty::flux_matrix()</methodname></link>
            computes the linearization of the &flux; at a given point
            in an &elem;, as a function of the relevant &fields;,
            their gradients, and possibly their time derivatives.
            That is, it determines the coefficients &Acal;, &Kcal;,
            &Dcal;, and &Ccal; in Eqn. <xref linkend="Eqn-flux1"/>.
          </para>
          <para>
            &Acal; and &Kcal; are used to compute the Jacobian if the
            property is nonlinear and the solver requires it.
          </para>
        </listitem>
        <listitem>
          <para>
            <link
            linkend="Class-FluxProperty-flux_offset"><methodname>FluxProperty::flux_offset()</methodname></link>
            computes the value of the &flux; at a given point in an
            &elem; when the &fields; and their gradients are zero.
            This is &sigma0; in <xref linkend="Eqn-flux1"/>.
          </para>
        </listitem>
        <listitem>
          <para>
            <link
            linkend="Class-FluxProperty-flux_value"><methodname>FluxProperty::flux_value()</methodname></link>
            computes the actual value of the &flux; at a given point
            in an &elem;.  If the &property; is linear in the
            &fields;, <methodname>flux_value()</methodname> does not
            need to be redefined, since the &flux; value can be
            deduced from <methodname>flux_matrix()</methodname> and
            <methodname>flux_offset()</methodname>.
          </para>
        </listitem>
        <listitem>
          <para>
            <link
            linkend="Class-FluxProperty-static_flux_value"><methodname>static_flux_value()</methodname></link>
            computes the part of the &flux; value that depends only on
            the &fields; and not on their time derivatives, if the
            &flux; depends on the &field; derivatives.
          </para>
        </listitem>
      </itemizedlist>
      The functions listed above all have a <xref
      linkend="Class-SmallSystem"/>* argument, which represents a
      small part of the <link
      linkend="Class-LinearizedSystem"><classname>LinearizedSystem</classname></link>
      that is currently being built.
      <classname>SmallSystem</classname> methods handle all of the
      issues related to matrix indexing, element order, and so forth.
      The derived <classname>FluxProperty</classname> methods (and the
      developer) do not need to know anything about what equations are
      being solved or how they are discretized by the finite element
      machinery.  Details on all of the functions are provided below.
    </para>
    <para>
      In addition, two virtual utility functions, <link
      linkend="Class-FluxProperty-begin_point"><methodname>begin_point()</methodname></link>
      and <link
      linkend="Class-FluxProperty-end_point"><methodname>end_point()</methodname></link>
      can be redefined to facilitate passing data between the other
      routines.
    </para>
  </refsection>               <!-- FluxProperty Overview -->
  
  <refsection>
    <title>Constructor</title>
    <para>
      The C++ and Python constructors for
      <classname>FluxProperty</classname> are the same as the <link
      linkend="Class-Property-Constructors">base class
      constructors</link>.
    </para>
  </refsection>

  <refsection>
    <title>Methods</title>

    <refsection id="Class-FluxProperty-begin_point">
	  <title><code>void* begin_point(...) const</code></title>
      <programlisting>
void* begin_point(const <xref linkend="Class-FEMesh"/>* mesh,
                  const <xref linkend="Class-Element"/>* element,
                  const <xref linkend="Class-Flux"/>* flux,
                  const <xref linkend="Class-MasterPosition"/>&amp; position,
                  double time) const </programlisting>
	  <para>
        When building the finite element matrices and vectors, &oof2;
        loops over the Gauss points within each &elem;.  At each Gauss
        point, and for each active &flux;, it calls
        <classname>FluxProperty</classname> methods for each
        &Property; that contributes to the &flux;, beginning with
        <function>begin_point()</function>, followed by <link
        linkend="Class-FluxProperty-flux_matrix"><function>flux_matrix()</function></link>,
        <link
        linkend="Class-FluxProperty-flux_offset"><function>flux_offset()</function></link>,
        and (sometimes) <link
        linkend="Class-FluxProperty-flux_value"><function>flux_value()</function></link>,
        and ending with <link
        linkend="Class-FluxProperty-end_point"><function>end_point()</function></link>.

        To avoid recomputing quantities that are required by more than
        one of these methods, computations can be done in
        <function>begin_point()</function> and their results stored in
        a data structure. <function>begin_point()</function> should
        return this structure (as a <code>void*</code> pointer in C++
        or an object in Python). The data structure will be passed
        through to the other <classname>FluxProperty</classname>
        methods.  If the data object was allocated in C++,
        <function>end_point()</function> should delete it.
	  </para>
      <para>
        The data returned by <function>begin_point()</function> is not
        stored or transmitted to any parts of &oof2; other than the
        <classname>FluxProperty</classname> methods discussed here.
        If no data needs to be transmitted,
        <function>begin_point()</function> should return
        <code>nullptr</code> in C++ or <code>None</code> in Python.
      </para>
      <para>
        The arguments to <function>begin_point()</function> are:
        <variablelist>
          <varlistentry>
            <term><code>const <link
            linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
            <listitem>
              <para>
                The <classname><xref
                linkend="Class-FEMesh"/></classname> currently being
                solved.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <xref linkend="Class-Element"/>* element</code></term>
            <listitem>
              <para>
                The <link
                linkend="Class-Element"><classname>Element</classname></link>
                containing the current point.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <xref linkend="Class-Flux"/>* flux</code></term>
            <listitem>
              <para>
                The &flux; that this &Property; computes.  If the
                &Property; computes more than one &flux;,
                <function>begin_point</function> will be called once
                for each &flux; at each point.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>const <link
            linkend="Class-MasterPosition">MasterPosition</link>&amp;
            point</code></term>
            <listitem>
              <para>
                The position within the <link
                linkend="Class-Element"><classname>Element</classname></link>
                where the &Property; is being evaluated.  The position
                is given in <link
                linkend="Class-MasterPosition">master
                coordinates</link>, which can be converted to physical
                coordinates by <link
                linkend="Class-Element-from_master"><function>Element::from_master()</function></link>
                if necessary.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>double time</code></term>
            <listitem>
              <para>
                The time at which the &Property; is being evaluated.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
      <para>
        The default implementation of
        <function>begin_point()</function> simply returns
        <constant>nullptr</constant> in C++ and
        <constant>None</constant> in Python.
      </para>
    </refsection>               <!-- begin_point -->
  
    <refsection id="Class-FluxProperty-end_point">
	  <title><code>void end_point(...) const</code></title>
      <programlisting>
void end_point(const <link linkend="Class-FEMesh">FEMesh</link>* mesh,
               const <link linkend="Class-Element">Element</link>* element,
               const <link linkend="Class-Flux">Flux</link>* flux,
               const <link linkend="Class-MasterPosition">MasterPosition</link>&amp; position,
               double time,
               void* data) const </programlisting>
	  <para>
	    <function>end_point()</function> is just like <link
	    linkend="Class-Property-end_point"><function>begin_point()</function></link>,
	    except that it's called <emphasis>after</emphasis> &oof2; is
	    done computing the contribution at a point.  The
	    <function>end_point()</function> method can be used to clean
	    up any temporary objects allocated by <link
	    linkend="Class-Property-end_point"><methodname>begin_point</methodname></link>.
	  </para>
      <para>
        The arguments for <function>end_point()</function> are the same
        as the arguments for <methodname><link
        linkend="Class-Property-end_point">begin_point()</link></methodname>,
        with the addition of a <code>void*</code> which points to the
        data returned by <link
	    linkend="Class-Property-end_point"><methodname>begin_point</methodname></link>.
      </para>
      <para>
        The default implementation of <function>end_point()</function>
        does nothing.
      </para>
    </refsection>               <!-- end_point -->
    
    <refsection id="Class-FluxProperty-flux_matrix">
	  <title><code>void flux_matrix(...) const</code></title>
      <programlisting>
void flux_matrix(const <link linkend="Class-FEMesh">FEMesh</link>* mesh,
                 const <link linkend="Class-Element">Element</link>* element,
                 const <link
                 linkend="Class-ElementFuncNodeIterator">ElementFuncNodeIterator</link>&amp; node,
                 const <link linkend="Class-Flux">Flux</link>* flux,
                 const <link
                 linkend="Class-MasterPosition">MasterPosition</link>&amp; position,
                 double time,
                 void* data,
                 <link linkend="Class-SmallSystem">SmallSystem</link>* linsys) const </programlisting>
	  <para>
	    <classname>FluxProperty</classname> subclasses that represent
	    the &Acal;, &Kcal;, &Dcal; or &Ccal; terms in the constitutive
	    equation <xref linkend="Eqn-flux1"/> must redefine the virtual
	    function <methodname>FluxProperty::flux_matrix()</methodname>.
	    <methodname>flux_matrix()</methodname> computes a matrix that,
	    when multiplied by a vector of degrees of freedom and/or their
	    time derivatives, produces a vector containing the components
	    of a &flux;.  Explaining this properly requires a brief review
	    of the finite element machinery.
	  </para>
	  <para>
        <anchor id="fluxmatrix_discussion"/>
	    Let

        <inlineequation>
	      <alt role="tex">\(\varphi_k({\bf x})\)</alt>
	    </inlineequation>

	    be the

        <inlineequation>
          <alt role="tex">\(k^\mathrm{th}\)</alt>
        </inlineequation>

	    component of a field &varphi; at position &boldx;.  If the
	    field values are known at nodes &nu;, which are at positions

	    <inlineequation>
          <alt role="tex">
            \({\bf x}_\nu\)
          </alt>
	    </inlineequation>,
        
        then the finite element shape functions

	    <inlineequation>
	      <alt role="tex">
            \(N_\nu({\bf x})\)
          </alt>
	    </inlineequation>
          
	    can be used to approximate the field at &boldx;:<footnote
	    id="summation"><para> We are using the convention that
	    repeated indices, such as &nu; in <xref
	    linkend="Eqn-Property-expansion"/> are implicitly summed:
	    <inlineequation><alt role="tex">\(x_i y_i\equiv \sum_i x_i
	    y_i\)</alt></inlineequation></para></footnote>
        
	    <equation id="Eqn-Property-expansion">
	      <alt role="tex">
            \[\varphi_k({\bf x}) = N_\nu({\bf x}) \varphi_{k\nu}\]
          </alt>
	    </equation>

	    where
          
	    <inlineequation>
	      <alt role="tex">
            \(N_\nu({\bf x})\)
          </alt>
	    </inlineequation>
          
	    is the shape function that is 1 at node &nu; and 0 at all
	    other nodes, and

	    <equation>
	      <alt role="tex">
            \[\varphi_{k\nu}\equiv \varphi_k({\bf x_\nu})\]
          </alt>
        </equation>

        is the

        <inlineequation>
          <alt role="tex">\(k^\mathrm{th}\)</alt>
        </inlineequation>

        component of the field at node &nu;.  Similarly, the gradient
        of the field is

        <equation id="Eqn-Property-expansion-deriv">
          <alt role="tex">
            \[
            \nabla\varphi =
            \frac{\partial\varphi_k({\bf x})}{\partial{\bf x}} =
            \frac{\partial N_\nu({\bf x})}{\partial{\bf x}} \varphi_{k\nu}.
            \]
          </alt>
        </equation>
        
        Because &oof2; does its computations in 2D, gradients include
        only <emphasis>x</emphasis> and <emphasis>y</emphasis>
        derivatives, unless explicitly stated otherwise.
 	  </para>
	  <para>
        Temporarily ignoring the &varphidot; terms, a constitutive
        relation connects a &field; &varphi; and its gradient,
        &gradphi;, to a &flux; &sigma;, through moduli &Acal; and
        &Kcal;, and an offset, &sigma0;:

        <equation id="Eqn-constitutive">
          <alt role="tex">
            \[
            \sigma =
            \sigma^0 +
            \mathcal{A} \cdot \varphi +
            \mathcal{K} \cdot \nabla\varphi.
            \]
          </alt>
        </equation>

        This is the linearization of a more general relation.  &Acal;,
        &Kcal; and &sigma0; may all be functions of &boldx;, &varphi;,
        &gradphi;, or time.  (&sigma0; must not have any linear
        dependence on &varphi; or &gradphi;, though, because then it
        would be part of &Acal; or &Kcal;.)
      </para>
      <para>
        <xref linkend="Eqn-constitutive"/> can be written as a matrix
        equation:
        
	    <equation id="Eqn-Property-flux">
	      <alt role="tex">
	        \[
            \sigma_i =
            \sigma^0_i + 
            \mathcal{A}_{ik} \cdot \varphi_k +
            \mathcal{K}_{ijk} \cdot \nabla_j\varphi_k
            \]
	      </alt>
	    </equation>
        (repeated indices are summed).  The index &texi; is a flux
        component, &texj; is a space component, and &texk; is a field
        component.  Inserting <xref linkend="Eqn-Property-expansion"/>
        and <xref linkend="Eqn-Property-expansion-deriv"/> into <xref
        linkend="Eqn-Property-flux"/>

        <equation id="Eqn-Property-fluxmtx">
          <alt role="tex">
            \begin{align*}
            \sigma_i
            &amp;=
            \mathcal{A}_{ik} N_\nu({\bf x}) \varphi_{k\nu}
            +
            \mathcal{K}_{ijk}
            \frac{\partial N_\nu}{\partial{\bf x}_j} \varphi_{k\nu}
            +
            \sigma^0_i \\
            &amp;=
            \left[
               \mathcal{A}_{ik} N_\nu({\bf x}) +
               \mathcal{K}_{ijk} \frac{\partial N_\nu}{\partial{\bf x}_j}
             \right] \varphi_{k\nu} +
             \sigma^0_i \\
             \end{align*}
          </alt>
        </equation>
        
        shows that the vector of flux values &sigma; at &boldx; is
        related to the vector of field values &varphi; at the nodes by
        a matrix we call the <emphasis>flux matrix</emphasis>:

        <equation id="Eqn-flux-matrix">
          <alt role="tex">
            \[
            {\bf K}_{ik\nu} =
            \mathcal{A}_{ik}({\bf x})N_\nu + 
            \mathcal{K}_{ijk}
            \frac{\partial N_\nu}{\partial{\bf x}_j}
            \]
          </alt>
        </equation>

        and an offset &sigma0;.  The columns of &Kmatrix; correspond
        to field values

        <inlineequation>
	      <alt role="tex">\(\varphi_{k\nu}\)</alt>
        </inlineequation>

        and the rows to flux components
        
        <inlineequation>
          <alt role="tex">
            \(\sigma_i({\bf x})\)
	      </alt>
          </inlineequation>.

          &Kmatrix; is a part of what is generally called the
          <emphasis>stiffness matrix</emphasis>.
      </para>
      <para>
        Computing &Kmatrix; <xref linkend="Eqn-flux-matrix"/> is the
        purpose of <function>FluxProperty::flux_matrix()</function>.
        On each call, <function>flux_matrix()</function> must make
        contributions to &Kmatrix; for all of the components of a
        given flux, all of the components of the relevant fields
        &varphi; (and their out-of-plane parts), and one given node
        &nu;.
	  </para>

      <para>
        The <link
        linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>
        object that is passed in to <function>flux_matrix</function>
        is a container for the various matrices that &Properties;
        compute.  <function>flux_matrix()</function> contributes to
        &Kmatrix; by calling <link
        linkend="Class-SmallSystem-stiffness_matrix_element"><methodname>SmallSystem::stiffness_matrix_element()</methodname></link>,
        as shown in the example <link
        linkend="example-fluxmatrix">below</link>.
      </para>
      <para>
        Similarly, if the &flux; depends on the time derivative of the
        &field;, &varphidot;, or its gradient, &gradphidot;, through
        moduli &Dcal; and &Ccal; respectively, then
        <function>flux_matrix()</function> must also compute a
        <emphasis>damping matrix</emphasis>:

        <equation id="Eqn-damping-matrix">
          <alt role="tex">
            \[
            {\bf C}_{ik\nu} =
            \mathcal{D}_{ik}({\bf x})N_\nu + 
            \mathcal{C}_{ijk}({\bf x})
            \frac{\partial N_\nu}{\partial{\bf x}_j}
            \]
          </alt>
        </equation>

        It stores its results by calling <link
        linkend="Class-SmallSystem-damping_matrix_element"><methodname>SmallSystem::damping_matrix_element()</methodname></link>.

        &oof2; currently does not allow nonlinearities in the time
        derivative terms, so &Dcal; and &Ccal; cannot depend on the
        &Fields;, but they can be functions of position.
      </para>

	  <para>
	    Note that it is <emphasis>not</emphasis> necessary for the
	    <function>flux_matrix()</function> routine (or its author) to
	    know anything about the following:
        <itemizedlist spacing="compact">
          <listitem>
            <para>
              The topology or number of nodes in the element.
            </para>
          </listitem>
          <listitem>
            <para>
              How nodal degrees of freedom are mapped into columns of
              the matrix.
            </para>
          </listitem>
          <listitem>
            <para>
              How flux components are mapped into rows of the matrix.
            </para>
          </listitem>
          <listitem>
            <para>
              What equations are being solved.
            </para>
          </listitem>
        </itemizedlist>
	  </para>
	  <para>
	    The arguments to <function>flux_matrix()</function> are:
	    <variablelist>
	      <varlistentry>
	        <term><code>const <link linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
	        <listitem>
		      <para>
		        The finite element mesh that's being solved.
		        <function>flux_matrix()</function> probably doesn't
		        have to use the <varname>mesh</varname> object
		        directly, but it does need to pass it through to other
		        functions.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code>const <link linkend="Class-Element">Element</link>* element</code></term>
	        <listitem>
		      <para>
		        The finite <link
		        linkend="Class-Element">element</link> under
		        consideration.  This shouldn't be explicitly needed
		        except in cases in which the material parameters
		        depend on physical space coordinates, or if
		        history-dependent fields are stored in the element.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code>const <link
	        linkend="Class-ElementFuncNodeIterator">ElementFuncNodeIterator</link>&amp; node</code></term>
	        <listitem>
		      <para>
		        This is the node &nu; referred to in the discussion
		        <link linkend="fluxmatrix_discussion">above</link>.
		        It's passed in in the form of an iterator, which can
		        iterate over all of the nodes of the element, although
		        it should be thought of here simply as a way of
		        accessing the node's indices and shape
		        functions.<footnote id="node-as-iterator"><simpara>
		        It's not possible to use a <link
		        linkend="Class-Node"><classname>Node</classname></link>
		        instead of an <link
		        linkend="Class-ElementFuncNodeIterator"><classname>ElementFuncNodeIterator</classname></link>
		        here.  <classname>Nodes</classname> are unable to
		        evaluate shape functions because they don't know which
		        <link
		        linkend="Class-Element"><classname>Element</classname></link>
		        is being computed.
		        <classname>ElementFuncNodeIterators</classname> know
		        which <classname>Element</classname> they're looping
		        over.</simpara></footnote> The node's shape function
		        and its derivatives can be obtained from <link
		        linkend="Class-ElementShapeFuncIterator-shapefunction"><methodname>ElementFuncNodeIterator::shapefunction()</methodname></link>
		        and <link
		        linkend="Class-ElementShapeFuncIterator-dshapefunction"><methodname>ElementFuncNodeIterator::dshapefunction()</methodname></link>.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code>const <link linkend="Class-Flux">Flux</link>*
	        flux</code></term>
	        <listitem>
		      <para>
		        The &flux; &sigma;.  Properties that contribute to
		        more than one &flux; need to check this variable to
		        know which flux they're computing now.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term><code>const <link
	        linkend="Class-MasterPosition">MasterPosition</link>&amp; position</code></term>
	        <listitem>
		      <para>
                This is the position &boldx; in <xref
                linkend="Eqn-Property-fluxmtx"/>.
                <varname>position</varname> is a point in
                <varname>element</varname>'s <link
                linkend="Class-Element"><classname>Element</classname></link>'s
                <link linkend="Class-MasterPosition">master coordinate
                space</link>.  It is often a Gauss integration point,
                but not always.  Master coordinates can be converted
                to physical coordinates by calling <link
                linkend="Class-Element-from_master"><function>Element::from_master()</function></link>.
		      </para>
	        </listitem>
	      </varlistentry>
          <varlistentry>
            <term><code>double time</code></term>
            <listitem>
              <para>
                The time at which the flux matrix is being evaluated.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>void* data</code></term>
            <listitem>
              <para>
                The data object, if any, returned by <link linkend="Class-FluxProperty-begin_point"><function>begin_point()</function></link>.
              </para>
            </listitem>
          </varlistentry>
	      <varlistentry>
	        <term>
              <code><link linkend="Class-SmallSystem">SmallSystem</link>*
	          linsys</code>
            </term>
	        <listitem>
		      <para>
		        The <link
		        linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>
		        class stores the portion of the the actual flux matrix
		        &Kmatrix; and damping matrix &Cmatrix; that are
		        currently being computed, along with other flux
		        data.<footnote><para>This data can't be stored
		        directly in the &Flux; object because one &Flux; is
		        shared among many &FEMesh;es.  The <link
		        linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>
		        object is local to this computation.</para></footnote>
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
      
      <refsection id="example-fluxmatrix">
        <title>Example of <function>flux_matrix()</function></title>
	    <para>
	      For example, for <link
	      linkend="Property-Thermal-Conductivity-Anisotropic-Cubic">thermal
	      conductivity</link> the field &varphi; is the temperature T,
	      and the heat flux is the vector

          <inlineequation>
            <alt role="tex">
              \({\bf J}\)
            </alt>
          </inlineequation>:

          <equation id="Eqn-ThermalFlux">
            <alt role="tex">
              \[
              {\bf J}_i({\bf x}) = -\kappa_{ij} \nabla_jT({\bf x}) -
              \kappa_{iz} T_z
              \]
            </alt>
          </equation>

          The <emphasis>z</emphasis> component in <xref
          linkend="Eqn-ThermalFlux"/> has been separated out because,
          as explained in <xref linkend="Section-Concepts-Mesh-3D"/>,
          the <emphasis>z</emphasis> derivatives of &fields; are
          treated differently from the <emphasis>x</emphasis> and
          <emphasis>y</emphasis> derivatives in &oof2;.

          <inlineequation>
            <alt role="tex">
              \(T_z \equiv \partial T/\partial z \)
            </alt>
          </inlineequation>

          is treated as a separate scalar &field;, and is only present
          if <varname>Temperature</varname> is not in-plane.  Because
          gradients of

          <inlineequation>
            <alt role="tex">
              \(T_z\)
            </alt>
          </inlineequation>

          don't appear in <xref linkend="Eqn-ThermalFlux"/>, it is
          treated as part of the &Acal; term in <xref
          linkend="Eqn-flux-matrix"/>.
        </para>
        <para>
          Expanding the fields and derivatives in terms of the shape
          functions via <xref linkend="Eqn-Property-expansion"/> and
          <xref linkend="Eqn-Property-expansion-deriv"/>,
        
	      <equation>
	        <alt role="tex">
	          \begin{align*}
              {\bf J}_i
              &amp;= -\kappa_{ij} \frac{\partial}{\partial{\bf x}_j}
              (T_\nu N_\nu({\bf x}))
              -\kappa_{iz}T_{z\nu}N_\nu({\bf x})
              \\
              &amp;= -\left(\kappa_{ij}
              \frac{\partial N_\nu({\bf x})}{\partial {\bf x}_j}\,
              \right) T_\nu
              -\left(\kappa_{iz}N_\nu({\bf x})\right) T_{z\nu}
              \\
              \end{align*} 
	        </alt>
          </equation>

	      from which we get
            
	      <equation id="Eqn-Property-K">
	        <alt role="tex">
              \[
	          {\bf K}_{i\nu} = -\kappa_{ij}
              \frac{\partial N_\nu({\bf x})}{\partial {\bf x}_j}
	          \]
	        </alt>
	      </equation>

          for <inlineequation><alt role="tex">\(T\)</alt></inlineequation>
          and

          <equation id="Eqn-Property-Kp">
            <alt role="tex">
              \[
              {\bf K}_{z\nu} = -\kappa_{iz}N_\nu({\bf x})
              \]
            </alt>
          </equation>

          for <inlineequation><alt
          role="tex">\(T_z\)</alt></inlineequation>.  Note that there
          is no <inlineequation><alt
          role="tex">\(k\)</alt></inlineequation> index because
          <varname>Temperature</varname> is a scalar.
	    </para>
        <para>
          Here is the <methodname>fluxmatrix</methodname> routine for
          the <classname>HeatConductivity</classname> class, from
          <filename>SRC/engine/properties/heatconductivity/heatconductivity.C</filename>
          in the &oof2; source code:
	    </para>

        <programlisting>
void HeatConductivity::flux_matrix(const FEMesh  *mesh,
                                   const Element *el,
                                   const ElementFuncNodeIterator &amp;nu,
                                   const Flux *flux,
                                   const MasterPosition &amp;position,
                                   double time,
                                   void* data,
                                   SmallSystem *linsys) const
{
  if (*flux != *heat_flux) { <co id="flux_matrix-test"/>
    throw ErrProgrammingError("Unexpected flux", __FILE__, __LINE__); <co id="flux_matrix-error"/>
  }

  double sf   = nu.shapefunction(position); <co id="flux_matrix-shapefun"/>
  double dsf0 = nu.dshapefunction(0, position); <co id="flux_matrix-dshapefun"/>
  double dsf1 = nu.dshapefunction(1, position); <coref linkend="flux_matrix-dshapefun"/>

  const SymmMatrix3 cond(conductivitytensor(mesh, el, position)); <co id="flux_matrix-modulus"/>

  for(IndexP i : *flux->components(ALL_INDICES)) { <co id="flux_matrix-loop"/>
     <co id="flux_matrix-fieldcomps"/>
    // in-plane temperature gradient contributions
    linsys->stiffness_matrix_element(i, temperature, nu) -= <co id="flux_matrix-temperature"/> <co id="flux_matrix-mat"/>
        cond(i, 0) * dsf0 +  <co id="fmtx_indexing"/><co id="flux_matrix-K"/>
        cond(i, 1) * dsf1;   <coref linkend="fmtx_indexing"/><coref linkend="flux_matrix-K"/>

    // out-of-plane temperature gradient contribution
    if(!temperature->in_plane(mesh)) <co id="flux_matrix-oopcheck"/>
      <coref linkend="flux_matrix-fieldcomps"/>
      linsys->stiffness_matrix_element(i, temperature->out_of_plane(), nu) <co id="flux_matrix-oop"/>
              -= cond(i, 2) * sf; <coref linkend="fmtx_indexing"/><co id="flux_matrix-Kp"/>
  }
} 
        </programlisting>
        <calloutlist>
          <callout arearefs="flux_matrix-test">
            <para>
              We don't really need to do this.  It's a sanity check to
              make sure that we got the &flux; we wanted.
              <varname>heat_flux</varname> is a protected data member of
              <classname>HeatConductivity</classname> and was set in
              the constructor by calling <code><link
              linkend="Function-getFlux">Flux::getFlux</link>("Heat_Flux")</code>
              and dynamically casting the result to a
              <classname>VectorFlux*</classname>.  If a Property makes
              contributions to more than one &Flux; then a statement
              like this must used to determine which flux it is being
              asked to compute.
            </para>
          </callout>
          <callout arearefs="flux_matrix-error">
            <para>
              <link
              linkend="Class-ErrProgrammingError"><classname>ErrProgrammingError</classname></link>
              is declared in
              <filename>SRC/common/ooferror.h</filename>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-shapefun">
            <para>
              Here is where the shape functions are evaluated.  This
              is <inlineequation><alt
              role="tex">\(N_\nu\)</alt></inlineequation>.  Shape
              function values are precomputed and cached at the Gauss
              integration points, so the evaluation here is fast.
            </para>
          </callout>
          <callout arearefs="flux_matrix-dshapefun">
            <para>
              These are the derivatives of the shape functions.  The
	          first argument is the component of the
	          gradient. <literal>0</literal> is <emphasis>x</emphasis>
	          and <literal>1</literal> is <emphasis>y</emphasis>.
	          These values are also cached at Gauss points.
            </para>
          </callout>
          <callout arearefs="flux_matrix-modulus">
            <para>
	          <function>conductivity_tensor()</function> is a virtual function
	          defined in the <classname>HeatConductivity</classname>
	          subclasses.  It takes <classname>FEMesh*</classname>,
	          <classname>Element*</classname>, and
	          <classname>MasterPosition&amp;</classname> arguments so
	          that a subclass can define a position-dependent modulus,
	          or something even more bizarre.
            </para>
          </callout>
          <callout arearefs="flux_matrix-loop">
            <para>
              Note that this loop is over all components of the
              &Flux;.  When solving a <link
              linkend="Section-Concepts-Mesh-plane-flux">plane-flux</link>
              problem, the out-of-plane coefficients in &Kmatrix; are
              used to generate the constraint equations. Looping over
              the components of a &Field; or &Flux; is discussed in
              <xref linkend="Section-Coding-Indices"/>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-fieldcomps">
            <para>
              If the field weren't a scalar, there would be a loop
              over its components here.
            </para>
          </callout>
          <callout arearefs="flux_matrix-temperature">
            <para>
              <varname>temperature</varname> is a variable stored in
              the <classname>HeatConductivity</classname> class and
              initialized by calling <code><link
              linkend="Function-getField">Field::getField</link>("Displacement")</code>
              in the <classname>HeatConductivity</classname>
              constructor.
            </para>
          </callout>
          <callout arearefs="flux_matrix-mat">
            <para>
              <link linkend="Class-SmallSystem-stiffness_matrix_element">
	          <methodname>SmallSystem::stiffness_matrix_element()</methodname>
              </link> retrieves a C++ reference to the matrix element
	          that couples flux component <varname>i</varname> to the
	          <varname>temperature</varname> field at node
	          <varname>nu</varname>.
              Note that we use <code>-=</code>
	          instead of <code>=</code> because a previous call to
	          <methodname>fluxmatrix</methodname> may already have
	          addressed this matrix element.
            </para>
          </callout>
          <callout arearefs="fmtx_indexing">
            <para>
              Here the <classname>IndexP</classname>,
              <varname>i</varname>, is implicitly converted to an
              integer when passed to <link
              linkend="Class-SymmMatrix3-call"><code>SymmMatrix3::operator(int, int)</code></link>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-K">
            <para>
              This is <xref linkend="Eqn-Property-K"/>, summing over
              <inlineequation><alt
              role="tex">\(j\)</alt></inlineequation>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-oopcheck">
            <para>
              This checks to see if the temperature field has an
              <link
              linkend="Section-Concepts-Mesh-3D">out-of-plane</link>
              part.  If it does, its contribution to the stress is
              computed.
            </para>
          </callout>
          <callout arearefs="flux_matrix-oop">
            <para>
	          This retrieves a reference to the matrix element
	          coupling the <link
	          linkend="Section-Concepts-Mesh-3D">out-of-plane</link>
	          part of the Temperature &field; to flux component
	          <inlineequation><alt
	          role="tex">\(i\)</alt></inlineequation>.
            </para>
          </callout>
          <callout arearefs="flux_matrix-Kp">
            <para>
              This is <xref linkend="Eqn-Property-Kp"/>.
            </para>
          </callout>
        </calloutlist>
      </refsection>             <!--flux_matrix example-->
    </refsection>               <!-- flux_matrix -->


    <refsection id="Class-FluxProperty-flux_offset">
	    <title><code>void flux_offset(...) const</code></title>
        <programlisting>
void flux_offset(const <link linkend="Class-FEMesh">FEMesh</link>* mesh,
                 const <link linkend="Class-Element">Element</link>* element,
                 const <link linkend="Class-Flux">Flux</link>* flux,
                 const <link linkend="Class-MasterPosition">MasterPosition</link>&amp; position,
                 double time,
                 void* data,
                 <link linkend="Class-SmallSystem">SmallSystem</link> *linysys) const </programlisting>
	    <para>
          <methodname>FluxProperty::flux_offset()</methodname>
          computes the &sigma0; term in <xref linkend="Eqn-flux1"/>.
          It is the value of the linearized &flux; when the &fields;
          are zero.  It is similar in purpose to <link
          linkend="Class-Property-flux_matrix"><methodname>FluxProperty::flux_matrix()</methodname></link>,
          but generally simpler to implement.
        </para>
        <para>
          Because &sigma0; is not proportional to a &field; or its
          gradient, <function>flux_offset()</function> does not have
          to worry about expansions and shape functions.  It just
          computes the value of &sigma0; and stores it in the given
          <link
              linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>.<footnote><para>
            The values of the flux offset are stored in the <link
            linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>
            as a vector, for all types of &Flux;.  This would be completely
            invisible to the user, if the name of the
            <classname>SmallSystem</classname> method for accessing
            the offset weren't <function>offsetVector()</function>.
          </para></footnote>
        </para>
        <para>
          As an example, consider <link
          linkend="PropertyType-ThermalExpansion">thermal
          expansion</link>. The flux (stress) is

          <equation id="Eqn-thermal-stress">
            <alt role="tex">
              \[
              \sigma_{ij} =
              C_{ijkl}\left(\epsilon_{kl} - \alpha_{kl}(T-T_0)\right).
              \]
            </alt>
          </equation>

          <inlineequation>
            <alt role="tex">
              \(\alpha_{kl}\)
            </alt>
          </inlineequation>

          is the thermal expansion coefficient and
            
          <inlineequation>
            <alt role="tex">
              \(T_0\)
            </alt>
          </inlineequation>
          is the temperature at which the thermal stress vanishes.

          The

          <inlineequation>
            <alt role="tex">
              \(
              C_{ijkl}\left(\epsilon_{kl}-\alpha_{kl}\,T\right)
              \)
            </alt>
          </inlineequation>

          term in <xref linkend="Eqn-thermal-stress"/> is handled by
          <methodname>ThermalExpansion::flux_matrix()</methodname>
          because of its field dependencies, but

          <inlineequation>
            <alt role="tex">
              \(C_{ijkl}\alpha_{kl}\,T_0\)
            </alt>
          </inlineequation>
          
          makes a field <emphasis>independent</emphasis> contribution
          to the flux, and needs to be handled by
          <function>flux_offset()</function>.
        </para>
        <para>
          The arguments to
          <methodname>FluxProperty::flux_offset()</methodname> are:
          <variablelist>
            <varlistentry>
              <term><code>const <link linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
              <listitem>
                <para>
		          The finite element mesh that's being solved.
		          <function>flux_offset()</function> probably doesn't
		          have to use the <varname>mesh</varname> object
		          directly, but it does have to pass it through to
		          other functions.
                </para>
              </listitem>
            </varlistentry>
	        <varlistentry>
	          <term><code>const <link linkend="Class-Element">Element</link>* element</code></term>
	          <listitem>
		        <para>
		          The finite <link
		          linkend="Class-Element">element</link> under
		          consideration.  This shouldn't be explicitly needed
		          except in cases in which the material parameters
		          depend on physical space coordinates or in which
		          history-dependent fields are stored in the element.
		        </para>
	          </listitem>
	        </varlistentry>
	        <varlistentry>
	          <term><code>const <link linkend="Class-Flux">Flux</link>*
	          flux</code></term>
	          <listitem>
		        <para>
		          The &flux; &sigma;.  Properties that contribute to
		          more than one &flux; need to check this variable to
		          know which flux they're computing now.
		        </para>
	          </listitem>
	        </varlistentry>
	        <varlistentry>
	          <term><code>const <link
	          linkend="Class-MasterCoord">MasterPosition</link>&amp; position</code></term>
	          <listitem>
		        <para>
		          The flux offset is evaluated at a physical
		          coordinate &boldx; (often a Gauss integration point,
		          but not always).  <varname>position</varname> is the
		          point in the <link
		          linkend="Class-Element"><classname>Element</classname></link>'s
		          <link linkend="Class-MasterPosition">master
		          coordinate space</link>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>double time</code></term>
              <listitem>
                <para>
                  The time at which the flux offset is being evaluated.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>void* data</code></term>
              <listitem>
                <para>
                  The data object, if any, returned by <link linkend="Class-FluxProperty-begin_point"><function>begin_point()</function></link>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code><link linkend="Class-SmallSystem">SmallSystem</link>*
                linsys</code>
              </term>
              <listitem>
                <para>
                  The <classname>SmallSystem</classname> class stores
                  the portion of the finite element matrices and
                  vectors that are currently being computed.  The
                  results of the <function>flux_offset()</function>
                  calculation are stored here.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>       <!-- flux_offset arguments -->
        </para>
        <refsection id="example-flux_offset">
          <title>Example of <function>flux_offset</function></title>
          <para>
            Here is the <function>flux_offset</function> routine for
            the <classname>ThermalExpansion</classname> class, from
            <filename>SRC/engine/properties/thermalexpansion/thermalexpansion.C</filename>:
          </para>
          <programlisting>
void ThermalExpansion::flux_offset(const FEMesh* mesh,
                   const Element* element,
                   const Flux* flux,
                   const MasterPosition&amp; x,
                   double time,
                   void* data, <co id="flux_offset-data"/>
                   SmallSystem* linsys)
  const
{

  if(*flux!=*stress_flux) { <co id="flux_offset-fluxcheck"/>
    throw ErrProgrammingError("Unexpected flux.", __FILE__, __LINE__);
  }
  const Cijkl modulus = elasticity->cijkl(mesh, element, x); <co id="flux_offset-modulus"/>
  SymmMatrix3 expten = expansiontensor(mesh, element, x); <co id="flux_offset-alpha"/>
  linsys->offsetVector() += modulus*expten*T0; <co id="flux_offset-eqn"/>
} </programlisting>
          <calloutlist>
            <callout arearefs="flux_offset-data">
              <para>
                This is the object returned by <link
                linkend="Class-FluxProperty-begin_point"><function>begin_point()</function></link>.
              </para>
            </callout>
            <callout arearefs="flux_offset-fluxcheck">
              <para>
                This is optional here, to check that we got the &Flux;
                we were expecting.  If a
                <classname>FluxProperty</classname> contributes to
                more than one &Flux;, then a statement like this can
                be used to determine which one is being computed.  The
                variable <varname>stress_flux</varname> was set by the
                <classname>ThermalExpansion</classname> constructor by
                calling <code><link
                linkend="Function-getFlux">Flux::get_Flux</link>("Stress")</code>
                and dynamically casting the result to a <code><link
                linkend="Class-SymmetricTensorFlux">SymmetricTensorFlux</link>*</code>.
              </para>
            </callout>
            <callout arearefs="flux_offset-modulus">
              <para>
                This extracts the elastic modulus from the <link
                linkend="Class-Material"><classname>Material</classname>'s</link>
                <literal>Elasticity</literal>
                <classname>Property</classname>.
                <varname>elasticity</varname> is a variable set in
                <link
                linkend="Class-Property-cross_reference"><methodname>ThermalExpansion::cross_reference()</methodname></link>
                by calling <code><link
                linkend="Class-Material-fetchProperty">Material::fetchProperty</link>("Elasticity")</code>.
              </para>
            </callout>
            <callout arearefs="flux_offset-alpha">
              <para>
                This is <inlineequation><alt
                role="tex">\(\alpha_{kl}\)</alt></inlineequation> in
                <xref linkend="Eqn-thermal-stress"/>.
                <function>expansiontensor()</function> is a virtual
                function in the
                <classname>ThermalExpansion</classname> class.  The
                various isotropic and anisotropic subclasses define
                <function>expansiontensor()</function> in different
                ways.
              </para>
            </callout>
            <callout arearefs="flux_offset-eqn">
              <para>
                <link
                linkend="Class-SmallSystem-offsetVector"><function>SmallSystem::offsetVector()</function></link>
                returns a reference to flux offset
                vector &sigma0;.  This line increments it according to
                <xref linkend="Eqn-thermal-stress"/>.  It is important
                to <emphasis>increment</emphasis> it instead of
                setting it, because some other &Property; may already
                have made a contribution to the same vector.
              </para>
              <para>
                &sigma0; is stored as a vector even though the Stress
                is a tensor.  It's treated as a list of values in an
                order determined by the <link
                linkend="Class-FieldIndex-integer"><function>integer()</function></link>
                method of the <link
                linkend="Class-SymTensorIndex"><classname>SymTensorIndex</classname></link>
                class.
              </para>
              
            </callout>
          </calloutlist>

          <para>
            The example above uses C++ vectors and tensors.  An
            equivalent way of writing it explicitly loops over their
            components:
          </para>
          
          <programlisting>
void ThermalExpansion::flux_offset(const FEMesh* mesh,
                   const Element* element,
                   const Flux* flux,
                   const MasterPosition&amp; x,
                   double time,
                   void* data,
                   SmallSystem* linsys) const {

  if(*flux != *stress_flux) { 
    throw ErrProgrammingError("Unexpected flux.", __FILE__, __LINE__);
  }
  const Cijkl modulus = elasticity->cijkl(mesh, element, x); 
  SymmMatrix3 expten = expansiontensor(mesh, element, x);

  for(IndexP ij : *flux->components(ALL_INDICES)) { <co id="flux_offset-loop"/>
    double &amp;offset_el = linsys->offset_vector_element(ij); <co id="flux_offset-reference"/>
    for(SymTensorIndex kl : symTensorIJComponents) { <co id="flux_offset-loop2"/>
      if(kl.diagonal()) { <co id="flux_offset-diagonal"/>
	offset_el += modulus(ij,kl)*expten[kl]*T0;
      }
      else {
	offset_el += 2.0*modulus(ij,kl)*expten[kl]*T0;
      }
    }
  }
}
          </programlisting>
          <calloutlist>
            <callout arearefs="flux_offset-loop">
              <para>
                This loop is over all components of the stress, even
                if the problem is being solved in plane stress.  The
                out-of-plane components are used in the constraint
                equations.  Looping over components is discussed in
                <xref linkend="Section-Coding-Indices"/>.
            </para>
            </callout>
            <callout arearefs="flux_offset-reference">
              <para>
                <varname>offset_el</varname> is a reference to the
                <varname>ij</varname> component of &sigma0; in the
                <link
                linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>
                object.  This value will be incorporated into the
                global vectors constructed by
                <classname>SmallSystem</classname>.
              </para>
            </callout>
            <callout arearefs="flux_offset-loop2">
              <para>
                This loops over all components of the stress.  The
                line could have been written
              <programlisting>
for(IndexP kl : *flux->components(ALL_INDICES)) { ... } </programlisting>
                but the generic <link
                linkend="Class-IndexP"><classname>IndexP</classname></link>
                would have to be cast into a <link
                linkend="Class-SymTensorIndex"><classname>SymTensorIndex*</classname></link>
                in order to call <link
                linkend="Class-SymTensorIndex-diagonal"><methodname>SymTensorIndex::diagonal()</methodname></link>
                on the next line.<footnote><para>
                It would look like
                <programlisting>
for(IndexP kl : *flux->components(ALL_INDICES)) {
  const SymTensorIndex* kayell = dynamic_cast&lt;const SymTensorIndex*&gt;(kl.fieldindex());
  if(kayell->diagonal()) {
    offset_el -= modulus(ij,kl)*expten[kl]*T0;
  }
  else {
    offset_el -= 2.0*modulus(ij,kl)*expten[kl]*T0;
  }
} </programlisting></para></footnote>
              Using <link
              linkend="Class-SymTensorIJComponents"><varname>symTensorIJComponents</varname></link>
              (note the lower-case <quote>s</quote>!) avoids this
              complication.
              </para>
            </callout>
            <callout arearefs="flux_offset-diagonal">
              <para>
                The loop over the components of the symmetric tensor
                flux hits each independent component once, but when
                multiplying tensors, the off-diagonal components occur
                twice, leading to a factor of two in the off-diagonal
                terms.  This complication can be avoided by using the
                tensor multiplication operators directly, as in the
                simpler example above.
              </para>
            </callout>
          </calloutlist>
        </refsection>           <!-- example flux_offset -->
      </refsection>             <!-- flux_offset-->

      <refsection id="Class-FluxProperty-flux_value">
        <title> <code>void flux_value(...) const</code> </title>
        <programlisting>
void flux_value(const <link linkend="Class-FEMesh">FEMesh</link>* mesh,
                const <link linkend="Class-Element">Element</link>* element,
                const <link linkend="Class-Flux">Flux</link>* flux,
                const <link linkend="Class-MasterPosition">MasterPosition</link>&amp; position,
                double time,
                void* data,
                <link linkend="Class-SmallSystem">SmallSystem</link> *linysys) const </programlisting>
        <para>
          <function>flux_value()</function> computes the value of a
          given &flux;, at a given point in an &elem;, as in <xref
          linkend="Eqn-flux1"/>.  It is used when solving nonlinear
          equations and when computing flux-dependent <link
          linkend="Section-Output"><classname>Outputs</classname></link>.
        </para>
        <para>
          The default base class version of
          <function>flux_value()</function> uses <link
          linkend="Class-FluxProperty-flux_matrix"><function>flux_property()</function></link>,
          <link
          linkend="Class-FluxProperty-flux_offset"><function>flux_offset()</function></link>,
          and the &field; values to evaluate <xref
          linkend="Eqn-flux1"/>.  A subclass of
          <classname>FluxProperty</classname> should redefine
          <function>flux_value()</function> if for some reason it is
          faster or more accurate to compute the &flux; directly than
          it is to use <xref linkend="Eqn-flux1"/>.  If the &flux; is
          a nonlinear function of the &fields;, it should always
          define <function>flux_value()</function>.
        </para>
        <para>
          The arguments to <function>flux_value()</function> are:
          <variablelist>
            <varlistentry>
              <term><code>const <link
              linkend="Class-FEMesh">FEMesh</link>* mesh</code></term>
              <listitem>
                <para>
                  The <link
                  linkend="Class-FEMesh"><classname>FEMesh</classname></link>
                  currently being solved or evaluated.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>const <link
              linkend="Class-Element">Element</link>* element</code></term>
              <listitem>
                <para>
                  The <link
                  linkend="Class-Element"><classname>Element</classname></link>
                  containing the current point.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>const <link linkend="Class-Flux">Flux</link>*
              flux</code></term>
              <listitem>
                <para>
                  The &flux; that is being computed.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>const <link
              linkend="Class-MasterPosition">MasterPosition</link>&amp;
              position</code></term>
              <listitem>
                <para>
                  The position within the <link
                  linkend="Class-Element"><classname>Element</classname></link>
                  where the &Property; is being evaluated.  The
                  position is given in <link
                  linkend="Class-MasterPosition">master
                  coordinates</link>, which can be converted to
                  physical coordinates by <link
                  linkend="Class-Element-from_master"><function>Element::from_master()</function></link>
                  if necessary.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>double time</code></term>
              <listitem>
                <para>
                  The time at which the &flux; is being computed.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><code>void* data</code></term>
              <listitem>
                <para>
                  The data object, if any, returned by <link linkend="Class-FluxProperty-begin_point"><function>begin_point()</function></link>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code><link linkend="Class-SmallSystem">SmallSystem</link>*
                linsys</code>
              </term>
              <listitem>
                <para>
                  The <classname>SmallSystem</classname> class stores
                  the portion of the finite element matrices and
                  vectors that are currently being computed.  The
                  results of the <function>flux_value()</function>
                  calculation are stored here.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </para>
        <refsection id="example-flux_value">
          <title>Example of <function>flux_value()</function></title>
          <para>
            Here is the <function>flux_value()</function> routine for
            the thermal conductivity property, from
            <filename>SRC/engine/properties/heatconductivity/heatconductivity.C</filename>
            in the &oof2; source code.  (Note that it could have been
            omitted, since in this case the heat flux can be computed
            from <function>flux_matrix</function> alone.)
          </para>
          <programlisting>
void HeatConductivity::flux_value(
            const FEMesh *mesh,
            const Element *element,
            const Flux *flux,
            const MasterPosition &amp;position,
            double time,
            void* data,
            SmallSystem *fluxdata)
  const
{
  DoubleVec fieldGradient = temperature->gradient(mesh, element, pt); <co id="flux_value-gradient"/>
  const SymmMatrix3 cond(conductivitytensor(mesh, element, pt)); <co id="flux_value-modulus"/>
  linsys->fluxVector() -= cond*fieldGradient; <co id="flux_value-result"/>
}
            </programlisting>
            <calloutlist>
              <callout arearefs="flux_value-gradient">
                <para>
                  <varname>temperature</varname> is a <link linkend="Class-ScalarField"><classname>ScalarField</classname>*</link>; stored
                  in the <classname>HeatConductivity</classname>
                  class.  It was initialized by calling
                  Field::getField() in the
                  <classname>HeatConductivity</classname> constructor. <link
                  linkend="Class-Field-gradient"><function>Field::gradient()</function></link>
                  returns an object containing all the components of a &Field;.
                </para>
              </callout>
              <callout arearefs="flux_value-modulus">
                <para>
                  <function>conductivitytensor()</function> is a
                  virtual function.  The various isotropic and
                  anisotropic subclasses of
                  <classname>HeatConductivity</classname> define it
                  differently.
                </para>
              </callout>
              <callout arearefs="flux_value-result">
                <para>
                  <function>SmallSystem::fluxVector()</function>
                  returns a reference to the &Flux; components stored
                  in the <link
                  linkend="Class-SmallSystem"><classname>SmallSystem</classname></link>.
                  Like the offset described in <link
                  linkend="Class-FluxProperty-flux_offset"><function>flux_offset()</function></link>,
                  it's always stored as a vector, independent of the
                  type of the &Flux;.  
                </para>
              </callout>
            </calloutlist>
          </refsection>           <!-- example flux_value -->
      </refsection>             <!-- flux_value -->

      <refsection id="Class-FluxProperty-static_flux_value">
        <title><code>void static_flux_value(...) const</code></title>
        <programlisting>
void static_flux_value(const <link linkend="Class-FEMesh">FEMesh</link>* mesh,
                       const <link linkend="Class-Element">Element</link>* element,
                       const <link linkend="Class-Flux">Flux</link>* flux,
                       const <link linkend="Class-MasterPosition">MasterPosition</link>&amp; position,
                       double time,
                       void* data,
                       <link linkend="Class-SmallSystem">SmallSystem</link> *linysys) const </programlisting>

        <para>
          <function>static_flux_value()</function> computes the part
          of the &flux; that depends only on the &fields; and not on
          their time derivatives. It only needs to be defined if the
          &flux; depends on the time derivatives of the &fields; and
          is nonlinear.  Its arguments are the same as the arguments
          to <link
          linkend="Class-FluxProperty-flux_value"><function>flux_value()</function></link>.
        </para>
        <para>
          In the base class, <function>static_flux_value()</function>
          simply calls <link
          linkend="Class-FluxProperty-flux_value"><function>flux_value()</function></link>.
        </para>

      </refsection>             <!-- static_flux_value -->
  
  </refsection>               <!-- FluxProperty Methods-->
  
</refentry>                    <!-- FluxProperty -->



  <!-- Keep this comment at the end of the file
  Local variables:
  sgml-omittag:t
  sgml-shorttag:t 
  sgml-namecase-general:nil
  sgml-minimize-attributes:nil
  sgml-always-quote-attributes:t
  sgml-indent-step:2
  sgml-indent-data:t
  sgml-parent-document:("man_oof2.xml" "book" "part" "reference")
  sgml-exposed-tags:nil
  sgml-local-ecat-files:nil
  End:
-->
